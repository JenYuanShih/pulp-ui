/* tslint:disable */
/* eslint-disable */
/**
 * Pulp 3 API
 * Fetch, Upload, Organize, and Distribute Software Packages
 *
 * The version of the OpenAPI document: v3
 * Contact: pulp-list@redhat.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Addon serializer.
 * @export
 * @interface AddonResponse
 */
export interface AddonResponse {
    /**
     * Addon id.
     * @type {string}
     * @memberof AddonResponse
     */
    addon_id: string;
    /**
     * Addon uid.
     * @type {string}
     * @memberof AddonResponse
     */
    uid: string;
    /**
     * Addon name.
     * @type {string}
     * @memberof AddonResponse
     */
    name: string;
    /**
     * Addon type.
     * @type {string}
     * @memberof AddonResponse
     */
    type: string;
    /**
     * Relative path to directory with binary RPMs.
     * @type {string}
     * @memberof AddonResponse
     */
    packages: string;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface ArtifactResponse
 */
export interface ArtifactResponse {
    /**
     * 
     * @type {string}
     * @memberof ArtifactResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof ArtifactResponse
     */
    pulp_created?: string;
    /**
     * The stored file.
     * @type {string}
     * @memberof ArtifactResponse
     */
    file: string;
    /**
     * The size of the file in bytes.
     * @type {number}
     * @memberof ArtifactResponse
     */
    size?: number;
    /**
     * The MD5 checksum of the file if available.
     * @type {string}
     * @memberof ArtifactResponse
     */
    md5?: string | null;
    /**
     * The SHA-1 checksum of the file if available.
     * @type {string}
     * @memberof ArtifactResponse
     */
    sha1?: string | null;
    /**
     * The SHA-224 checksum of the file if available.
     * @type {string}
     * @memberof ArtifactResponse
     */
    sha224?: string | null;
    /**
     * The SHA-256 checksum of the file if available.
     * @type {string}
     * @memberof ArtifactResponse
     */
    sha256?: string | null;
    /**
     * The SHA-384 checksum of the file if available.
     * @type {string}
     * @memberof ArtifactResponse
     */
    sha384?: string | null;
    /**
     * The SHA-512 checksum of the file if available.
     * @type {string}
     * @memberof ArtifactResponse
     */
    sha512?: string | null;
}
/**
 * Serializer for asynchronous operations.
 * @export
 * @interface AsyncOperationResponse
 */
export interface AsyncOperationResponse {
    /**
     * The href of the task.
     * @type {string}
     * @memberof AsyncOperationResponse
     */
    task: string;
}
/**
 * Checksum serializer.
 * @export
 * @interface ChecksumResponse
 */
export interface ChecksumResponse {
    /**
     * File path.
     * @type {string}
     * @memberof ChecksumResponse
     */
    path: string;
    /**
     * Checksum for the file.
     * @type {string}
     * @memberof ChecksumResponse
     */
    checksum: string;
}
/**
 * Serializer for the RepositoryVersion content summary
 * @export
 * @interface ContentSummary
 */
export interface ContentSummary {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ContentSummary
     */
    added: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ContentSummary
     */
    removed: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ContentSummary
     */
    present: { [key: string]: object; };
}
/**
 * Serializer for the RepositoryVersion content summary
 * @export
 * @interface ContentSummaryResponse
 */
export interface ContentSummaryResponse {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ContentSummaryResponse
     */
    added: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ContentSummaryResponse
     */
    removed: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ContentSummaryResponse
     */
    present: { [key: string]: object; };
}
/**
 * A serializer for Content Copy API.
 * @export
 * @interface Copy
 */
export interface Copy {
    /**
     * A JSON document describing sources, destinations, and content to be copied
     * @type {object}
     * @memberof Copy
     */
    config: object;
    /**
     * Also copy dependencies of the content being copied.
     * @type {boolean}
     * @memberof Copy
     */
    dependency_solving?: boolean;
}
/**
 * Image serializer.
 * @export
 * @interface ImageResponse
 */
export interface ImageResponse {
    /**
     * File name.
     * @type {string}
     * @memberof ImageResponse
     */
    name: string;
    /**
     * File path.
     * @type {string}
     * @memberof ImageResponse
     */
    path: string;
    /**
     * Compatible platforms.
     * @type {string}
     * @memberof ImageResponse
     */
    platforms: string;
    /**
     * 
     * @type {ArtifactResponse}
     * @memberof ImageResponse
     */
    artifact: ArtifactResponse | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum MetadataChecksumTypeEnum {
    Unknown = 'unknown',
    Md5 = 'md5',
    Sha1 = 'sha1',
    Sha224 = 'sha224',
    Sha256 = 'sha256',
    Sha384 = 'sha384',
    Sha512 = 'sha512'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum PackageChecksumTypeEnum {
    Unknown = 'unknown',
    Md5 = 'md5',
    Sha1 = 'sha1',
    Sha224 = 'sha224',
    Sha256 = 'sha256',
    Sha384 = 'sha384',
    Sha512 = 'sha512'
}

/**
 * 
 * @export
 * @interface PaginatedRepositoryVersionResponseList
 */
export interface PaginatedRepositoryVersionResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRepositoryVersionResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRepositoryVersionResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRepositoryVersionResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RepositoryVersionResponse>}
     * @memberof PaginatedRepositoryVersionResponseList
     */
    results?: Array<RepositoryVersionResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedrpmDistributionTreeResponseList
 */
export interface PaginatedrpmDistributionTreeResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedrpmDistributionTreeResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmDistributionTreeResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmDistributionTreeResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RpmDistributionTreeResponse>}
     * @memberof PaginatedrpmDistributionTreeResponseList
     */
    results?: Array<RpmDistributionTreeResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedrpmModulemdDefaultsResponseList
 */
export interface PaginatedrpmModulemdDefaultsResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedrpmModulemdDefaultsResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmModulemdDefaultsResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmModulemdDefaultsResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RpmModulemdDefaultsResponse>}
     * @memberof PaginatedrpmModulemdDefaultsResponseList
     */
    results?: Array<RpmModulemdDefaultsResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedrpmModulemdResponseList
 */
export interface PaginatedrpmModulemdResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedrpmModulemdResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmModulemdResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmModulemdResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RpmModulemdResponse>}
     * @memberof PaginatedrpmModulemdResponseList
     */
    results?: Array<RpmModulemdResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedrpmPackageCategoryResponseList
 */
export interface PaginatedrpmPackageCategoryResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedrpmPackageCategoryResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmPackageCategoryResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmPackageCategoryResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RpmPackageCategoryResponse>}
     * @memberof PaginatedrpmPackageCategoryResponseList
     */
    results?: Array<RpmPackageCategoryResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedrpmPackageEnvironmentResponseList
 */
export interface PaginatedrpmPackageEnvironmentResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedrpmPackageEnvironmentResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmPackageEnvironmentResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmPackageEnvironmentResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RpmPackageEnvironmentResponse>}
     * @memberof PaginatedrpmPackageEnvironmentResponseList
     */
    results?: Array<RpmPackageEnvironmentResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedrpmPackageGroupResponseList
 */
export interface PaginatedrpmPackageGroupResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedrpmPackageGroupResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmPackageGroupResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmPackageGroupResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RpmPackageGroupResponse>}
     * @memberof PaginatedrpmPackageGroupResponseList
     */
    results?: Array<RpmPackageGroupResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedrpmPackageLangpacksResponseList
 */
export interface PaginatedrpmPackageLangpacksResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedrpmPackageLangpacksResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmPackageLangpacksResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmPackageLangpacksResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RpmPackageLangpacksResponse>}
     * @memberof PaginatedrpmPackageLangpacksResponseList
     */
    results?: Array<RpmPackageLangpacksResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedrpmPackageResponseList
 */
export interface PaginatedrpmPackageResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedrpmPackageResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmPackageResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmPackageResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RpmPackageResponse>}
     * @memberof PaginatedrpmPackageResponseList
     */
    results?: Array<RpmPackageResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedrpmRepoMetadataFileResponseList
 */
export interface PaginatedrpmRepoMetadataFileResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedrpmRepoMetadataFileResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmRepoMetadataFileResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmRepoMetadataFileResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RpmRepoMetadataFileResponse>}
     * @memberof PaginatedrpmRepoMetadataFileResponseList
     */
    results?: Array<RpmRepoMetadataFileResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedrpmRpmDistributionResponseList
 */
export interface PaginatedrpmRpmDistributionResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedrpmRpmDistributionResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmRpmDistributionResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmRpmDistributionResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RpmRpmDistributionResponse>}
     * @memberof PaginatedrpmRpmDistributionResponseList
     */
    results?: Array<RpmRpmDistributionResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedrpmRpmPublicationResponseList
 */
export interface PaginatedrpmRpmPublicationResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedrpmRpmPublicationResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmRpmPublicationResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmRpmPublicationResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RpmRpmPublicationResponse>}
     * @memberof PaginatedrpmRpmPublicationResponseList
     */
    results?: Array<RpmRpmPublicationResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedrpmRpmRemoteResponseList
 */
export interface PaginatedrpmRpmRemoteResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedrpmRpmRemoteResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmRpmRemoteResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmRpmRemoteResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RpmRpmRemoteResponse>}
     * @memberof PaginatedrpmRpmRemoteResponseList
     */
    results?: Array<RpmRpmRemoteResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedrpmRpmRepositoryResponseList
 */
export interface PaginatedrpmRpmRepositoryResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedrpmRpmRepositoryResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmRpmRepositoryResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmRpmRepositoryResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RpmRpmRepositoryResponse>}
     * @memberof PaginatedrpmRpmRepositoryResponseList
     */
    results?: Array<RpmRpmRepositoryResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedrpmUlnRemoteResponseList
 */
export interface PaginatedrpmUlnRemoteResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedrpmUlnRemoteResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmUlnRemoteResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmUlnRemoteResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RpmUlnRemoteResponse>}
     * @memberof PaginatedrpmUlnRemoteResponseList
     */
    results?: Array<RpmUlnRemoteResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedrpmUpdateRecordResponseList
 */
export interface PaginatedrpmUpdateRecordResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedrpmUpdateRecordResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmUpdateRecordResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedrpmUpdateRecordResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RpmUpdateRecordResponse>}
     * @memberof PaginatedrpmUpdateRecordResponseList
     */
    results?: Array<RpmUpdateRecordResponse>;
}
/**
 * Serializer for RPM Distributions.
 * @export
 * @interface PatchedrpmRpmDistribution
 */
export interface PatchedrpmRpmDistribution {
    /**
     * The base (relative) path component of the published url. Avoid paths that                     overlap with other distribution base paths (e.g. \"foo\" and \"foo/bar\")
     * @type {string}
     * @memberof PatchedrpmRpmDistribution
     */
    base_path?: string;
    /**
     * An optional content-guard.
     * @type {string}
     * @memberof PatchedrpmRpmDistribution
     */
    content_guard?: string | null;
    /**
     * 
     * @type {object}
     * @memberof PatchedrpmRpmDistribution
     */
    pulp_labels?: object;
    /**
     * A unique name. Ex, `rawhide` and `stable`.
     * @type {string}
     * @memberof PatchedrpmRpmDistribution
     */
    name?: string;
    /**
     * The latest RepositoryVersion for this Repository will be served.
     * @type {string}
     * @memberof PatchedrpmRpmDistribution
     */
    repository?: string | null;
    /**
     * Publication to be served
     * @type {string}
     * @memberof PatchedrpmRpmDistribution
     */
    publication?: string | null;
}
/**
 * A Serializer for RpmRemote.
 * @export
 * @interface PatchedrpmRpmRemote
 */
export interface PatchedrpmRpmRemote {
    /**
     * A unique name for this remote.
     * @type {string}
     * @memberof PatchedrpmRpmRemote
     */
    name?: string;
    /**
     * The URL of an external content source.
     * @type {string}
     * @memberof PatchedrpmRpmRemote
     */
    url?: string;
    /**
     * A PEM encoded CA certificate used to validate the server certificate presented by the remote server.
     * @type {string}
     * @memberof PatchedrpmRpmRemote
     */
    ca_cert?: string | null;
    /**
     * A PEM encoded client certificate used for authentication.
     * @type {string}
     * @memberof PatchedrpmRpmRemote
     */
    client_cert?: string | null;
    /**
     * A PEM encoded private key used for authentication.
     * @type {string}
     * @memberof PatchedrpmRpmRemote
     */
    client_key?: string | null;
    /**
     * If True, TLS peer validation must be performed.
     * @type {boolean}
     * @memberof PatchedrpmRpmRemote
     */
    tls_validation?: boolean;
    /**
     * The proxy URL. Format: scheme://host:port
     * @type {string}
     * @memberof PatchedrpmRpmRemote
     */
    proxy_url?: string | null;
    /**
     * The username to authenticte to the proxy.
     * @type {string}
     * @memberof PatchedrpmRpmRemote
     */
    proxy_username?: string | null;
    /**
     * The password to authenticte to the proxy.
     * @type {string}
     * @memberof PatchedrpmRpmRemote
     */
    proxy_password?: string | null;
    /**
     * The username to be used for authentication when syncing.
     * @type {string}
     * @memberof PatchedrpmRpmRemote
     */
    username?: string | null;
    /**
     * The password to be used for authentication when syncing.
     * @type {string}
     * @memberof PatchedrpmRpmRemote
     */
    password?: string | null;
    /**
     * 
     * @type {object}
     * @memberof PatchedrpmRpmRemote
     */
    pulp_labels?: object;
    /**
     * Total number of simultaneous connections. If not set then the default value will be used.
     * @type {number}
     * @memberof PatchedrpmRpmRemote
     */
    download_concurrency?: number | null;
    /**
     * Maximum number of retry attempts after a download failure. If not set then the default value (3) will be used.
     * @type {number}
     * @memberof PatchedrpmRpmRemote
     */
    max_retries?: number | null;
    /**
     * The policy to use when downloading content. The possible values include: \'immediate\', \'on_demand\', and \'streamed\'. \'immediate\' is the default.
     * @type {PolicyEnum}
     * @memberof PatchedrpmRpmRemote
     */
    policy?: PolicyEnum;
    /**
     * aiohttp.ClientTimeout.total (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof PatchedrpmRpmRemote
     */
    total_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.connect (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof PatchedrpmRpmRemote
     */
    connect_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.sock_connect (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof PatchedrpmRpmRemote
     */
    sock_connect_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.sock_read (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof PatchedrpmRpmRemote
     */
    sock_read_timeout?: number | null;
    /**
     * Headers for aiohttp.Clientsession
     * @type {Array<object>}
     * @memberof PatchedrpmRpmRemote
     */
    headers?: Array<object>;
    /**
     * Limits total download rate in requests per second
     * @type {number}
     * @memberof PatchedrpmRpmRemote
     */
    rate_limit?: number | null;
    /**
     * Authentication token for SLES repositories.
     * @type {string}
     * @memberof PatchedrpmRpmRemote
     */
    sles_auth_token?: string | null;
}
/**
 * Serializer for Rpm Repositories.
 * @export
 * @interface PatchedrpmRpmRepository
 */
export interface PatchedrpmRpmRepository {
    /**
     * 
     * @type {object}
     * @memberof PatchedrpmRpmRepository
     */
    pulp_labels?: object;
    /**
     * A unique name for this repository.
     * @type {string}
     * @memberof PatchedrpmRpmRepository
     */
    name?: string;
    /**
     * An optional description.
     * @type {string}
     * @memberof PatchedrpmRpmRepository
     */
    description?: string | null;
    /**
     * Retain X versions of the repository. Default is null which retains all versions. This is provided as a tech preview in Pulp 3 and may change in the future.
     * @type {number}
     * @memberof PatchedrpmRpmRepository
     */
    retain_repo_versions?: number | null;
    /**
     * An optional remote to use by default when syncing.
     * @type {string}
     * @memberof PatchedrpmRpmRepository
     */
    remote?: string | null;
    /**
     * Whether to automatically create publications for new repository versions, and update any distributions pointing to this repository.
     * @type {boolean}
     * @memberof PatchedrpmRpmRepository
     */
    autopublish?: boolean;
    /**
     * A reference to an associated signing service.
     * @type {string}
     * @memberof PatchedrpmRpmRepository
     */
    metadata_signing_service?: string | null;
    /**
     * The number of versions of each package to keep in the repository; older versions will be purged. The default is \'0\', which will disable this feature and keep all versions of each package.
     * @type {number}
     * @memberof PatchedrpmRpmRepository
     */
    retain_package_versions?: number;
    /**
     * The checksum type for metadata.
     * @type {MetadataChecksumTypeEnum}
     * @memberof PatchedrpmRpmRepository
     */
    metadata_checksum_type?: MetadataChecksumTypeEnum | null;
    /**
     * The checksum type for packages.
     * @type {PackageChecksumTypeEnum}
     * @memberof PatchedrpmRpmRepository
     */
    package_checksum_type?: PackageChecksumTypeEnum | null;
    /**
     * An option specifying whether a client should perform a GPG signature check on packages.
     * @type {number}
     * @memberof PatchedrpmRpmRepository
     */
    gpgcheck?: number;
    /**
     * An option specifying whether a client should perform a GPG signature check on the repodata.
     * @type {number}
     * @memberof PatchedrpmRpmRepository
     */
    repo_gpgcheck?: number;
    /**
     * An option specifying whether Pulp should generate SQLite metadata.
     * @type {boolean}
     * @memberof PatchedrpmRpmRepository
     */
    sqlite_metadata?: boolean;
}
/**
 * A Serializer for UlnRemote.
 * @export
 * @interface PatchedrpmUlnRemote
 */
export interface PatchedrpmUlnRemote {
    /**
     * A unique name for this remote.
     * @type {string}
     * @memberof PatchedrpmUlnRemote
     */
    name?: string;
    /**
     * The ULN repo URL of the remote content source.\"This is \"uln://\" followed by the channel name. E.g.: \"uln://ol7_x86_64_oracle\"
     * @type {string}
     * @memberof PatchedrpmUlnRemote
     */
    url?: string;
    /**
     * A PEM encoded CA certificate used to validate the server certificate presented by the remote server.
     * @type {string}
     * @memberof PatchedrpmUlnRemote
     */
    ca_cert?: string | null;
    /**
     * A PEM encoded client certificate used for authentication.
     * @type {string}
     * @memberof PatchedrpmUlnRemote
     */
    client_cert?: string | null;
    /**
     * A PEM encoded private key used for authentication.
     * @type {string}
     * @memberof PatchedrpmUlnRemote
     */
    client_key?: string | null;
    /**
     * If True, TLS peer validation must be performed.
     * @type {boolean}
     * @memberof PatchedrpmUlnRemote
     */
    tls_validation?: boolean;
    /**
     * The proxy URL. Format: scheme://host:port
     * @type {string}
     * @memberof PatchedrpmUlnRemote
     */
    proxy_url?: string | null;
    /**
     * The username to authenticte to the proxy.
     * @type {string}
     * @memberof PatchedrpmUlnRemote
     */
    proxy_username?: string | null;
    /**
     * The password to authenticte to the proxy.
     * @type {string}
     * @memberof PatchedrpmUlnRemote
     */
    proxy_password?: string | null;
    /**
     * Your ULN account username.
     * @type {string}
     * @memberof PatchedrpmUlnRemote
     */
    username?: string;
    /**
     * Your ULN account password.
     * @type {string}
     * @memberof PatchedrpmUlnRemote
     */
    password?: string;
    /**
     * 
     * @type {object}
     * @memberof PatchedrpmUlnRemote
     */
    pulp_labels?: object;
    /**
     * Total number of simultaneous connections. If not set then the default value will be used.
     * @type {number}
     * @memberof PatchedrpmUlnRemote
     */
    download_concurrency?: number | null;
    /**
     * Maximum number of retry attempts after a download failure. If not set then the default value (3) will be used.
     * @type {number}
     * @memberof PatchedrpmUlnRemote
     */
    max_retries?: number | null;
    /**
     * The policy to use when downloading content. The possible values include: \'immediate\', \'on_demand\', and \'streamed\'. \'immediate\' is the default.
     * @type {PolicyEnum}
     * @memberof PatchedrpmUlnRemote
     */
    policy?: PolicyEnum;
    /**
     * aiohttp.ClientTimeout.total (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof PatchedrpmUlnRemote
     */
    total_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.connect (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof PatchedrpmUlnRemote
     */
    connect_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.sock_connect (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof PatchedrpmUlnRemote
     */
    sock_connect_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.sock_read (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof PatchedrpmUlnRemote
     */
    sock_read_timeout?: number | null;
    /**
     * Headers for aiohttp.Clientsession
     * @type {Array<object>}
     * @memberof PatchedrpmUlnRemote
     */
    headers?: Array<object>;
    /**
     * Limits total download rate in requests per second
     * @type {number}
     * @memberof PatchedrpmUlnRemote
     */
    rate_limit?: number | null;
    /**
     * Base URL of the ULN server. If the uln_server_base_url is not provided pulp_rpm willuse the contents of the DEFAULT_ULN_SERVER_BASE_URL setting instead.
     * @type {string}
     * @memberof PatchedrpmUlnRemote
     */
    uln_server_base_url?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum PolicyEnum {
    Immediate = 'immediate',
    OnDemand = 'on_demand',
    Streamed = 'streamed'
}

/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface RepositoryAddRemoveContent
 */
export interface RepositoryAddRemoveContent {
    /**
     * A list of content units to add to a new repository version. This content is added after remove_content_units are removed.
     * @type {Array<any>}
     * @memberof RepositoryAddRemoveContent
     */
    add_content_units?: Array<any>;
    /**
     * A list of content units to remove from the latest repository version. You may also specify \'*\' as an entry to remove all content. This content is removed before add_content_units are added.
     * @type {Array<any>}
     * @memberof RepositoryAddRemoveContent
     */
    remove_content_units?: Array<any>;
    /**
     * A repository version whose content will be used as the initial set of content for the new repository version
     * @type {string}
     * @memberof RepositoryAddRemoveContent
     */
    base_version?: string;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface RepositoryVersion
 */
export interface RepositoryVersion {
    /**
     * A repository version whose content was used as the initial set of content for this repository version
     * @type {string}
     * @memberof RepositoryVersion
     */
    base_version?: string;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface RepositoryVersionResponse
 */
export interface RepositoryVersionResponse {
    /**
     * 
     * @type {string}
     * @memberof RepositoryVersionResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof RepositoryVersionResponse
     */
    pulp_created?: string;
    /**
     * 
     * @type {number}
     * @memberof RepositoryVersionResponse
     */
    number?: number;
    /**
     * 
     * @type {string}
     * @memberof RepositoryVersionResponse
     */
    repository?: string;
    /**
     * A repository version whose content was used as the initial set of content for this repository version
     * @type {string}
     * @memberof RepositoryVersionResponse
     */
    base_version?: string;
    /**
     * Various count summaries of the content in the version and the HREF to view them.
     * @type {ContentSummaryResponse}
     * @memberof RepositoryVersionResponse
     */
    content_summary?: ContentSummaryResponse;
}
/**
 * DistributionTree serializer.
 * @export
 * @interface RpmDistributionTreeResponse
 */
export interface RpmDistributionTreeResponse {
    /**
     * 
     * @type {string}
     * @memberof RpmDistributionTreeResponse
     */
    pulp_href?: string;
    /**
     * Header Version.
     * @type {string}
     * @memberof RpmDistributionTreeResponse
     */
    header_version: string;
    /**
     * Release name.
     * @type {string}
     * @memberof RpmDistributionTreeResponse
     */
    release_name: string;
    /**
     * Release short name.
     * @type {string}
     * @memberof RpmDistributionTreeResponse
     */
    release_short: string;
    /**
     * Release version.
     * @type {string}
     * @memberof RpmDistributionTreeResponse
     */
    release_version: string;
    /**
     * Typically False for an operating system, True otherwise.
     * @type {boolean}
     * @memberof RpmDistributionTreeResponse
     */
    release_is_layered: boolean;
    /**
     * Base Product name.
     * @type {string}
     * @memberof RpmDistributionTreeResponse
     */
    base_product_name: string | null;
    /**
     * Base Product short name.
     * @type {string}
     * @memberof RpmDistributionTreeResponse
     */
    base_product_short: string | null;
    /**
     * Base Product version.
     * @type {string}
     * @memberof RpmDistributionTreeResponse
     */
    base_product_version: string | null;
    /**
     * Tree architecturerch.
     * @type {string}
     * @memberof RpmDistributionTreeResponse
     */
    arch: string;
    /**
     * Tree build time timestamp.
     * @type {number}
     * @memberof RpmDistributionTreeResponse
     */
    build_timestamp: number;
    /**
     * Relative path to Anaconda instimage.
     * @type {string}
     * @memberof RpmDistributionTreeResponse
     */
    instimage: string | null;
    /**
     * Relative path to Anaconda stage2 image.
     * @type {string}
     * @memberof RpmDistributionTreeResponse
     */
    mainimage: string | null;
    /**
     * Disc number.
     * @type {number}
     * @memberof RpmDistributionTreeResponse
     */
    discnum: number | null;
    /**
     * Number of discs in media set.
     * @type {number}
     * @memberof RpmDistributionTreeResponse
     */
    totaldiscs: number | null;
    /**
     * 
     * @type {Array<AddonResponse>}
     * @memberof RpmDistributionTreeResponse
     */
    addons: Array<AddonResponse>;
    /**
     * 
     * @type {Array<ChecksumResponse>}
     * @memberof RpmDistributionTreeResponse
     */
    checksums: Array<ChecksumResponse>;
    /**
     * 
     * @type {Array<ImageResponse>}
     * @memberof RpmDistributionTreeResponse
     */
    images: Array<ImageResponse>;
    /**
     * 
     * @type {Array<VariantResponse>}
     * @memberof RpmDistributionTreeResponse
     */
    variants: Array<VariantResponse>;
}
/**
 * ModulemdDefaults serializer.
 * @export
 * @interface RpmModulemdDefaultsResponse
 */
export interface RpmModulemdDefaultsResponse {
    /**
     * 
     * @type {string}
     * @memberof RpmModulemdDefaultsResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof RpmModulemdDefaultsResponse
     */
    pulp_created?: string;
    /**
     * The MD5 checksum if available.
     * @type {string}
     * @memberof RpmModulemdDefaultsResponse
     */
    md5?: string;
    /**
     * The SHA-1 checksum if available.
     * @type {string}
     * @memberof RpmModulemdDefaultsResponse
     */
    sha1?: string;
    /**
     * The SHA-224 checksum if available.
     * @type {string}
     * @memberof RpmModulemdDefaultsResponse
     */
    sha224?: string;
    /**
     * The SHA-256 checksum if available.
     * @type {string}
     * @memberof RpmModulemdDefaultsResponse
     */
    sha256?: string;
    /**
     * The SHA-384 checksum if available.
     * @type {string}
     * @memberof RpmModulemdDefaultsResponse
     */
    sha384?: string;
    /**
     * The SHA-512 checksum if available.
     * @type {string}
     * @memberof RpmModulemdDefaultsResponse
     */
    sha512?: string;
    /**
     * Artifact file representing the physical content
     * @type {string}
     * @memberof RpmModulemdDefaultsResponse
     */
    artifact?: string;
    /**
     * Modulemd name.
     * @type {string}
     * @memberof RpmModulemdDefaultsResponse
     */
    module: string;
    /**
     * Modulemd default stream.
     * @type {string}
     * @memberof RpmModulemdDefaultsResponse
     */
    stream: string;
    /**
     * Default profiles for modulemd streams.
     * @type {object}
     * @memberof RpmModulemdDefaultsResponse
     */
    profiles: object;
}
/**
 * Modulemd serializer.
 * @export
 * @interface RpmModulemdResponse
 */
export interface RpmModulemdResponse {
    /**
     * 
     * @type {string}
     * @memberof RpmModulemdResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof RpmModulemdResponse
     */
    pulp_created?: string;
    /**
     * The MD5 checksum if available.
     * @type {string}
     * @memberof RpmModulemdResponse
     */
    md5?: string;
    /**
     * The SHA-1 checksum if available.
     * @type {string}
     * @memberof RpmModulemdResponse
     */
    sha1?: string;
    /**
     * The SHA-224 checksum if available.
     * @type {string}
     * @memberof RpmModulemdResponse
     */
    sha224?: string;
    /**
     * The SHA-256 checksum if available.
     * @type {string}
     * @memberof RpmModulemdResponse
     */
    sha256?: string;
    /**
     * The SHA-384 checksum if available.
     * @type {string}
     * @memberof RpmModulemdResponse
     */
    sha384?: string;
    /**
     * The SHA-512 checksum if available.
     * @type {string}
     * @memberof RpmModulemdResponse
     */
    sha512?: string;
    /**
     * Artifact file representing the physical content
     * @type {string}
     * @memberof RpmModulemdResponse
     */
    artifact?: string;
    /**
     * Modulemd name.
     * @type {string}
     * @memberof RpmModulemdResponse
     */
    name: string;
    /**
     * Stream name.
     * @type {string}
     * @memberof RpmModulemdResponse
     */
    stream: string;
    /**
     * Modulemd version.
     * @type {string}
     * @memberof RpmModulemdResponse
     */
    version: string;
    /**
     * Modulemd static-context flag.
     * @type {boolean}
     * @memberof RpmModulemdResponse
     */
    static_context?: boolean;
    /**
     * Modulemd context.
     * @type {string}
     * @memberof RpmModulemdResponse
     */
    context: string;
    /**
     * Modulemd architecture.
     * @type {string}
     * @memberof RpmModulemdResponse
     */
    arch: string;
    /**
     * Modulemd artifacts.
     * @type {object}
     * @memberof RpmModulemdResponse
     */
    artifacts: object | null;
    /**
     * Modulemd dependencies.
     * @type {object}
     * @memberof RpmModulemdResponse
     */
    dependencies: object | null;
    /**
     * Modulemd artifacts\' packages.
     * @type {Array<string>}
     * @memberof RpmModulemdResponse
     */
    packages?: Array<string>;
}
/**
 * PackageCategory serializer.
 * @export
 * @interface RpmPackageCategoryResponse
 */
export interface RpmPackageCategoryResponse {
    /**
     * 
     * @type {string}
     * @memberof RpmPackageCategoryResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof RpmPackageCategoryResponse
     */
    pulp_created?: string;
    /**
     * Category id.
     * @type {string}
     * @memberof RpmPackageCategoryResponse
     */
    id: string;
    /**
     * Category name.
     * @type {string}
     * @memberof RpmPackageCategoryResponse
     */
    name: string;
    /**
     * Category description.
     * @type {string}
     * @memberof RpmPackageCategoryResponse
     */
    description: string;
    /**
     * Category display order.
     * @type {number}
     * @memberof RpmPackageCategoryResponse
     */
    display_order: number | null;
    /**
     * Category group list.
     * @type {object}
     * @memberof RpmPackageCategoryResponse
     */
    group_ids: object | null;
    /**
     * Category description by language.
     * @type {object}
     * @memberof RpmPackageCategoryResponse
     */
    desc_by_lang: object | null;
    /**
     * Category name by language.
     * @type {object}
     * @memberof RpmPackageCategoryResponse
     */
    name_by_lang: object | null;
    /**
     * Category digest.
     * @type {string}
     * @memberof RpmPackageCategoryResponse
     */
    digest: string;
}
/**
 * PackageEnvironment serializer.
 * @export
 * @interface RpmPackageEnvironmentResponse
 */
export interface RpmPackageEnvironmentResponse {
    /**
     * 
     * @type {string}
     * @memberof RpmPackageEnvironmentResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof RpmPackageEnvironmentResponse
     */
    pulp_created?: string;
    /**
     * Environment id.
     * @type {string}
     * @memberof RpmPackageEnvironmentResponse
     */
    id: string;
    /**
     * Environment name.
     * @type {string}
     * @memberof RpmPackageEnvironmentResponse
     */
    name: string;
    /**
     * Environment description.
     * @type {string}
     * @memberof RpmPackageEnvironmentResponse
     */
    description: string;
    /**
     * Environment display order.
     * @type {number}
     * @memberof RpmPackageEnvironmentResponse
     */
    display_order: number | null;
    /**
     * Environment group list.
     * @type {object}
     * @memberof RpmPackageEnvironmentResponse
     */
    group_ids: object | null;
    /**
     * Environment option ids
     * @type {object}
     * @memberof RpmPackageEnvironmentResponse
     */
    option_ids: object | null;
    /**
     * Environment description by language.
     * @type {object}
     * @memberof RpmPackageEnvironmentResponse
     */
    desc_by_lang: object | null;
    /**
     * Environment name by language.
     * @type {object}
     * @memberof RpmPackageEnvironmentResponse
     */
    name_by_lang: object | null;
    /**
     * Environment digest.
     * @type {string}
     * @memberof RpmPackageEnvironmentResponse
     */
    digest: string;
}
/**
 * PackageGroup serializer.
 * @export
 * @interface RpmPackageGroupResponse
 */
export interface RpmPackageGroupResponse {
    /**
     * 
     * @type {string}
     * @memberof RpmPackageGroupResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof RpmPackageGroupResponse
     */
    pulp_created?: string;
    /**
     * PackageGroup id.
     * @type {string}
     * @memberof RpmPackageGroupResponse
     */
    id: string;
    /**
     * PackageGroup default.
     * @type {boolean}
     * @memberof RpmPackageGroupResponse
     */
    _default?: boolean;
    /**
     * PackageGroup user visibility.
     * @type {boolean}
     * @memberof RpmPackageGroupResponse
     */
    user_visible?: boolean;
    /**
     * PackageGroup display order.
     * @type {number}
     * @memberof RpmPackageGroupResponse
     */
    display_order: number | null;
    /**
     * PackageGroup name.
     * @type {string}
     * @memberof RpmPackageGroupResponse
     */
    name: string;
    /**
     * PackageGroup description.
     * @type {string}
     * @memberof RpmPackageGroupResponse
     */
    description: string;
    /**
     * PackageGroup package list.
     * @type {object}
     * @memberof RpmPackageGroupResponse
     */
    packages: object | null;
    /**
     * PackageGroup biarch only.
     * @type {boolean}
     * @memberof RpmPackageGroupResponse
     */
    biarch_only?: boolean;
    /**
     * PackageGroup description by language.
     * @type {object}
     * @memberof RpmPackageGroupResponse
     */
    desc_by_lang: object | null;
    /**
     * PackageGroup name by language.
     * @type {object}
     * @memberof RpmPackageGroupResponse
     */
    name_by_lang: object | null;
    /**
     * PackageGroup digest.
     * @type {string}
     * @memberof RpmPackageGroupResponse
     */
    digest: string;
}
/**
 * PackageLangpacks serializer.
 * @export
 * @interface RpmPackageLangpacksResponse
 */
export interface RpmPackageLangpacksResponse {
    /**
     * 
     * @type {string}
     * @memberof RpmPackageLangpacksResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof RpmPackageLangpacksResponse
     */
    pulp_created?: string;
    /**
     * Langpacks matches.
     * @type {object}
     * @memberof RpmPackageLangpacksResponse
     */
    matches: object | null;
    /**
     * Langpacks digest.
     * @type {string}
     * @memberof RpmPackageLangpacksResponse
     */
    digest: string | null;
}
/**
 * A Serializer for Package.  Add serializers for the new fields defined in Package and add those fields to the Meta class keeping fields from the parent class as well. Provide help_text.
 * @export
 * @interface RpmPackageResponse
 */
export interface RpmPackageResponse {
    /**
     * 
     * @type {string}
     * @memberof RpmPackageResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof RpmPackageResponse
     */
    pulp_created?: string;
    /**
     * The MD5 checksum if available.
     * @type {string}
     * @memberof RpmPackageResponse
     */
    md5?: string;
    /**
     * The SHA-1 checksum if available.
     * @type {string}
     * @memberof RpmPackageResponse
     */
    sha1?: string;
    /**
     * The SHA-224 checksum if available.
     * @type {string}
     * @memberof RpmPackageResponse
     */
    sha224?: string;
    /**
     * The SHA-256 checksum if available.
     * @type {string}
     * @memberof RpmPackageResponse
     */
    sha256?: string;
    /**
     * The SHA-384 checksum if available.
     * @type {string}
     * @memberof RpmPackageResponse
     */
    sha384?: string;
    /**
     * The SHA-512 checksum if available.
     * @type {string}
     * @memberof RpmPackageResponse
     */
    sha512?: string;
    /**
     * Artifact file representing the physical content
     * @type {string}
     * @memberof RpmPackageResponse
     */
    artifact?: string;
    /**
     * Name of the package
     * @type {string}
     * @memberof RpmPackageResponse
     */
    name?: string;
    /**
     * The package\'s epoch
     * @type {string}
     * @memberof RpmPackageResponse
     */
    epoch?: string;
    /**
     * The version of the package. For example, \'2.8.0\'
     * @type {string}
     * @memberof RpmPackageResponse
     */
    version?: string;
    /**
     * The release of a particular version of the package. e.g. \'1.el7\' or \'3.f24\'
     * @type {string}
     * @memberof RpmPackageResponse
     */
    release?: string;
    /**
     * The target architecture for a package.For example, \'x86_64\', \'i686\', or \'noarch\'
     * @type {string}
     * @memberof RpmPackageResponse
     */
    arch?: string;
    /**
     * Checksum of the package file
     * @type {string}
     * @memberof RpmPackageResponse
     */
    pkgId?: string;
    /**
     * Type of checksum, e.g. \'sha256\', \'md5\'
     * @type {string}
     * @memberof RpmPackageResponse
     */
    checksum_type?: string;
    /**
     * Short description of the packaged software
     * @type {string}
     * @memberof RpmPackageResponse
     */
    summary?: string;
    /**
     * In-depth description of the packaged software
     * @type {string}
     * @memberof RpmPackageResponse
     */
    description?: string;
    /**
     * URL with more information about the packaged software
     * @type {string}
     * @memberof RpmPackageResponse
     */
    url?: string;
    /**
     * Changelogs that package contains
     * @type {object}
     * @memberof RpmPackageResponse
     */
    changelogs?: object;
    /**
     * Files that package contains
     * @type {object}
     * @memberof RpmPackageResponse
     */
    files?: object;
    /**
     * Capabilities the package requires
     * @type {object}
     * @memberof RpmPackageResponse
     */
    requires?: object;
    /**
     * Capabilities the package provides
     * @type {object}
     * @memberof RpmPackageResponse
     */
    provides?: object;
    /**
     * Capabilities the package conflicts
     * @type {object}
     * @memberof RpmPackageResponse
     */
    conflicts?: object;
    /**
     * Capabilities the package obsoletes
     * @type {object}
     * @memberof RpmPackageResponse
     */
    obsoletes?: object;
    /**
     * Capabilities the package suggests
     * @type {object}
     * @memberof RpmPackageResponse
     */
    suggests?: object;
    /**
     * Capabilities the package enhances
     * @type {object}
     * @memberof RpmPackageResponse
     */
    enhances?: object;
    /**
     * Capabilities the package recommends
     * @type {object}
     * @memberof RpmPackageResponse
     */
    recommends?: object;
    /**
     * Capabilities the package supplements
     * @type {object}
     * @memberof RpmPackageResponse
     */
    supplements?: object;
    /**
     * Base location of this package
     * @type {string}
     * @memberof RpmPackageResponse
     */
    location_base?: string;
    /**
     * Relative location of package to the repodata
     * @type {string}
     * @memberof RpmPackageResponse
     */
    location_href?: string;
    /**
     * Hostname of the system that built the package
     * @type {string}
     * @memberof RpmPackageResponse
     */
    rpm_buildhost?: string;
    /**
     * RPM group (See: http://fedoraproject.org/wiki/RPMGroups)
     * @type {string}
     * @memberof RpmPackageResponse
     */
    rpm_group?: string;
    /**
     * License term applicable to the package software (GPLv2, etc.)
     * @type {string}
     * @memberof RpmPackageResponse
     */
    rpm_license?: string;
    /**
     * Person or persons responsible for creating the package
     * @type {string}
     * @memberof RpmPackageResponse
     */
    rpm_packager?: string;
    /**
     * Name of the source package (srpm) the package was built from
     * @type {string}
     * @memberof RpmPackageResponse
     */
    rpm_sourcerpm?: string;
    /**
     * Name of the organization that produced the package
     * @type {string}
     * @memberof RpmPackageResponse
     */
    rpm_vendor?: string;
    /**
     * First byte of the header
     * @type {number}
     * @memberof RpmPackageResponse
     */
    rpm_header_start?: number;
    /**
     * Last byte of the header
     * @type {number}
     * @memberof RpmPackageResponse
     */
    rpm_header_end?: number;
    /**
     * Flag to identify if the package is modular
     * @type {boolean}
     * @memberof RpmPackageResponse
     */
    is_modular?: boolean;
    /**
     * Size, in bytes, of the archive portion of the original package file
     * @type {number}
     * @memberof RpmPackageResponse
     */
    size_archive?: number;
    /**
     * Total size, in bytes, of every file installed by this package
     * @type {number}
     * @memberof RpmPackageResponse
     */
    size_installed?: number;
    /**
     * Size, in bytes, of the package
     * @type {number}
     * @memberof RpmPackageResponse
     */
    size_package?: number;
    /**
     * Time the package was built in seconds since the epoch
     * @type {number}
     * @memberof RpmPackageResponse
     */
    time_build?: number;
    /**
     * The \'file\' time attribute in the primary XML - file mtime in seconds since the epoch.
     * @type {number}
     * @memberof RpmPackageResponse
     */
    time_file?: number;
}
/**
 * RepoMetadataFile serializer.
 * @export
 * @interface RpmRepoMetadataFileResponse
 */
export interface RpmRepoMetadataFileResponse {
    /**
     * 
     * @type {string}
     * @memberof RpmRepoMetadataFileResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof RpmRepoMetadataFileResponse
     */
    pulp_created?: string;
    /**
     * The MD5 checksum if available.
     * @type {string}
     * @memberof RpmRepoMetadataFileResponse
     */
    md5?: string;
    /**
     * The SHA-1 checksum if available.
     * @type {string}
     * @memberof RpmRepoMetadataFileResponse
     */
    sha1?: string;
    /**
     * The SHA-224 checksum if available.
     * @type {string}
     * @memberof RpmRepoMetadataFileResponse
     */
    sha224?: string;
    /**
     * The SHA-256 checksum if available.
     * @type {string}
     * @memberof RpmRepoMetadataFileResponse
     */
    sha256?: string;
    /**
     * The SHA-384 checksum if available.
     * @type {string}
     * @memberof RpmRepoMetadataFileResponse
     */
    sha384?: string;
    /**
     * The SHA-512 checksum if available.
     * @type {string}
     * @memberof RpmRepoMetadataFileResponse
     */
    sha512?: string;
    /**
     * Artifact file representing the physical content
     * @type {string}
     * @memberof RpmRepoMetadataFileResponse
     */
    artifact?: string;
    /**
     * Relative path of the file.
     * @type {string}
     * @memberof RpmRepoMetadataFileResponse
     */
    relative_path: string;
    /**
     * Metadata type.
     * @type {string}
     * @memberof RpmRepoMetadataFileResponse
     */
    data_type: string;
    /**
     * Checksum type for the file.
     * @type {string}
     * @memberof RpmRepoMetadataFileResponse
     */
    checksum_type: string;
    /**
     * Checksum for the file.
     * @type {string}
     * @memberof RpmRepoMetadataFileResponse
     */
    checksum: string;
}
/**
 * Serializer for RPM Sync.
 * @export
 * @interface RpmRepositorySyncURL
 */
export interface RpmRepositorySyncURL {
    /**
     * A remote to sync from. This will override a remote set on repository.
     * @type {string}
     * @memberof RpmRepositorySyncURL
     */
    remote?: string;
    /**
     * If ``True``, synchronization will remove all content that is not present in the remote repository. If ``False``, sync will be additive only.
     * @type {boolean}
     * @memberof RpmRepositorySyncURL
     */
    mirror?: boolean;
    /**
     * List of content types to skip during sync.
     * @type {Array<SkipTypesEnum>}
     * @memberof RpmRepositorySyncURL
     */
    skip_types?: Array<SkipTypesEnum>;
    /**
     * Whether or not to optimize sync.
     * @type {boolean}
     * @memberof RpmRepositorySyncURL
     */
    optimize?: boolean;
}
/**
 * Serializer for RPM Distributions.
 * @export
 * @interface RpmRpmDistribution
 */
export interface RpmRpmDistribution {
    /**
     * The base (relative) path component of the published url. Avoid paths that                     overlap with other distribution base paths (e.g. \"foo\" and \"foo/bar\")
     * @type {string}
     * @memberof RpmRpmDistribution
     */
    base_path: string;
    /**
     * An optional content-guard.
     * @type {string}
     * @memberof RpmRpmDistribution
     */
    content_guard?: string | null;
    /**
     * 
     * @type {object}
     * @memberof RpmRpmDistribution
     */
    pulp_labels?: object;
    /**
     * A unique name. Ex, `rawhide` and `stable`.
     * @type {string}
     * @memberof RpmRpmDistribution
     */
    name: string;
    /**
     * The latest RepositoryVersion for this Repository will be served.
     * @type {string}
     * @memberof RpmRpmDistribution
     */
    repository?: string | null;
    /**
     * Publication to be served
     * @type {string}
     * @memberof RpmRpmDistribution
     */
    publication?: string | null;
}
/**
 * Serializer for RPM Distributions.
 * @export
 * @interface RpmRpmDistributionResponse
 */
export interface RpmRpmDistributionResponse {
    /**
     * 
     * @type {string}
     * @memberof RpmRpmDistributionResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof RpmRpmDistributionResponse
     */
    pulp_created?: string;
    /**
     * The base (relative) path component of the published url. Avoid paths that                     overlap with other distribution base paths (e.g. \"foo\" and \"foo/bar\")
     * @type {string}
     * @memberof RpmRpmDistributionResponse
     */
    base_path: string;
    /**
     * The URL for accessing the publication as defined by this distribution.
     * @type {string}
     * @memberof RpmRpmDistributionResponse
     */
    base_url?: string;
    /**
     * An optional content-guard.
     * @type {string}
     * @memberof RpmRpmDistributionResponse
     */
    content_guard?: string | null;
    /**
     * 
     * @type {object}
     * @memberof RpmRpmDistributionResponse
     */
    pulp_labels?: object;
    /**
     * A unique name. Ex, `rawhide` and `stable`.
     * @type {string}
     * @memberof RpmRpmDistributionResponse
     */
    name: string;
    /**
     * The latest RepositoryVersion for this Repository will be served.
     * @type {string}
     * @memberof RpmRpmDistributionResponse
     */
    repository?: string | null;
    /**
     * Publication to be served
     * @type {string}
     * @memberof RpmRpmDistributionResponse
     */
    publication?: string | null;
}
/**
 * A Serializer for RpmPublication.
 * @export
 * @interface RpmRpmPublication
 */
export interface RpmRpmPublication {
    /**
     * 
     * @type {string}
     * @memberof RpmRpmPublication
     */
    repository_version?: string;
    /**
     * A URI of the repository to be published.
     * @type {string}
     * @memberof RpmRpmPublication
     */
    repository?: string;
    /**
     * The checksum type for metadata.
     * @type {MetadataChecksumTypeEnum}
     * @memberof RpmRpmPublication
     */
    metadata_checksum_type?: MetadataChecksumTypeEnum;
    /**
     * The checksum type for packages.
     * @type {PackageChecksumTypeEnum}
     * @memberof RpmRpmPublication
     */
    package_checksum_type?: PackageChecksumTypeEnum;
    /**
     * An option specifying whether a client should perform a GPG signature check on packages.
     * @type {number}
     * @memberof RpmRpmPublication
     */
    gpgcheck?: number;
    /**
     * An option specifying whether a client should perform a GPG signature check on the repodata.
     * @type {number}
     * @memberof RpmRpmPublication
     */
    repo_gpgcheck?: number;
    /**
     * An option specifying whether Pulp should generate SQLite metadata.
     * @type {boolean}
     * @memberof RpmRpmPublication
     */
    sqlite_metadata?: boolean;
}
/**
 * A Serializer for RpmPublication.
 * @export
 * @interface RpmRpmPublicationResponse
 */
export interface RpmRpmPublicationResponse {
    /**
     * 
     * @type {string}
     * @memberof RpmRpmPublicationResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof RpmRpmPublicationResponse
     */
    pulp_created?: string;
    /**
     * 
     * @type {string}
     * @memberof RpmRpmPublicationResponse
     */
    repository_version?: string;
    /**
     * A URI of the repository to be published.
     * @type {string}
     * @memberof RpmRpmPublicationResponse
     */
    repository?: string;
    /**
     * The checksum type for metadata.
     * @type {MetadataChecksumTypeEnum}
     * @memberof RpmRpmPublicationResponse
     */
    metadata_checksum_type?: MetadataChecksumTypeEnum;
    /**
     * The checksum type for packages.
     * @type {PackageChecksumTypeEnum}
     * @memberof RpmRpmPublicationResponse
     */
    package_checksum_type?: PackageChecksumTypeEnum;
    /**
     * An option specifying whether a client should perform a GPG signature check on packages.
     * @type {number}
     * @memberof RpmRpmPublicationResponse
     */
    gpgcheck?: number;
    /**
     * An option specifying whether a client should perform a GPG signature check on the repodata.
     * @type {number}
     * @memberof RpmRpmPublicationResponse
     */
    repo_gpgcheck?: number;
    /**
     * An option specifying whether Pulp should generate SQLite metadata.
     * @type {boolean}
     * @memberof RpmRpmPublicationResponse
     */
    sqlite_metadata?: boolean;
}
/**
 * A Serializer for RpmRemote.
 * @export
 * @interface RpmRpmRemote
 */
export interface RpmRpmRemote {
    /**
     * A unique name for this remote.
     * @type {string}
     * @memberof RpmRpmRemote
     */
    name: string;
    /**
     * The URL of an external content source.
     * @type {string}
     * @memberof RpmRpmRemote
     */
    url: string;
    /**
     * A PEM encoded CA certificate used to validate the server certificate presented by the remote server.
     * @type {string}
     * @memberof RpmRpmRemote
     */
    ca_cert?: string | null;
    /**
     * A PEM encoded client certificate used for authentication.
     * @type {string}
     * @memberof RpmRpmRemote
     */
    client_cert?: string | null;
    /**
     * A PEM encoded private key used for authentication.
     * @type {string}
     * @memberof RpmRpmRemote
     */
    client_key?: string | null;
    /**
     * If True, TLS peer validation must be performed.
     * @type {boolean}
     * @memberof RpmRpmRemote
     */
    tls_validation?: boolean;
    /**
     * The proxy URL. Format: scheme://host:port
     * @type {string}
     * @memberof RpmRpmRemote
     */
    proxy_url?: string | null;
    /**
     * The username to authenticte to the proxy.
     * @type {string}
     * @memberof RpmRpmRemote
     */
    proxy_username?: string | null;
    /**
     * The password to authenticte to the proxy.
     * @type {string}
     * @memberof RpmRpmRemote
     */
    proxy_password?: string | null;
    /**
     * The username to be used for authentication when syncing.
     * @type {string}
     * @memberof RpmRpmRemote
     */
    username?: string | null;
    /**
     * The password to be used for authentication when syncing.
     * @type {string}
     * @memberof RpmRpmRemote
     */
    password?: string | null;
    /**
     * 
     * @type {object}
     * @memberof RpmRpmRemote
     */
    pulp_labels?: object;
    /**
     * Total number of simultaneous connections. If not set then the default value will be used.
     * @type {number}
     * @memberof RpmRpmRemote
     */
    download_concurrency?: number | null;
    /**
     * Maximum number of retry attempts after a download failure. If not set then the default value (3) will be used.
     * @type {number}
     * @memberof RpmRpmRemote
     */
    max_retries?: number | null;
    /**
     * The policy to use when downloading content. The possible values include: \'immediate\', \'on_demand\', and \'streamed\'. \'immediate\' is the default.
     * @type {PolicyEnum}
     * @memberof RpmRpmRemote
     */
    policy?: PolicyEnum;
    /**
     * aiohttp.ClientTimeout.total (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof RpmRpmRemote
     */
    total_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.connect (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof RpmRpmRemote
     */
    connect_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.sock_connect (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof RpmRpmRemote
     */
    sock_connect_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.sock_read (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof RpmRpmRemote
     */
    sock_read_timeout?: number | null;
    /**
     * Headers for aiohttp.Clientsession
     * @type {Array<object>}
     * @memberof RpmRpmRemote
     */
    headers?: Array<object>;
    /**
     * Limits total download rate in requests per second
     * @type {number}
     * @memberof RpmRpmRemote
     */
    rate_limit?: number | null;
    /**
     * Authentication token for SLES repositories.
     * @type {string}
     * @memberof RpmRpmRemote
     */
    sles_auth_token?: string | null;
}
/**
 * A Serializer for RpmRemote.
 * @export
 * @interface RpmRpmRemoteResponse
 */
export interface RpmRpmRemoteResponse {
    /**
     * 
     * @type {string}
     * @memberof RpmRpmRemoteResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof RpmRpmRemoteResponse
     */
    pulp_created?: string;
    /**
     * A unique name for this remote.
     * @type {string}
     * @memberof RpmRpmRemoteResponse
     */
    name: string;
    /**
     * The URL of an external content source.
     * @type {string}
     * @memberof RpmRpmRemoteResponse
     */
    url: string;
    /**
     * A PEM encoded CA certificate used to validate the server certificate presented by the remote server.
     * @type {string}
     * @memberof RpmRpmRemoteResponse
     */
    ca_cert?: string | null;
    /**
     * A PEM encoded client certificate used for authentication.
     * @type {string}
     * @memberof RpmRpmRemoteResponse
     */
    client_cert?: string | null;
    /**
     * If True, TLS peer validation must be performed.
     * @type {boolean}
     * @memberof RpmRpmRemoteResponse
     */
    tls_validation?: boolean;
    /**
     * The proxy URL. Format: scheme://host:port
     * @type {string}
     * @memberof RpmRpmRemoteResponse
     */
    proxy_url?: string | null;
    /**
     * 
     * @type {object}
     * @memberof RpmRpmRemoteResponse
     */
    pulp_labels?: object;
    /**
     * Timestamp of the most recent update of the remote.
     * @type {string}
     * @memberof RpmRpmRemoteResponse
     */
    pulp_last_updated?: string;
    /**
     * Total number of simultaneous connections. If not set then the default value will be used.
     * @type {number}
     * @memberof RpmRpmRemoteResponse
     */
    download_concurrency?: number | null;
    /**
     * Maximum number of retry attempts after a download failure. If not set then the default value (3) will be used.
     * @type {number}
     * @memberof RpmRpmRemoteResponse
     */
    max_retries?: number | null;
    /**
     * The policy to use when downloading content. The possible values include: \'immediate\', \'on_demand\', and \'streamed\'. \'immediate\' is the default.
     * @type {PolicyEnum}
     * @memberof RpmRpmRemoteResponse
     */
    policy?: PolicyEnum;
    /**
     * aiohttp.ClientTimeout.total (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof RpmRpmRemoteResponse
     */
    total_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.connect (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof RpmRpmRemoteResponse
     */
    connect_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.sock_connect (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof RpmRpmRemoteResponse
     */
    sock_connect_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.sock_read (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof RpmRpmRemoteResponse
     */
    sock_read_timeout?: number | null;
    /**
     * Headers for aiohttp.Clientsession
     * @type {Array<object>}
     * @memberof RpmRpmRemoteResponse
     */
    headers?: Array<object>;
    /**
     * Limits total download rate in requests per second
     * @type {number}
     * @memberof RpmRpmRemoteResponse
     */
    rate_limit?: number | null;
    /**
     * Authentication token for SLES repositories.
     * @type {string}
     * @memberof RpmRpmRemoteResponse
     */
    sles_auth_token?: string | null;
}
/**
 * Serializer for Rpm Repositories.
 * @export
 * @interface RpmRpmRepository
 */
export interface RpmRpmRepository {
    /**
     * 
     * @type {object}
     * @memberof RpmRpmRepository
     */
    pulp_labels?: object;
    /**
     * A unique name for this repository.
     * @type {string}
     * @memberof RpmRpmRepository
     */
    name: string;
    /**
     * An optional description.
     * @type {string}
     * @memberof RpmRpmRepository
     */
    description?: string | null;
    /**
     * Retain X versions of the repository. Default is null which retains all versions. This is provided as a tech preview in Pulp 3 and may change in the future.
     * @type {number}
     * @memberof RpmRpmRepository
     */
    retain_repo_versions?: number | null;
    /**
     * An optional remote to use by default when syncing.
     * @type {string}
     * @memberof RpmRpmRepository
     */
    remote?: string | null;
    /**
     * Whether to automatically create publications for new repository versions, and update any distributions pointing to this repository.
     * @type {boolean}
     * @memberof RpmRpmRepository
     */
    autopublish?: boolean;
    /**
     * A reference to an associated signing service.
     * @type {string}
     * @memberof RpmRpmRepository
     */
    metadata_signing_service?: string | null;
    /**
     * The number of versions of each package to keep in the repository; older versions will be purged. The default is \'0\', which will disable this feature and keep all versions of each package.
     * @type {number}
     * @memberof RpmRpmRepository
     */
    retain_package_versions?: number;
    /**
     * The checksum type for metadata.
     * @type {MetadataChecksumTypeEnum}
     * @memberof RpmRpmRepository
     */
    metadata_checksum_type?: MetadataChecksumTypeEnum | null;
    /**
     * The checksum type for packages.
     * @type {PackageChecksumTypeEnum}
     * @memberof RpmRpmRepository
     */
    package_checksum_type?: PackageChecksumTypeEnum | null;
    /**
     * An option specifying whether a client should perform a GPG signature check on packages.
     * @type {number}
     * @memberof RpmRpmRepository
     */
    gpgcheck?: number;
    /**
     * An option specifying whether a client should perform a GPG signature check on the repodata.
     * @type {number}
     * @memberof RpmRpmRepository
     */
    repo_gpgcheck?: number;
    /**
     * An option specifying whether Pulp should generate SQLite metadata.
     * @type {boolean}
     * @memberof RpmRpmRepository
     */
    sqlite_metadata?: boolean;
}
/**
 * Serializer for Rpm Repositories.
 * @export
 * @interface RpmRpmRepositoryResponse
 */
export interface RpmRpmRepositoryResponse {
    /**
     * 
     * @type {string}
     * @memberof RpmRpmRepositoryResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof RpmRpmRepositoryResponse
     */
    pulp_created?: string;
    /**
     * 
     * @type {string}
     * @memberof RpmRpmRepositoryResponse
     */
    versions_href?: string;
    /**
     * 
     * @type {object}
     * @memberof RpmRpmRepositoryResponse
     */
    pulp_labels?: object;
    /**
     * 
     * @type {string}
     * @memberof RpmRpmRepositoryResponse
     */
    latest_version_href?: string;
    /**
     * A unique name for this repository.
     * @type {string}
     * @memberof RpmRpmRepositoryResponse
     */
    name: string;
    /**
     * An optional description.
     * @type {string}
     * @memberof RpmRpmRepositoryResponse
     */
    description?: string | null;
    /**
     * Retain X versions of the repository. Default is null which retains all versions. This is provided as a tech preview in Pulp 3 and may change in the future.
     * @type {number}
     * @memberof RpmRpmRepositoryResponse
     */
    retain_repo_versions?: number | null;
    /**
     * An optional remote to use by default when syncing.
     * @type {string}
     * @memberof RpmRpmRepositoryResponse
     */
    remote?: string | null;
    /**
     * Whether to automatically create publications for new repository versions, and update any distributions pointing to this repository.
     * @type {boolean}
     * @memberof RpmRpmRepositoryResponse
     */
    autopublish?: boolean;
    /**
     * A reference to an associated signing service.
     * @type {string}
     * @memberof RpmRpmRepositoryResponse
     */
    metadata_signing_service?: string | null;
    /**
     * The number of versions of each package to keep in the repository; older versions will be purged. The default is \'0\', which will disable this feature and keep all versions of each package.
     * @type {number}
     * @memberof RpmRpmRepositoryResponse
     */
    retain_package_versions?: number;
    /**
     * The checksum type for metadata.
     * @type {MetadataChecksumTypeEnum}
     * @memberof RpmRpmRepositoryResponse
     */
    metadata_checksum_type?: MetadataChecksumTypeEnum | null;
    /**
     * The checksum type for packages.
     * @type {PackageChecksumTypeEnum}
     * @memberof RpmRpmRepositoryResponse
     */
    package_checksum_type?: PackageChecksumTypeEnum | null;
    /**
     * An option specifying whether a client should perform a GPG signature check on packages.
     * @type {number}
     * @memberof RpmRpmRepositoryResponse
     */
    gpgcheck?: number;
    /**
     * An option specifying whether a client should perform a GPG signature check on the repodata.
     * @type {number}
     * @memberof RpmRpmRepositoryResponse
     */
    repo_gpgcheck?: number;
    /**
     * An option specifying whether Pulp should generate SQLite metadata.
     * @type {boolean}
     * @memberof RpmRpmRepositoryResponse
     */
    sqlite_metadata?: boolean;
}
/**
 * A Serializer for UlnRemote.
 * @export
 * @interface RpmUlnRemote
 */
export interface RpmUlnRemote {
    /**
     * A unique name for this remote.
     * @type {string}
     * @memberof RpmUlnRemote
     */
    name: string;
    /**
     * The ULN repo URL of the remote content source.\"This is \"uln://\" followed by the channel name. E.g.: \"uln://ol7_x86_64_oracle\"
     * @type {string}
     * @memberof RpmUlnRemote
     */
    url: string;
    /**
     * A PEM encoded CA certificate used to validate the server certificate presented by the remote server.
     * @type {string}
     * @memberof RpmUlnRemote
     */
    ca_cert?: string | null;
    /**
     * A PEM encoded client certificate used for authentication.
     * @type {string}
     * @memberof RpmUlnRemote
     */
    client_cert?: string | null;
    /**
     * A PEM encoded private key used for authentication.
     * @type {string}
     * @memberof RpmUlnRemote
     */
    client_key?: string | null;
    /**
     * If True, TLS peer validation must be performed.
     * @type {boolean}
     * @memberof RpmUlnRemote
     */
    tls_validation?: boolean;
    /**
     * The proxy URL. Format: scheme://host:port
     * @type {string}
     * @memberof RpmUlnRemote
     */
    proxy_url?: string | null;
    /**
     * The username to authenticte to the proxy.
     * @type {string}
     * @memberof RpmUlnRemote
     */
    proxy_username?: string | null;
    /**
     * The password to authenticte to the proxy.
     * @type {string}
     * @memberof RpmUlnRemote
     */
    proxy_password?: string | null;
    /**
     * Your ULN account username.
     * @type {string}
     * @memberof RpmUlnRemote
     */
    username: string;
    /**
     * Your ULN account password.
     * @type {string}
     * @memberof RpmUlnRemote
     */
    password: string;
    /**
     * 
     * @type {object}
     * @memberof RpmUlnRemote
     */
    pulp_labels?: object;
    /**
     * Total number of simultaneous connections. If not set then the default value will be used.
     * @type {number}
     * @memberof RpmUlnRemote
     */
    download_concurrency?: number | null;
    /**
     * Maximum number of retry attempts after a download failure. If not set then the default value (3) will be used.
     * @type {number}
     * @memberof RpmUlnRemote
     */
    max_retries?: number | null;
    /**
     * The policy to use when downloading content. The possible values include: \'immediate\', \'on_demand\', and \'streamed\'. \'immediate\' is the default.
     * @type {PolicyEnum}
     * @memberof RpmUlnRemote
     */
    policy?: PolicyEnum;
    /**
     * aiohttp.ClientTimeout.total (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof RpmUlnRemote
     */
    total_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.connect (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof RpmUlnRemote
     */
    connect_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.sock_connect (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof RpmUlnRemote
     */
    sock_connect_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.sock_read (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof RpmUlnRemote
     */
    sock_read_timeout?: number | null;
    /**
     * Headers for aiohttp.Clientsession
     * @type {Array<object>}
     * @memberof RpmUlnRemote
     */
    headers?: Array<object>;
    /**
     * Limits total download rate in requests per second
     * @type {number}
     * @memberof RpmUlnRemote
     */
    rate_limit?: number | null;
    /**
     * Base URL of the ULN server. If the uln_server_base_url is not provided pulp_rpm willuse the contents of the DEFAULT_ULN_SERVER_BASE_URL setting instead.
     * @type {string}
     * @memberof RpmUlnRemote
     */
    uln_server_base_url?: string | null;
}
/**
 * A Serializer for UlnRemote.
 * @export
 * @interface RpmUlnRemoteResponse
 */
export interface RpmUlnRemoteResponse {
    /**
     * 
     * @type {string}
     * @memberof RpmUlnRemoteResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof RpmUlnRemoteResponse
     */
    pulp_created?: string;
    /**
     * A unique name for this remote.
     * @type {string}
     * @memberof RpmUlnRemoteResponse
     */
    name: string;
    /**
     * The ULN repo URL of the remote content source.\"This is \"uln://\" followed by the channel name. E.g.: \"uln://ol7_x86_64_oracle\"
     * @type {string}
     * @memberof RpmUlnRemoteResponse
     */
    url: string;
    /**
     * A PEM encoded CA certificate used to validate the server certificate presented by the remote server.
     * @type {string}
     * @memberof RpmUlnRemoteResponse
     */
    ca_cert?: string | null;
    /**
     * A PEM encoded client certificate used for authentication.
     * @type {string}
     * @memberof RpmUlnRemoteResponse
     */
    client_cert?: string | null;
    /**
     * If True, TLS peer validation must be performed.
     * @type {boolean}
     * @memberof RpmUlnRemoteResponse
     */
    tls_validation?: boolean;
    /**
     * The proxy URL. Format: scheme://host:port
     * @type {string}
     * @memberof RpmUlnRemoteResponse
     */
    proxy_url?: string | null;
    /**
     * Your ULN account username.
     * @type {string}
     * @memberof RpmUlnRemoteResponse
     */
    username: string;
    /**
     * Your ULN account password.
     * @type {string}
     * @memberof RpmUlnRemoteResponse
     */
    password: string;
    /**
     * 
     * @type {object}
     * @memberof RpmUlnRemoteResponse
     */
    pulp_labels?: object;
    /**
     * Timestamp of the most recent update of the remote.
     * @type {string}
     * @memberof RpmUlnRemoteResponse
     */
    pulp_last_updated?: string;
    /**
     * Total number of simultaneous connections. If not set then the default value will be used.
     * @type {number}
     * @memberof RpmUlnRemoteResponse
     */
    download_concurrency?: number | null;
    /**
     * Maximum number of retry attempts after a download failure. If not set then the default value (3) will be used.
     * @type {number}
     * @memberof RpmUlnRemoteResponse
     */
    max_retries?: number | null;
    /**
     * The policy to use when downloading content. The possible values include: \'immediate\', \'on_demand\', and \'streamed\'. \'immediate\' is the default.
     * @type {PolicyEnum}
     * @memberof RpmUlnRemoteResponse
     */
    policy?: PolicyEnum;
    /**
     * aiohttp.ClientTimeout.total (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof RpmUlnRemoteResponse
     */
    total_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.connect (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof RpmUlnRemoteResponse
     */
    connect_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.sock_connect (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof RpmUlnRemoteResponse
     */
    sock_connect_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.sock_read (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof RpmUlnRemoteResponse
     */
    sock_read_timeout?: number | null;
    /**
     * Headers for aiohttp.Clientsession
     * @type {Array<object>}
     * @memberof RpmUlnRemoteResponse
     */
    headers?: Array<object>;
    /**
     * Limits total download rate in requests per second
     * @type {number}
     * @memberof RpmUlnRemoteResponse
     */
    rate_limit?: number | null;
    /**
     * Base URL of the ULN server. If the uln_server_base_url is not provided pulp_rpm willuse the contents of the DEFAULT_ULN_SERVER_BASE_URL setting instead.
     * @type {string}
     * @memberof RpmUlnRemoteResponse
     */
    uln_server_base_url?: string | null;
}
/**
 * A Serializer for UpdateCollection.
 * @export
 * @interface RpmUpdateCollection
 */
export interface RpmUpdateCollection {
    /**
     * Collection name.
     * @type {string}
     * @memberof RpmUpdateCollection
     */
    name: string | null;
    /**
     * Collection short name.
     * @type {string}
     * @memberof RpmUpdateCollection
     */
    shortname: string | null;
    /**
     * Collection modular NSVCA.
     * @type {object}
     * @memberof RpmUpdateCollection
     */
    module: object | null;
}
/**
 * A Serializer for UpdateCollection.
 * @export
 * @interface RpmUpdateCollectionResponse
 */
export interface RpmUpdateCollectionResponse {
    /**
     * Collection name.
     * @type {string}
     * @memberof RpmUpdateCollectionResponse
     */
    name: string | null;
    /**
     * Collection short name.
     * @type {string}
     * @memberof RpmUpdateCollectionResponse
     */
    shortname: string | null;
    /**
     * Collection modular NSVCA.
     * @type {object}
     * @memberof RpmUpdateCollectionResponse
     */
    module: object | null;
    /**
     * List of packages
     * @type {Array<object>}
     * @memberof RpmUpdateCollectionResponse
     */
    packages?: Array<object>;
}
/**
 * A Serializer for UpdateRecord.
 * @export
 * @interface RpmUpdateRecordResponse
 */
export interface RpmUpdateRecordResponse {
    /**
     * 
     * @type {string}
     * @memberof RpmUpdateRecordResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof RpmUpdateRecordResponse
     */
    pulp_created?: string;
    /**
     * Update id (short update name, e.g. RHEA-2013:1777)
     * @type {string}
     * @memberof RpmUpdateRecordResponse
     */
    id?: string;
    /**
     * Date when the update was updated (e.g. \'2013-12-02 00:00:00\')
     * @type {string}
     * @memberof RpmUpdateRecordResponse
     */
    updated_date?: string;
    /**
     * Update description
     * @type {string}
     * @memberof RpmUpdateRecordResponse
     */
    description?: string;
    /**
     * Date when the update was issued (e.g. \'2013-12-02 00:00:00\')
     * @type {string}
     * @memberof RpmUpdateRecordResponse
     */
    issued_date?: string;
    /**
     * Source of the update (e.g. security@redhat.com)
     * @type {string}
     * @memberof RpmUpdateRecordResponse
     */
    fromstr?: string;
    /**
     * Update status (\'final\', ...)
     * @type {string}
     * @memberof RpmUpdateRecordResponse
     */
    status?: string;
    /**
     * Update name
     * @type {string}
     * @memberof RpmUpdateRecordResponse
     */
    title?: string;
    /**
     * Short summary
     * @type {string}
     * @memberof RpmUpdateRecordResponse
     */
    summary?: string;
    /**
     * Update version (probably always an integer number)
     * @type {string}
     * @memberof RpmUpdateRecordResponse
     */
    version?: string;
    /**
     * Update type (\'enhancement\', \'bugfix\', ...)
     * @type {string}
     * @memberof RpmUpdateRecordResponse
     */
    type?: string;
    /**
     * Severity
     * @type {string}
     * @memberof RpmUpdateRecordResponse
     */
    severity?: string;
    /**
     * Solution
     * @type {string}
     * @memberof RpmUpdateRecordResponse
     */
    solution?: string;
    /**
     * Update release
     * @type {string}
     * @memberof RpmUpdateRecordResponse
     */
    release?: string;
    /**
     * Copyrights
     * @type {string}
     * @memberof RpmUpdateRecordResponse
     */
    rights?: string;
    /**
     * Push count
     * @type {string}
     * @memberof RpmUpdateRecordResponse
     */
    pushcount?: string;
    /**
     * List of packages
     * @type {Array<RpmUpdateCollectionResponse>}
     * @memberof RpmUpdateRecordResponse
     */
    pkglist?: Array<RpmUpdateCollectionResponse>;
    /**
     * List of references
     * @type {Array<object>}
     * @memberof RpmUpdateRecordResponse
     */
    references?: Array<object>;
    /**
     * Reboot suggested
     * @type {boolean}
     * @memberof RpmUpdateRecordResponse
     */
    reboot_suggested?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum SkipTypesEnum {
    Srpm = 'srpm'
}

/**
 * Variant serializer.
 * @export
 * @interface VariantResponse
 */
export interface VariantResponse {
    /**
     * Variant id.
     * @type {string}
     * @memberof VariantResponse
     */
    variant_id: string;
    /**
     * Variant uid.
     * @type {string}
     * @memberof VariantResponse
     */
    uid: string;
    /**
     * Variant name.
     * @type {string}
     * @memberof VariantResponse
     */
    name: string;
    /**
     * Variant type.
     * @type {string}
     * @memberof VariantResponse
     */
    type: string;
    /**
     * Relative path to directory with binary RPMs.
     * @type {string}
     * @memberof VariantResponse
     */
    packages: string;
    /**
     * Relative path to directory with source RPMs.
     * @type {string}
     * @memberof VariantResponse
     */
    source_packages: string | null;
    /**
     * Relative path to YUM repository with source RPMs.
     * @type {string}
     * @memberof VariantResponse
     */
    source_repository: string | null;
    /**
     * Relative path to directory with debug RPMs.
     * @type {string}
     * @memberof VariantResponse
     */
    debug_packages: string | null;
    /**
     * Relative path to YUM repository with debug RPMs.
     * @type {string}
     * @memberof VariantResponse
     */
    debug_repository: string | null;
    /**
     * Relative path to a pem file that identifies a product.
     * @type {string}
     * @memberof VariantResponse
     */
    identity: string | null;
}

/**
 * ContentAdvisoriesApi - axios parameter creator
 * @export
 */
export const ContentAdvisoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous task to create content,optionally create new repository version.
         * @summary Create an update record
         * @param {any} [file] An uploaded file that may be turned into the artifact of the content unit.
         * @param {string} [repository] A URI of a repository the new content unit should be associated with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (file?: any, repository?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/content/rpm/advisories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (repository !== undefined) { 
                localVarFormParams.append('repository', repository as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A ViewSet for UpdateRecord.  Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/advisories/  Also specify queryset and serializer for UpdateRecord.
         * @summary List update records
         * @param {string} [id] Filter results where id matches value
         * @param {Array<string>} [idIn] Filter results where id is in a comma-separated list of values
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [severity] Filter results where severity matches value
         * @param {Array<string>} [severityIn] Filter results where severity is in a comma-separated list of values
         * @param {string} [severityNe] Filter results where severity not equal to value
         * @param {string} [status] Filter results where status matches value
         * @param {Array<string>} [statusIn] Filter results where status is in a comma-separated list of values
         * @param {string} [statusNe] Filter results where status not equal to value
         * @param {string} [type] Filter results where type matches value
         * @param {Array<string>} [typeIn] Filter results where type is in a comma-separated list of values
         * @param {string} [typeNe] Filter results where type not equal to value
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (id?: string, idIn?: Array<string>, limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, severity?: string, severityIn?: Array<string>, severityNe?: string, status?: string, statusIn?: Array<string>, statusNe?: string, type?: string, typeIn?: Array<string>, typeNe?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/content/rpm/advisories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (idIn) {
                localVarQueryParameter['id__in'] = idIn.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (repositoryVersion !== undefined) {
                localVarQueryParameter['repository_version'] = repositoryVersion;
            }

            if (repositoryVersionAdded !== undefined) {
                localVarQueryParameter['repository_version_added'] = repositoryVersionAdded;
            }

            if (repositoryVersionRemoved !== undefined) {
                localVarQueryParameter['repository_version_removed'] = repositoryVersionRemoved;
            }

            if (severity !== undefined) {
                localVarQueryParameter['severity'] = severity;
            }

            if (severityIn) {
                localVarQueryParameter['severity__in'] = severityIn.join(COLLECTION_FORMATS.csv);
            }

            if (severityNe !== undefined) {
                localVarQueryParameter['severity__ne'] = severityNe;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (statusIn) {
                localVarQueryParameter['status__in'] = statusIn.join(COLLECTION_FORMATS.csv);
            }

            if (statusNe !== undefined) {
                localVarQueryParameter['status__ne'] = statusNe;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (typeIn) {
                localVarQueryParameter['type__in'] = typeIn.join(COLLECTION_FORMATS.csv);
            }

            if (typeNe !== undefined) {
                localVarQueryParameter['type__ne'] = typeNe;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A ViewSet for UpdateRecord.  Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/advisories/  Also specify queryset and serializer for UpdateRecord.
         * @summary Inspect an update record
         * @param {string} rpmUpdateRecordHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (rpmUpdateRecordHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmUpdateRecordHref' is not null or undefined
            assertParamExists('read', 'rpmUpdateRecordHref', rpmUpdateRecordHref)
            const localVarPath = `{rpm_update_record_href}`
                .replace(`{${"rpm_update_record_href"}}`, String(rpmUpdateRecordHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentAdvisoriesApi - functional programming interface
 * @export
 */
export const ContentAdvisoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentAdvisoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Trigger an asynchronous task to create content,optionally create new repository version.
         * @summary Create an update record
         * @param {any} [file] An uploaded file that may be turned into the artifact of the content unit.
         * @param {string} [repository] A URI of a repository the new content unit should be associated with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(file?: any, repository?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(file, repository, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A ViewSet for UpdateRecord.  Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/advisories/  Also specify queryset and serializer for UpdateRecord.
         * @summary List update records
         * @param {string} [id] Filter results where id matches value
         * @param {Array<string>} [idIn] Filter results where id is in a comma-separated list of values
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [severity] Filter results where severity matches value
         * @param {Array<string>} [severityIn] Filter results where severity is in a comma-separated list of values
         * @param {string} [severityNe] Filter results where severity not equal to value
         * @param {string} [status] Filter results where status matches value
         * @param {Array<string>} [statusIn] Filter results where status is in a comma-separated list of values
         * @param {string} [statusNe] Filter results where status not equal to value
         * @param {string} [type] Filter results where type matches value
         * @param {Array<string>} [typeIn] Filter results where type is in a comma-separated list of values
         * @param {string} [typeNe] Filter results where type not equal to value
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(id?: string, idIn?: Array<string>, limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, severity?: string, severityIn?: Array<string>, severityNe?: string, status?: string, statusIn?: Array<string>, statusNe?: string, type?: string, typeIn?: Array<string>, typeNe?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedrpmUpdateRecordResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(id, idIn, limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, severity, severityIn, severityNe, status, statusIn, statusNe, type, typeIn, typeNe, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A ViewSet for UpdateRecord.  Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/advisories/  Also specify queryset and serializer for UpdateRecord.
         * @summary Inspect an update record
         * @param {string} rpmUpdateRecordHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(rpmUpdateRecordHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RpmUpdateRecordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(rpmUpdateRecordHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContentAdvisoriesApi - factory interface
 * @export
 */
export const ContentAdvisoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentAdvisoriesApiFp(configuration)
    return {
        /**
         * Trigger an asynchronous task to create content,optionally create new repository version.
         * @summary Create an update record
         * @param {any} [file] An uploaded file that may be turned into the artifact of the content unit.
         * @param {string} [repository] A URI of a repository the new content unit should be associated with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(file?: any, repository?: string, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.create(file, repository, options).then((request) => request(axios, basePath));
        },
        /**
         * A ViewSet for UpdateRecord.  Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/advisories/  Also specify queryset and serializer for UpdateRecord.
         * @summary List update records
         * @param {string} [id] Filter results where id matches value
         * @param {Array<string>} [idIn] Filter results where id is in a comma-separated list of values
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [severity] Filter results where severity matches value
         * @param {Array<string>} [severityIn] Filter results where severity is in a comma-separated list of values
         * @param {string} [severityNe] Filter results where severity not equal to value
         * @param {string} [status] Filter results where status matches value
         * @param {Array<string>} [statusIn] Filter results where status is in a comma-separated list of values
         * @param {string} [statusNe] Filter results where status not equal to value
         * @param {string} [type] Filter results where type matches value
         * @param {Array<string>} [typeIn] Filter results where type is in a comma-separated list of values
         * @param {string} [typeNe] Filter results where type not equal to value
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(id?: string, idIn?: Array<string>, limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, severity?: string, severityIn?: Array<string>, severityNe?: string, status?: string, statusIn?: Array<string>, statusNe?: string, type?: string, typeIn?: Array<string>, typeNe?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedrpmUpdateRecordResponseList> {
            return localVarFp.list(id, idIn, limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, severity, severityIn, severityNe, status, statusIn, statusNe, type, typeIn, typeNe, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * A ViewSet for UpdateRecord.  Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/advisories/  Also specify queryset and serializer for UpdateRecord.
         * @summary Inspect an update record
         * @param {string} rpmUpdateRecordHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(rpmUpdateRecordHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<RpmUpdateRecordResponse> {
            return localVarFp.read(rpmUpdateRecordHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentAdvisoriesApi - object-oriented interface
 * @export
 * @class ContentAdvisoriesApi
 * @extends {BaseAPI}
 */
export class ContentAdvisoriesApi extends BaseAPI {
    /**
     * Trigger an asynchronous task to create content,optionally create new repository version.
     * @summary Create an update record
     * @param {any} [file] An uploaded file that may be turned into the artifact of the content unit.
     * @param {string} [repository] A URI of a repository the new content unit should be associated with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentAdvisoriesApi
     */
    public create(file?: any, repository?: string, options?: any) {
        return ContentAdvisoriesApiFp(this.configuration).create(file, repository, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A ViewSet for UpdateRecord.  Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/advisories/  Also specify queryset and serializer for UpdateRecord.
     * @summary List update records
     * @param {string} [id] Filter results where id matches value
     * @param {Array<string>} [idIn] Filter results where id is in a comma-separated list of values
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [repositoryVersion] Repository Version referenced by HREF
     * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
     * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
     * @param {string} [severity] Filter results where severity matches value
     * @param {Array<string>} [severityIn] Filter results where severity is in a comma-separated list of values
     * @param {string} [severityNe] Filter results where severity not equal to value
     * @param {string} [status] Filter results where status matches value
     * @param {Array<string>} [statusIn] Filter results where status is in a comma-separated list of values
     * @param {string} [statusNe] Filter results where status not equal to value
     * @param {string} [type] Filter results where type matches value
     * @param {Array<string>} [typeIn] Filter results where type is in a comma-separated list of values
     * @param {string} [typeNe] Filter results where type not equal to value
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentAdvisoriesApi
     */
    public list(id?: string, idIn?: Array<string>, limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, severity?: string, severityIn?: Array<string>, severityNe?: string, status?: string, statusIn?: Array<string>, statusNe?: string, type?: string, typeIn?: Array<string>, typeNe?: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentAdvisoriesApiFp(this.configuration).list(id, idIn, limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, severity, severityIn, severityNe, status, statusIn, statusNe, type, typeIn, typeNe, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A ViewSet for UpdateRecord.  Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/advisories/  Also specify queryset and serializer for UpdateRecord.
     * @summary Inspect an update record
     * @param {string} rpmUpdateRecordHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentAdvisoriesApi
     */
    public read(rpmUpdateRecordHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentAdvisoriesApiFp(this.configuration).read(rpmUpdateRecordHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentDistributionTreesApi - axios parameter creator
 * @export
 */
export const ContentDistributionTreesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Distribution Tree Viewset.
         * @summary List distribution trees
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/content/rpm/distribution_trees/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (repositoryVersion !== undefined) {
                localVarQueryParameter['repository_version'] = repositoryVersion;
            }

            if (repositoryVersionAdded !== undefined) {
                localVarQueryParameter['repository_version_added'] = repositoryVersionAdded;
            }

            if (repositoryVersionRemoved !== undefined) {
                localVarQueryParameter['repository_version_removed'] = repositoryVersionRemoved;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Distribution Tree Viewset.
         * @summary Inspect a distribution tree
         * @param {string} rpmDistributionTreeHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (rpmDistributionTreeHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmDistributionTreeHref' is not null or undefined
            assertParamExists('read', 'rpmDistributionTreeHref', rpmDistributionTreeHref)
            const localVarPath = `{rpm_distribution_tree_href}`
                .replace(`{${"rpm_distribution_tree_href"}}`, String(rpmDistributionTreeHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentDistributionTreesApi - functional programming interface
 * @export
 */
export const ContentDistributionTreesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentDistributionTreesApiAxiosParamCreator(configuration)
    return {
        /**
         * Distribution Tree Viewset.
         * @summary List distribution trees
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedrpmDistributionTreeResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Distribution Tree Viewset.
         * @summary Inspect a distribution tree
         * @param {string} rpmDistributionTreeHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(rpmDistributionTreeHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RpmDistributionTreeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(rpmDistributionTreeHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContentDistributionTreesApi - factory interface
 * @export
 */
export const ContentDistributionTreesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentDistributionTreesApiFp(configuration)
    return {
        /**
         * Distribution Tree Viewset.
         * @summary List distribution trees
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedrpmDistributionTreeResponseList> {
            return localVarFp.list(limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Distribution Tree Viewset.
         * @summary Inspect a distribution tree
         * @param {string} rpmDistributionTreeHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(rpmDistributionTreeHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<RpmDistributionTreeResponse> {
            return localVarFp.read(rpmDistributionTreeHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentDistributionTreesApi - object-oriented interface
 * @export
 * @class ContentDistributionTreesApi
 * @extends {BaseAPI}
 */
export class ContentDistributionTreesApi extends BaseAPI {
    /**
     * Distribution Tree Viewset.
     * @summary List distribution trees
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [repositoryVersion] Repository Version referenced by HREF
     * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
     * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentDistributionTreesApi
     */
    public list(limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentDistributionTreesApiFp(this.configuration).list(limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Distribution Tree Viewset.
     * @summary Inspect a distribution tree
     * @param {string} rpmDistributionTreeHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentDistributionTreesApi
     */
    public read(rpmDistributionTreeHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentDistributionTreesApiFp(this.configuration).read(rpmDistributionTreeHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentModulemdDefaultsApi - axios parameter creator
 * @export
 */
export const ContentModulemdDefaultsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous task to create content,optionally create new repository version.
         * @summary Create a modulemd defaults
         * @param {string} relativePath Path where the artifact is located relative to distributions base_path
         * @param {string} module Modulemd name.
         * @param {string} stream Modulemd default stream.
         * @param {object} profiles Default profiles for modulemd streams.
         * @param {string} [artifact] Artifact file representing the physical content
         * @param {any} [file] An uploaded file that may be turned into the artifact of the content unit.
         * @param {string} [repository] A URI of a repository the new content unit should be associated with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (relativePath: string, module: string, stream: string, profiles: object, artifact?: string, file?: any, repository?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'relativePath' is not null or undefined
            assertParamExists('create', 'relativePath', relativePath)
            // verify required parameter 'module' is not null or undefined
            assertParamExists('create', 'module', module)
            // verify required parameter 'stream' is not null or undefined
            assertParamExists('create', 'stream', stream)
            // verify required parameter 'profiles' is not null or undefined
            assertParamExists('create', 'profiles', profiles)
            const localVarPath = `/pulp/api/v3/content/rpm/modulemd_defaults/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


            if (artifact !== undefined) { 
                localVarFormParams.append('artifact', artifact as any);
            }
    
            if (relativePath !== undefined) { 
                localVarFormParams.append('relative_path', relativePath as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (repository !== undefined) { 
                localVarFormParams.append('repository', repository as any);
            }
    
            if (module !== undefined) { 
                localVarFormParams.append('module', module as any);
            }
    
            if (stream !== undefined) { 
                localVarFormParams.append('stream', stream as any);
            }
    
            if (profiles !== undefined) { 
                localVarFormParams.append('profiles', new Blob([JSON.stringify(profiles)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for Modulemd.
         * @summary List modulemd defaultss
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [module] Filter results where module matches value
         * @param {Array<string>} [moduleIn] Filter results where module is in a comma-separated list of values
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [sha256] 
         * @param {string} [stream] Filter results where stream matches value
         * @param {Array<string>} [streamIn] Filter results where stream is in a comma-separated list of values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, module?: string, moduleIn?: Array<string>, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, sha256?: string, stream?: string, streamIn?: Array<string>, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/content/rpm/modulemd_defaults/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (module !== undefined) {
                localVarQueryParameter['module'] = module;
            }

            if (moduleIn) {
                localVarQueryParameter['module__in'] = moduleIn.join(COLLECTION_FORMATS.csv);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (repositoryVersion !== undefined) {
                localVarQueryParameter['repository_version'] = repositoryVersion;
            }

            if (repositoryVersionAdded !== undefined) {
                localVarQueryParameter['repository_version_added'] = repositoryVersionAdded;
            }

            if (repositoryVersionRemoved !== undefined) {
                localVarQueryParameter['repository_version_removed'] = repositoryVersionRemoved;
            }

            if (sha256 !== undefined) {
                localVarQueryParameter['sha256'] = sha256;
            }

            if (stream !== undefined) {
                localVarQueryParameter['stream'] = stream;
            }

            if (streamIn) {
                localVarQueryParameter['stream__in'] = streamIn.join(COLLECTION_FORMATS.csv);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for Modulemd.
         * @summary Inspect a modulemd defaults
         * @param {string} rpmModulemdDefaultsHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (rpmModulemdDefaultsHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmModulemdDefaultsHref' is not null or undefined
            assertParamExists('read', 'rpmModulemdDefaultsHref', rpmModulemdDefaultsHref)
            const localVarPath = `{rpm_modulemd_defaults_href}`
                .replace(`{${"rpm_modulemd_defaults_href"}}`, String(rpmModulemdDefaultsHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentModulemdDefaultsApi - functional programming interface
 * @export
 */
export const ContentModulemdDefaultsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentModulemdDefaultsApiAxiosParamCreator(configuration)
    return {
        /**
         * Trigger an asynchronous task to create content,optionally create new repository version.
         * @summary Create a modulemd defaults
         * @param {string} relativePath Path where the artifact is located relative to distributions base_path
         * @param {string} module Modulemd name.
         * @param {string} stream Modulemd default stream.
         * @param {object} profiles Default profiles for modulemd streams.
         * @param {string} [artifact] Artifact file representing the physical content
         * @param {any} [file] An uploaded file that may be turned into the artifact of the content unit.
         * @param {string} [repository] A URI of a repository the new content unit should be associated with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(relativePath: string, module: string, stream: string, profiles: object, artifact?: string, file?: any, repository?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(relativePath, module, stream, profiles, artifact, file, repository, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for Modulemd.
         * @summary List modulemd defaultss
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [module] Filter results where module matches value
         * @param {Array<string>} [moduleIn] Filter results where module is in a comma-separated list of values
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [sha256] 
         * @param {string} [stream] Filter results where stream matches value
         * @param {Array<string>} [streamIn] Filter results where stream is in a comma-separated list of values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, module?: string, moduleIn?: Array<string>, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, sha256?: string, stream?: string, streamIn?: Array<string>, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedrpmModulemdDefaultsResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, module, moduleIn, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, sha256, stream, streamIn, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for Modulemd.
         * @summary Inspect a modulemd defaults
         * @param {string} rpmModulemdDefaultsHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(rpmModulemdDefaultsHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RpmModulemdDefaultsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(rpmModulemdDefaultsHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContentModulemdDefaultsApi - factory interface
 * @export
 */
export const ContentModulemdDefaultsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentModulemdDefaultsApiFp(configuration)
    return {
        /**
         * Trigger an asynchronous task to create content,optionally create new repository version.
         * @summary Create a modulemd defaults
         * @param {string} relativePath Path where the artifact is located relative to distributions base_path
         * @param {string} module Modulemd name.
         * @param {string} stream Modulemd default stream.
         * @param {object} profiles Default profiles for modulemd streams.
         * @param {string} [artifact] Artifact file representing the physical content
         * @param {any} [file] An uploaded file that may be turned into the artifact of the content unit.
         * @param {string} [repository] A URI of a repository the new content unit should be associated with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(relativePath: string, module: string, stream: string, profiles: object, artifact?: string, file?: any, repository?: string, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.create(relativePath, module, stream, profiles, artifact, file, repository, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for Modulemd.
         * @summary List modulemd defaultss
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [module] Filter results where module matches value
         * @param {Array<string>} [moduleIn] Filter results where module is in a comma-separated list of values
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [sha256] 
         * @param {string} [stream] Filter results where stream matches value
         * @param {Array<string>} [streamIn] Filter results where stream is in a comma-separated list of values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, module?: string, moduleIn?: Array<string>, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, sha256?: string, stream?: string, streamIn?: Array<string>, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedrpmModulemdDefaultsResponseList> {
            return localVarFp.list(limit, module, moduleIn, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, sha256, stream, streamIn, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for Modulemd.
         * @summary Inspect a modulemd defaults
         * @param {string} rpmModulemdDefaultsHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(rpmModulemdDefaultsHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<RpmModulemdDefaultsResponse> {
            return localVarFp.read(rpmModulemdDefaultsHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentModulemdDefaultsApi - object-oriented interface
 * @export
 * @class ContentModulemdDefaultsApi
 * @extends {BaseAPI}
 */
export class ContentModulemdDefaultsApi extends BaseAPI {
    /**
     * Trigger an asynchronous task to create content,optionally create new repository version.
     * @summary Create a modulemd defaults
     * @param {string} relativePath Path where the artifact is located relative to distributions base_path
     * @param {string} module Modulemd name.
     * @param {string} stream Modulemd default stream.
     * @param {object} profiles Default profiles for modulemd streams.
     * @param {string} [artifact] Artifact file representing the physical content
     * @param {any} [file] An uploaded file that may be turned into the artifact of the content unit.
     * @param {string} [repository] A URI of a repository the new content unit should be associated with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentModulemdDefaultsApi
     */
    public create(relativePath: string, module: string, stream: string, profiles: object, artifact?: string, file?: any, repository?: string, options?: any) {
        return ContentModulemdDefaultsApiFp(this.configuration).create(relativePath, module, stream, profiles, artifact, file, repository, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for Modulemd.
     * @summary List modulemd defaultss
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [module] Filter results where module matches value
     * @param {Array<string>} [moduleIn] Filter results where module is in a comma-separated list of values
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [repositoryVersion] Repository Version referenced by HREF
     * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
     * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
     * @param {string} [sha256] 
     * @param {string} [stream] Filter results where stream matches value
     * @param {Array<string>} [streamIn] Filter results where stream is in a comma-separated list of values
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentModulemdDefaultsApi
     */
    public list(limit?: number, module?: string, moduleIn?: Array<string>, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, sha256?: string, stream?: string, streamIn?: Array<string>, fields?: string, excludeFields?: string, options?: any) {
        return ContentModulemdDefaultsApiFp(this.configuration).list(limit, module, moduleIn, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, sha256, stream, streamIn, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for Modulemd.
     * @summary Inspect a modulemd defaults
     * @param {string} rpmModulemdDefaultsHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentModulemdDefaultsApi
     */
    public read(rpmModulemdDefaultsHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentModulemdDefaultsApiFp(this.configuration).read(rpmModulemdDefaultsHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentModulemdsApi - axios parameter creator
 * @export
 */
export const ContentModulemdsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous task to create content,optionally create new repository version.
         * @summary Create a modulemd
         * @param {string} relativePath Path where the artifact is located relative to distributions base_path
         * @param {string} name Modulemd name.
         * @param {string} stream Stream name.
         * @param {string} version Modulemd version.
         * @param {string} context Modulemd context.
         * @param {string} arch Modulemd architecture.
         * @param {object} artifacts Modulemd artifacts.
         * @param {object} dependencies Modulemd dependencies.
         * @param {string} [artifact] Artifact file representing the physical content
         * @param {any} [file] An uploaded file that may be turned into the artifact of the content unit.
         * @param {string} [repository] A URI of a repository the new content unit should be associated with.
         * @param {boolean} [staticContext] Modulemd static-context flag.
         * @param {Array<string>} [packages] Modulemd artifacts\&#39; packages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (relativePath: string, name: string, stream: string, version: string, context: string, arch: string, artifacts: object, dependencies: object, artifact?: string, file?: any, repository?: string, staticContext?: boolean, packages?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'relativePath' is not null or undefined
            assertParamExists('create', 'relativePath', relativePath)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('create', 'name', name)
            // verify required parameter 'stream' is not null or undefined
            assertParamExists('create', 'stream', stream)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('create', 'version', version)
            // verify required parameter 'context' is not null or undefined
            assertParamExists('create', 'context', context)
            // verify required parameter 'arch' is not null or undefined
            assertParamExists('create', 'arch', arch)
            // verify required parameter 'artifacts' is not null or undefined
            assertParamExists('create', 'artifacts', artifacts)
            // verify required parameter 'dependencies' is not null or undefined
            assertParamExists('create', 'dependencies', dependencies)
            const localVarPath = `/pulp/api/v3/content/rpm/modulemds/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


            if (artifact !== undefined) { 
                localVarFormParams.append('artifact', artifact as any);
            }
    
            if (relativePath !== undefined) { 
                localVarFormParams.append('relative_path', relativePath as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (repository !== undefined) { 
                localVarFormParams.append('repository', repository as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (stream !== undefined) { 
                localVarFormParams.append('stream', stream as any);
            }
    
            if (version !== undefined) { 
                localVarFormParams.append('version', version as any);
            }
    
            if (staticContext !== undefined) { 
                localVarFormParams.append('static_context', staticContext as any);
            }
    
            if (context !== undefined) { 
                localVarFormParams.append('context', context as any);
            }
    
            if (arch !== undefined) { 
                localVarFormParams.append('arch', arch as any);
            }
    
            if (artifacts !== undefined) { 
                localVarFormParams.append('artifacts', new Blob([JSON.stringify(artifacts)], { type: "application/json", }));
            }
    
            if (dependencies !== undefined) { 
                localVarFormParams.append('dependencies', new Blob([JSON.stringify(dependencies)], { type: "application/json", }));
            }
                if (packages) {
                localVarFormParams.append('packages', packages.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for Modulemd.
         * @summary List modulemds
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] Filter results where name matches value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [sha256] 
         * @param {string} [stream] Filter results where stream matches value
         * @param {Array<string>} [streamIn] Filter results where stream is in a comma-separated list of values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, name?: string, nameIn?: Array<string>, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, sha256?: string, stream?: string, streamIn?: Array<string>, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/content/rpm/modulemds/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameIn) {
                localVarQueryParameter['name__in'] = nameIn.join(COLLECTION_FORMATS.csv);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (repositoryVersion !== undefined) {
                localVarQueryParameter['repository_version'] = repositoryVersion;
            }

            if (repositoryVersionAdded !== undefined) {
                localVarQueryParameter['repository_version_added'] = repositoryVersionAdded;
            }

            if (repositoryVersionRemoved !== undefined) {
                localVarQueryParameter['repository_version_removed'] = repositoryVersionRemoved;
            }

            if (sha256 !== undefined) {
                localVarQueryParameter['sha256'] = sha256;
            }

            if (stream !== undefined) {
                localVarQueryParameter['stream'] = stream;
            }

            if (streamIn) {
                localVarQueryParameter['stream__in'] = streamIn.join(COLLECTION_FORMATS.csv);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for Modulemd.
         * @summary Inspect a modulemd
         * @param {string} rpmModulemdHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (rpmModulemdHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmModulemdHref' is not null or undefined
            assertParamExists('read', 'rpmModulemdHref', rpmModulemdHref)
            const localVarPath = `{rpm_modulemd_href}`
                .replace(`{${"rpm_modulemd_href"}}`, String(rpmModulemdHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentModulemdsApi - functional programming interface
 * @export
 */
export const ContentModulemdsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentModulemdsApiAxiosParamCreator(configuration)
    return {
        /**
         * Trigger an asynchronous task to create content,optionally create new repository version.
         * @summary Create a modulemd
         * @param {string} relativePath Path where the artifact is located relative to distributions base_path
         * @param {string} name Modulemd name.
         * @param {string} stream Stream name.
         * @param {string} version Modulemd version.
         * @param {string} context Modulemd context.
         * @param {string} arch Modulemd architecture.
         * @param {object} artifacts Modulemd artifacts.
         * @param {object} dependencies Modulemd dependencies.
         * @param {string} [artifact] Artifact file representing the physical content
         * @param {any} [file] An uploaded file that may be turned into the artifact of the content unit.
         * @param {string} [repository] A URI of a repository the new content unit should be associated with.
         * @param {boolean} [staticContext] Modulemd static-context flag.
         * @param {Array<string>} [packages] Modulemd artifacts\&#39; packages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(relativePath: string, name: string, stream: string, version: string, context: string, arch: string, artifacts: object, dependencies: object, artifact?: string, file?: any, repository?: string, staticContext?: boolean, packages?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(relativePath, name, stream, version, context, arch, artifacts, dependencies, artifact, file, repository, staticContext, packages, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for Modulemd.
         * @summary List modulemds
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] Filter results where name matches value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [sha256] 
         * @param {string} [stream] Filter results where stream matches value
         * @param {Array<string>} [streamIn] Filter results where stream is in a comma-separated list of values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, name?: string, nameIn?: Array<string>, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, sha256?: string, stream?: string, streamIn?: Array<string>, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedrpmModulemdResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, name, nameIn, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, sha256, stream, streamIn, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for Modulemd.
         * @summary Inspect a modulemd
         * @param {string} rpmModulemdHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(rpmModulemdHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RpmModulemdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(rpmModulemdHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContentModulemdsApi - factory interface
 * @export
 */
export const ContentModulemdsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentModulemdsApiFp(configuration)
    return {
        /**
         * Trigger an asynchronous task to create content,optionally create new repository version.
         * @summary Create a modulemd
         * @param {string} relativePath Path where the artifact is located relative to distributions base_path
         * @param {string} name Modulemd name.
         * @param {string} stream Stream name.
         * @param {string} version Modulemd version.
         * @param {string} context Modulemd context.
         * @param {string} arch Modulemd architecture.
         * @param {object} artifacts Modulemd artifacts.
         * @param {object} dependencies Modulemd dependencies.
         * @param {string} [artifact] Artifact file representing the physical content
         * @param {any} [file] An uploaded file that may be turned into the artifact of the content unit.
         * @param {string} [repository] A URI of a repository the new content unit should be associated with.
         * @param {boolean} [staticContext] Modulemd static-context flag.
         * @param {Array<string>} [packages] Modulemd artifacts\&#39; packages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(relativePath: string, name: string, stream: string, version: string, context: string, arch: string, artifacts: object, dependencies: object, artifact?: string, file?: any, repository?: string, staticContext?: boolean, packages?: Array<string>, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.create(relativePath, name, stream, version, context, arch, artifacts, dependencies, artifact, file, repository, staticContext, packages, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for Modulemd.
         * @summary List modulemds
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] Filter results where name matches value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [sha256] 
         * @param {string} [stream] Filter results where stream matches value
         * @param {Array<string>} [streamIn] Filter results where stream is in a comma-separated list of values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, name?: string, nameIn?: Array<string>, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, sha256?: string, stream?: string, streamIn?: Array<string>, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedrpmModulemdResponseList> {
            return localVarFp.list(limit, name, nameIn, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, sha256, stream, streamIn, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for Modulemd.
         * @summary Inspect a modulemd
         * @param {string} rpmModulemdHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(rpmModulemdHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<RpmModulemdResponse> {
            return localVarFp.read(rpmModulemdHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentModulemdsApi - object-oriented interface
 * @export
 * @class ContentModulemdsApi
 * @extends {BaseAPI}
 */
export class ContentModulemdsApi extends BaseAPI {
    /**
     * Trigger an asynchronous task to create content,optionally create new repository version.
     * @summary Create a modulemd
     * @param {string} relativePath Path where the artifact is located relative to distributions base_path
     * @param {string} name Modulemd name.
     * @param {string} stream Stream name.
     * @param {string} version Modulemd version.
     * @param {string} context Modulemd context.
     * @param {string} arch Modulemd architecture.
     * @param {object} artifacts Modulemd artifacts.
     * @param {object} dependencies Modulemd dependencies.
     * @param {string} [artifact] Artifact file representing the physical content
     * @param {any} [file] An uploaded file that may be turned into the artifact of the content unit.
     * @param {string} [repository] A URI of a repository the new content unit should be associated with.
     * @param {boolean} [staticContext] Modulemd static-context flag.
     * @param {Array<string>} [packages] Modulemd artifacts\&#39; packages.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentModulemdsApi
     */
    public create(relativePath: string, name: string, stream: string, version: string, context: string, arch: string, artifacts: object, dependencies: object, artifact?: string, file?: any, repository?: string, staticContext?: boolean, packages?: Array<string>, options?: any) {
        return ContentModulemdsApiFp(this.configuration).create(relativePath, name, stream, version, context, arch, artifacts, dependencies, artifact, file, repository, staticContext, packages, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for Modulemd.
     * @summary List modulemds
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] Filter results where name matches value
     * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [repositoryVersion] Repository Version referenced by HREF
     * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
     * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
     * @param {string} [sha256] 
     * @param {string} [stream] Filter results where stream matches value
     * @param {Array<string>} [streamIn] Filter results where stream is in a comma-separated list of values
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentModulemdsApi
     */
    public list(limit?: number, name?: string, nameIn?: Array<string>, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, sha256?: string, stream?: string, streamIn?: Array<string>, fields?: string, excludeFields?: string, options?: any) {
        return ContentModulemdsApiFp(this.configuration).list(limit, name, nameIn, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, sha256, stream, streamIn, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for Modulemd.
     * @summary Inspect a modulemd
     * @param {string} rpmModulemdHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentModulemdsApi
     */
    public read(rpmModulemdHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentModulemdsApiFp(this.configuration).read(rpmModulemdHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentPackagecategoriesApi - axios parameter creator
 * @export
 */
export const ContentPackagecategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * PackageCategory ViewSet.
         * @summary List package categorys
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/content/rpm/packagecategories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (repositoryVersion !== undefined) {
                localVarQueryParameter['repository_version'] = repositoryVersion;
            }

            if (repositoryVersionAdded !== undefined) {
                localVarQueryParameter['repository_version_added'] = repositoryVersionAdded;
            }

            if (repositoryVersionRemoved !== undefined) {
                localVarQueryParameter['repository_version_removed'] = repositoryVersionRemoved;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PackageCategory ViewSet.
         * @summary Inspect a package category
         * @param {string} rpmPackageCategoryHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (rpmPackageCategoryHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmPackageCategoryHref' is not null or undefined
            assertParamExists('read', 'rpmPackageCategoryHref', rpmPackageCategoryHref)
            const localVarPath = `{rpm_package_category_href}`
                .replace(`{${"rpm_package_category_href"}}`, String(rpmPackageCategoryHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentPackagecategoriesApi - functional programming interface
 * @export
 */
export const ContentPackagecategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentPackagecategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * PackageCategory ViewSet.
         * @summary List package categorys
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedrpmPackageCategoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * PackageCategory ViewSet.
         * @summary Inspect a package category
         * @param {string} rpmPackageCategoryHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(rpmPackageCategoryHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RpmPackageCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(rpmPackageCategoryHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContentPackagecategoriesApi - factory interface
 * @export
 */
export const ContentPackagecategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentPackagecategoriesApiFp(configuration)
    return {
        /**
         * PackageCategory ViewSet.
         * @summary List package categorys
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedrpmPackageCategoryResponseList> {
            return localVarFp.list(limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * PackageCategory ViewSet.
         * @summary Inspect a package category
         * @param {string} rpmPackageCategoryHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(rpmPackageCategoryHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<RpmPackageCategoryResponse> {
            return localVarFp.read(rpmPackageCategoryHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentPackagecategoriesApi - object-oriented interface
 * @export
 * @class ContentPackagecategoriesApi
 * @extends {BaseAPI}
 */
export class ContentPackagecategoriesApi extends BaseAPI {
    /**
     * PackageCategory ViewSet.
     * @summary List package categorys
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [repositoryVersion] Repository Version referenced by HREF
     * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
     * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentPackagecategoriesApi
     */
    public list(limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentPackagecategoriesApiFp(this.configuration).list(limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PackageCategory ViewSet.
     * @summary Inspect a package category
     * @param {string} rpmPackageCategoryHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentPackagecategoriesApi
     */
    public read(rpmPackageCategoryHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentPackagecategoriesApiFp(this.configuration).read(rpmPackageCategoryHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentPackageenvironmentsApi - axios parameter creator
 * @export
 */
export const ContentPackageenvironmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * PackageEnvironment ViewSet.
         * @summary List package environments
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/content/rpm/packageenvironments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (repositoryVersion !== undefined) {
                localVarQueryParameter['repository_version'] = repositoryVersion;
            }

            if (repositoryVersionAdded !== undefined) {
                localVarQueryParameter['repository_version_added'] = repositoryVersionAdded;
            }

            if (repositoryVersionRemoved !== undefined) {
                localVarQueryParameter['repository_version_removed'] = repositoryVersionRemoved;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PackageEnvironment ViewSet.
         * @summary Inspect a package environment
         * @param {string} rpmPackageEnvironmentHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (rpmPackageEnvironmentHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmPackageEnvironmentHref' is not null or undefined
            assertParamExists('read', 'rpmPackageEnvironmentHref', rpmPackageEnvironmentHref)
            const localVarPath = `{rpm_package_environment_href}`
                .replace(`{${"rpm_package_environment_href"}}`, String(rpmPackageEnvironmentHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentPackageenvironmentsApi - functional programming interface
 * @export
 */
export const ContentPackageenvironmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentPackageenvironmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * PackageEnvironment ViewSet.
         * @summary List package environments
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedrpmPackageEnvironmentResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * PackageEnvironment ViewSet.
         * @summary Inspect a package environment
         * @param {string} rpmPackageEnvironmentHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(rpmPackageEnvironmentHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RpmPackageEnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(rpmPackageEnvironmentHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContentPackageenvironmentsApi - factory interface
 * @export
 */
export const ContentPackageenvironmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentPackageenvironmentsApiFp(configuration)
    return {
        /**
         * PackageEnvironment ViewSet.
         * @summary List package environments
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedrpmPackageEnvironmentResponseList> {
            return localVarFp.list(limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * PackageEnvironment ViewSet.
         * @summary Inspect a package environment
         * @param {string} rpmPackageEnvironmentHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(rpmPackageEnvironmentHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<RpmPackageEnvironmentResponse> {
            return localVarFp.read(rpmPackageEnvironmentHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentPackageenvironmentsApi - object-oriented interface
 * @export
 * @class ContentPackageenvironmentsApi
 * @extends {BaseAPI}
 */
export class ContentPackageenvironmentsApi extends BaseAPI {
    /**
     * PackageEnvironment ViewSet.
     * @summary List package environments
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [repositoryVersion] Repository Version referenced by HREF
     * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
     * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentPackageenvironmentsApi
     */
    public list(limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentPackageenvironmentsApiFp(this.configuration).list(limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PackageEnvironment ViewSet.
     * @summary Inspect a package environment
     * @param {string} rpmPackageEnvironmentHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentPackageenvironmentsApi
     */
    public read(rpmPackageEnvironmentHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentPackageenvironmentsApiFp(this.configuration).read(rpmPackageEnvironmentHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentPackagegroupsApi - axios parameter creator
 * @export
 */
export const ContentPackagegroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * PackageGroup ViewSet.
         * @summary List package groups
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/content/rpm/packagegroups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (repositoryVersion !== undefined) {
                localVarQueryParameter['repository_version'] = repositoryVersion;
            }

            if (repositoryVersionAdded !== undefined) {
                localVarQueryParameter['repository_version_added'] = repositoryVersionAdded;
            }

            if (repositoryVersionRemoved !== undefined) {
                localVarQueryParameter['repository_version_removed'] = repositoryVersionRemoved;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PackageGroup ViewSet.
         * @summary Inspect a package group
         * @param {string} rpmPackageGroupHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (rpmPackageGroupHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmPackageGroupHref' is not null or undefined
            assertParamExists('read', 'rpmPackageGroupHref', rpmPackageGroupHref)
            const localVarPath = `{rpm_package_group_href}`
                .replace(`{${"rpm_package_group_href"}}`, String(rpmPackageGroupHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentPackagegroupsApi - functional programming interface
 * @export
 */
export const ContentPackagegroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentPackagegroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * PackageGroup ViewSet.
         * @summary List package groups
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedrpmPackageGroupResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * PackageGroup ViewSet.
         * @summary Inspect a package group
         * @param {string} rpmPackageGroupHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(rpmPackageGroupHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RpmPackageGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(rpmPackageGroupHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContentPackagegroupsApi - factory interface
 * @export
 */
export const ContentPackagegroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentPackagegroupsApiFp(configuration)
    return {
        /**
         * PackageGroup ViewSet.
         * @summary List package groups
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedrpmPackageGroupResponseList> {
            return localVarFp.list(limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * PackageGroup ViewSet.
         * @summary Inspect a package group
         * @param {string} rpmPackageGroupHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(rpmPackageGroupHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<RpmPackageGroupResponse> {
            return localVarFp.read(rpmPackageGroupHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentPackagegroupsApi - object-oriented interface
 * @export
 * @class ContentPackagegroupsApi
 * @extends {BaseAPI}
 */
export class ContentPackagegroupsApi extends BaseAPI {
    /**
     * PackageGroup ViewSet.
     * @summary List package groups
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [repositoryVersion] Repository Version referenced by HREF
     * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
     * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentPackagegroupsApi
     */
    public list(limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentPackagegroupsApiFp(this.configuration).list(limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PackageGroup ViewSet.
     * @summary Inspect a package group
     * @param {string} rpmPackageGroupHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentPackagegroupsApi
     */
    public read(rpmPackageGroupHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentPackagegroupsApiFp(this.configuration).read(rpmPackageGroupHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentPackagelangpacksApi - axios parameter creator
 * @export
 */
export const ContentPackagelangpacksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * PackageLangpacks ViewSet.
         * @summary List package langpackss
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/content/rpm/packagelangpacks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (repositoryVersion !== undefined) {
                localVarQueryParameter['repository_version'] = repositoryVersion;
            }

            if (repositoryVersionAdded !== undefined) {
                localVarQueryParameter['repository_version_added'] = repositoryVersionAdded;
            }

            if (repositoryVersionRemoved !== undefined) {
                localVarQueryParameter['repository_version_removed'] = repositoryVersionRemoved;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PackageLangpacks ViewSet.
         * @summary Inspect a package langpacks
         * @param {string} rpmPackageLangpacksHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (rpmPackageLangpacksHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmPackageLangpacksHref' is not null or undefined
            assertParamExists('read', 'rpmPackageLangpacksHref', rpmPackageLangpacksHref)
            const localVarPath = `{rpm_package_langpacks_href}`
                .replace(`{${"rpm_package_langpacks_href"}}`, String(rpmPackageLangpacksHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentPackagelangpacksApi - functional programming interface
 * @export
 */
export const ContentPackagelangpacksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentPackagelangpacksApiAxiosParamCreator(configuration)
    return {
        /**
         * PackageLangpacks ViewSet.
         * @summary List package langpackss
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedrpmPackageLangpacksResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * PackageLangpacks ViewSet.
         * @summary Inspect a package langpacks
         * @param {string} rpmPackageLangpacksHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(rpmPackageLangpacksHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RpmPackageLangpacksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(rpmPackageLangpacksHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContentPackagelangpacksApi - factory interface
 * @export
 */
export const ContentPackagelangpacksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentPackagelangpacksApiFp(configuration)
    return {
        /**
         * PackageLangpacks ViewSet.
         * @summary List package langpackss
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedrpmPackageLangpacksResponseList> {
            return localVarFp.list(limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * PackageLangpacks ViewSet.
         * @summary Inspect a package langpacks
         * @param {string} rpmPackageLangpacksHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(rpmPackageLangpacksHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<RpmPackageLangpacksResponse> {
            return localVarFp.read(rpmPackageLangpacksHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentPackagelangpacksApi - object-oriented interface
 * @export
 * @class ContentPackagelangpacksApi
 * @extends {BaseAPI}
 */
export class ContentPackagelangpacksApi extends BaseAPI {
    /**
     * PackageLangpacks ViewSet.
     * @summary List package langpackss
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [repositoryVersion] Repository Version referenced by HREF
     * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
     * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentPackagelangpacksApi
     */
    public list(limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentPackagelangpacksApiFp(this.configuration).list(limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PackageLangpacks ViewSet.
     * @summary Inspect a package langpacks
     * @param {string} rpmPackageLangpacksHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentPackagelangpacksApi
     */
    public read(rpmPackageLangpacksHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentPackagelangpacksApiFp(this.configuration).read(rpmPackageLangpacksHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentPackagesApi - axios parameter creator
 * @export
 */
export const ContentPackagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous task to create content,optionally create new repository version.
         * @summary Create a package
         * @param {string} relativePath Path where the artifact is located relative to distributions base_path
         * @param {string} [artifact] Artifact file representing the physical content
         * @param {any} [file] An uploaded file that may be turned into the artifact of the content unit.
         * @param {string} [repository] A URI of a repository the new content unit should be associated with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (relativePath: string, artifact?: string, file?: any, repository?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'relativePath' is not null or undefined
            assertParamExists('create', 'relativePath', relativePath)
            const localVarPath = `/pulp/api/v3/content/rpm/packages/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


            if (artifact !== undefined) { 
                localVarFormParams.append('artifact', artifact as any);
            }
    
            if (relativePath !== undefined) { 
                localVarFormParams.append('relative_path', relativePath as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (repository !== undefined) { 
                localVarFormParams.append('repository', repository as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A ViewSet for Package.  Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/packages/  Also specify queryset and serializer for Package.
         * @summary List packages
         * @param {string} [arch] Filter results where arch matches value
         * @param {Array<string>} [archIn] Filter results where arch is in a comma-separated list of values
         * @param {string} [archNe] Filter results where arch not equal to value
         * @param {'md5' | 'sha1' | 'sha1' | 'sha224' | 'sha256' | 'sha384' | 'sha512' | 'unknown'} [checksumType] Filter results where checksum_type matches value
         * @param {Array<string>} [checksumTypeIn] Filter results where checksum_type is in a comma-separated list of values
         * @param {string} [checksumTypeNe] Filter results where checksum_type not equal to value
         * @param {string} [epoch] Filter results where epoch matches value
         * @param {Array<string>} [epochIn] Filter results where epoch is in a comma-separated list of values
         * @param {string} [epochNe] Filter results where epoch not equal to value
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] Filter results where name matches value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameNe] Filter results where name not equal to value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pkgId] Filter results where pkgId matches value
         * @param {Array<string>} [pkgIdIn] Filter results where pkgId is in a comma-separated list of values
         * @param {string} [release] Filter results where release matches value
         * @param {Array<string>} [releaseIn] Filter results where release is in a comma-separated list of values
         * @param {string} [releaseNe] Filter results where release not equal to value
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [sha256] 
         * @param {string} [version] Filter results where version matches value
         * @param {Array<string>} [versionIn] Filter results where version is in a comma-separated list of values
         * @param {string} [versionNe] Filter results where version not equal to value
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (arch?: string, archIn?: Array<string>, archNe?: string, checksumType?: 'md5' | 'sha1' | 'sha1' | 'sha224' | 'sha256' | 'sha384' | 'sha512' | 'unknown', checksumTypeIn?: Array<string>, checksumTypeNe?: string, epoch?: string, epochIn?: Array<string>, epochNe?: string, limit?: number, name?: string, nameIn?: Array<string>, nameNe?: string, offset?: number, ordering?: string, pkgId?: string, pkgIdIn?: Array<string>, release?: string, releaseIn?: Array<string>, releaseNe?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, sha256?: string, version?: string, versionIn?: Array<string>, versionNe?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/content/rpm/packages/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (arch !== undefined) {
                localVarQueryParameter['arch'] = arch;
            }

            if (archIn) {
                localVarQueryParameter['arch__in'] = archIn.join(COLLECTION_FORMATS.csv);
            }

            if (archNe !== undefined) {
                localVarQueryParameter['arch__ne'] = archNe;
            }

            if (checksumType !== undefined) {
                localVarQueryParameter['checksum_type'] = checksumType;
            }

            if (checksumTypeIn) {
                localVarQueryParameter['checksum_type__in'] = checksumTypeIn.join(COLLECTION_FORMATS.csv);
            }

            if (checksumTypeNe !== undefined) {
                localVarQueryParameter['checksum_type__ne'] = checksumTypeNe;
            }

            if (epoch !== undefined) {
                localVarQueryParameter['epoch'] = epoch;
            }

            if (epochIn) {
                localVarQueryParameter['epoch__in'] = epochIn.join(COLLECTION_FORMATS.csv);
            }

            if (epochNe !== undefined) {
                localVarQueryParameter['epoch__ne'] = epochNe;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameIn) {
                localVarQueryParameter['name__in'] = nameIn.join(COLLECTION_FORMATS.csv);
            }

            if (nameNe !== undefined) {
                localVarQueryParameter['name__ne'] = nameNe;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (pkgId !== undefined) {
                localVarQueryParameter['pkgId'] = pkgId;
            }

            if (pkgIdIn) {
                localVarQueryParameter['pkgId__in'] = pkgIdIn.join(COLLECTION_FORMATS.csv);
            }

            if (release !== undefined) {
                localVarQueryParameter['release'] = release;
            }

            if (releaseIn) {
                localVarQueryParameter['release__in'] = releaseIn.join(COLLECTION_FORMATS.csv);
            }

            if (releaseNe !== undefined) {
                localVarQueryParameter['release__ne'] = releaseNe;
            }

            if (repositoryVersion !== undefined) {
                localVarQueryParameter['repository_version'] = repositoryVersion;
            }

            if (repositoryVersionAdded !== undefined) {
                localVarQueryParameter['repository_version_added'] = repositoryVersionAdded;
            }

            if (repositoryVersionRemoved !== undefined) {
                localVarQueryParameter['repository_version_removed'] = repositoryVersionRemoved;
            }

            if (sha256 !== undefined) {
                localVarQueryParameter['sha256'] = sha256;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (versionIn) {
                localVarQueryParameter['version__in'] = versionIn.join(COLLECTION_FORMATS.csv);
            }

            if (versionNe !== undefined) {
                localVarQueryParameter['version__ne'] = versionNe;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A ViewSet for Package.  Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/packages/  Also specify queryset and serializer for Package.
         * @summary Inspect a package
         * @param {string} rpmPackageHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (rpmPackageHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmPackageHref' is not null or undefined
            assertParamExists('read', 'rpmPackageHref', rpmPackageHref)
            const localVarPath = `{rpm_package_href}`
                .replace(`{${"rpm_package_href"}}`, String(rpmPackageHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentPackagesApi - functional programming interface
 * @export
 */
export const ContentPackagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentPackagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Trigger an asynchronous task to create content,optionally create new repository version.
         * @summary Create a package
         * @param {string} relativePath Path where the artifact is located relative to distributions base_path
         * @param {string} [artifact] Artifact file representing the physical content
         * @param {any} [file] An uploaded file that may be turned into the artifact of the content unit.
         * @param {string} [repository] A URI of a repository the new content unit should be associated with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(relativePath: string, artifact?: string, file?: any, repository?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(relativePath, artifact, file, repository, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A ViewSet for Package.  Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/packages/  Also specify queryset and serializer for Package.
         * @summary List packages
         * @param {string} [arch] Filter results where arch matches value
         * @param {Array<string>} [archIn] Filter results where arch is in a comma-separated list of values
         * @param {string} [archNe] Filter results where arch not equal to value
         * @param {'md5' | 'sha1' | 'sha1' | 'sha224' | 'sha256' | 'sha384' | 'sha512' | 'unknown'} [checksumType] Filter results where checksum_type matches value
         * @param {Array<string>} [checksumTypeIn] Filter results where checksum_type is in a comma-separated list of values
         * @param {string} [checksumTypeNe] Filter results where checksum_type not equal to value
         * @param {string} [epoch] Filter results where epoch matches value
         * @param {Array<string>} [epochIn] Filter results where epoch is in a comma-separated list of values
         * @param {string} [epochNe] Filter results where epoch not equal to value
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] Filter results where name matches value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameNe] Filter results where name not equal to value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pkgId] Filter results where pkgId matches value
         * @param {Array<string>} [pkgIdIn] Filter results where pkgId is in a comma-separated list of values
         * @param {string} [release] Filter results where release matches value
         * @param {Array<string>} [releaseIn] Filter results where release is in a comma-separated list of values
         * @param {string} [releaseNe] Filter results where release not equal to value
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [sha256] 
         * @param {string} [version] Filter results where version matches value
         * @param {Array<string>} [versionIn] Filter results where version is in a comma-separated list of values
         * @param {string} [versionNe] Filter results where version not equal to value
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(arch?: string, archIn?: Array<string>, archNe?: string, checksumType?: 'md5' | 'sha1' | 'sha1' | 'sha224' | 'sha256' | 'sha384' | 'sha512' | 'unknown', checksumTypeIn?: Array<string>, checksumTypeNe?: string, epoch?: string, epochIn?: Array<string>, epochNe?: string, limit?: number, name?: string, nameIn?: Array<string>, nameNe?: string, offset?: number, ordering?: string, pkgId?: string, pkgIdIn?: Array<string>, release?: string, releaseIn?: Array<string>, releaseNe?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, sha256?: string, version?: string, versionIn?: Array<string>, versionNe?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedrpmPackageResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(arch, archIn, archNe, checksumType, checksumTypeIn, checksumTypeNe, epoch, epochIn, epochNe, limit, name, nameIn, nameNe, offset, ordering, pkgId, pkgIdIn, release, releaseIn, releaseNe, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, sha256, version, versionIn, versionNe, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A ViewSet for Package.  Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/packages/  Also specify queryset and serializer for Package.
         * @summary Inspect a package
         * @param {string} rpmPackageHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(rpmPackageHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RpmPackageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(rpmPackageHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContentPackagesApi - factory interface
 * @export
 */
export const ContentPackagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentPackagesApiFp(configuration)
    return {
        /**
         * Trigger an asynchronous task to create content,optionally create new repository version.
         * @summary Create a package
         * @param {string} relativePath Path where the artifact is located relative to distributions base_path
         * @param {string} [artifact] Artifact file representing the physical content
         * @param {any} [file] An uploaded file that may be turned into the artifact of the content unit.
         * @param {string} [repository] A URI of a repository the new content unit should be associated with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(relativePath: string, artifact?: string, file?: any, repository?: string, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.create(relativePath, artifact, file, repository, options).then((request) => request(axios, basePath));
        },
        /**
         * A ViewSet for Package.  Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/packages/  Also specify queryset and serializer for Package.
         * @summary List packages
         * @param {string} [arch] Filter results where arch matches value
         * @param {Array<string>} [archIn] Filter results where arch is in a comma-separated list of values
         * @param {string} [archNe] Filter results where arch not equal to value
         * @param {'md5' | 'sha1' | 'sha1' | 'sha224' | 'sha256' | 'sha384' | 'sha512' | 'unknown'} [checksumType] Filter results where checksum_type matches value
         * @param {Array<string>} [checksumTypeIn] Filter results where checksum_type is in a comma-separated list of values
         * @param {string} [checksumTypeNe] Filter results where checksum_type not equal to value
         * @param {string} [epoch] Filter results where epoch matches value
         * @param {Array<string>} [epochIn] Filter results where epoch is in a comma-separated list of values
         * @param {string} [epochNe] Filter results where epoch not equal to value
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] Filter results where name matches value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameNe] Filter results where name not equal to value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pkgId] Filter results where pkgId matches value
         * @param {Array<string>} [pkgIdIn] Filter results where pkgId is in a comma-separated list of values
         * @param {string} [release] Filter results where release matches value
         * @param {Array<string>} [releaseIn] Filter results where release is in a comma-separated list of values
         * @param {string} [releaseNe] Filter results where release not equal to value
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [sha256] 
         * @param {string} [version] Filter results where version matches value
         * @param {Array<string>} [versionIn] Filter results where version is in a comma-separated list of values
         * @param {string} [versionNe] Filter results where version not equal to value
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(arch?: string, archIn?: Array<string>, archNe?: string, checksumType?: 'md5' | 'sha1' | 'sha1' | 'sha224' | 'sha256' | 'sha384' | 'sha512' | 'unknown', checksumTypeIn?: Array<string>, checksumTypeNe?: string, epoch?: string, epochIn?: Array<string>, epochNe?: string, limit?: number, name?: string, nameIn?: Array<string>, nameNe?: string, offset?: number, ordering?: string, pkgId?: string, pkgIdIn?: Array<string>, release?: string, releaseIn?: Array<string>, releaseNe?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, sha256?: string, version?: string, versionIn?: Array<string>, versionNe?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedrpmPackageResponseList> {
            return localVarFp.list(arch, archIn, archNe, checksumType, checksumTypeIn, checksumTypeNe, epoch, epochIn, epochNe, limit, name, nameIn, nameNe, offset, ordering, pkgId, pkgIdIn, release, releaseIn, releaseNe, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, sha256, version, versionIn, versionNe, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * A ViewSet for Package.  Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/packages/  Also specify queryset and serializer for Package.
         * @summary Inspect a package
         * @param {string} rpmPackageHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(rpmPackageHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<RpmPackageResponse> {
            return localVarFp.read(rpmPackageHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentPackagesApi - object-oriented interface
 * @export
 * @class ContentPackagesApi
 * @extends {BaseAPI}
 */
export class ContentPackagesApi extends BaseAPI {
    /**
     * Trigger an asynchronous task to create content,optionally create new repository version.
     * @summary Create a package
     * @param {string} relativePath Path where the artifact is located relative to distributions base_path
     * @param {string} [artifact] Artifact file representing the physical content
     * @param {any} [file] An uploaded file that may be turned into the artifact of the content unit.
     * @param {string} [repository] A URI of a repository the new content unit should be associated with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentPackagesApi
     */
    public create(relativePath: string, artifact?: string, file?: any, repository?: string, options?: any) {
        return ContentPackagesApiFp(this.configuration).create(relativePath, artifact, file, repository, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A ViewSet for Package.  Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/packages/  Also specify queryset and serializer for Package.
     * @summary List packages
     * @param {string} [arch] Filter results where arch matches value
     * @param {Array<string>} [archIn] Filter results where arch is in a comma-separated list of values
     * @param {string} [archNe] Filter results where arch not equal to value
     * @param {'md5' | 'sha1' | 'sha1' | 'sha224' | 'sha256' | 'sha384' | 'sha512' | 'unknown'} [checksumType] Filter results where checksum_type matches value
     * @param {Array<string>} [checksumTypeIn] Filter results where checksum_type is in a comma-separated list of values
     * @param {string} [checksumTypeNe] Filter results where checksum_type not equal to value
     * @param {string} [epoch] Filter results where epoch matches value
     * @param {Array<string>} [epochIn] Filter results where epoch is in a comma-separated list of values
     * @param {string} [epochNe] Filter results where epoch not equal to value
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] Filter results where name matches value
     * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
     * @param {string} [nameNe] Filter results where name not equal to value
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [pkgId] Filter results where pkgId matches value
     * @param {Array<string>} [pkgIdIn] Filter results where pkgId is in a comma-separated list of values
     * @param {string} [release] Filter results where release matches value
     * @param {Array<string>} [releaseIn] Filter results where release is in a comma-separated list of values
     * @param {string} [releaseNe] Filter results where release not equal to value
     * @param {string} [repositoryVersion] Repository Version referenced by HREF
     * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
     * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
     * @param {string} [sha256] 
     * @param {string} [version] Filter results where version matches value
     * @param {Array<string>} [versionIn] Filter results where version is in a comma-separated list of values
     * @param {string} [versionNe] Filter results where version not equal to value
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentPackagesApi
     */
    public list(arch?: string, archIn?: Array<string>, archNe?: string, checksumType?: 'md5' | 'sha1' | 'sha1' | 'sha224' | 'sha256' | 'sha384' | 'sha512' | 'unknown', checksumTypeIn?: Array<string>, checksumTypeNe?: string, epoch?: string, epochIn?: Array<string>, epochNe?: string, limit?: number, name?: string, nameIn?: Array<string>, nameNe?: string, offset?: number, ordering?: string, pkgId?: string, pkgIdIn?: Array<string>, release?: string, releaseIn?: Array<string>, releaseNe?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, sha256?: string, version?: string, versionIn?: Array<string>, versionNe?: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentPackagesApiFp(this.configuration).list(arch, archIn, archNe, checksumType, checksumTypeIn, checksumTypeNe, epoch, epochIn, epochNe, limit, name, nameIn, nameNe, offset, ordering, pkgId, pkgIdIn, release, releaseIn, releaseNe, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, sha256, version, versionIn, versionNe, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A ViewSet for Package.  Define endpoint name which will appear in the API endpoint for this content type. For example::     http://pulp.example.com/pulp/api/v3/content/rpm/packages/  Also specify queryset and serializer for Package.
     * @summary Inspect a package
     * @param {string} rpmPackageHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentPackagesApi
     */
    public read(rpmPackageHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentPackagesApiFp(this.configuration).read(rpmPackageHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentRepoMetadataFilesApi - axios parameter creator
 * @export
 */
export const ContentRepoMetadataFilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * RepoMetadataFile Viewset.
         * @summary List repo metadata files
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/content/rpm/repo_metadata_files/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (repositoryVersion !== undefined) {
                localVarQueryParameter['repository_version'] = repositoryVersion;
            }

            if (repositoryVersionAdded !== undefined) {
                localVarQueryParameter['repository_version_added'] = repositoryVersionAdded;
            }

            if (repositoryVersionRemoved !== undefined) {
                localVarQueryParameter['repository_version_removed'] = repositoryVersionRemoved;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * RepoMetadataFile Viewset.
         * @summary Inspect a repo metadata file
         * @param {string} rpmRepoMetadataFileHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (rpmRepoMetadataFileHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmRepoMetadataFileHref' is not null or undefined
            assertParamExists('read', 'rpmRepoMetadataFileHref', rpmRepoMetadataFileHref)
            const localVarPath = `{rpm_repo_metadata_file_href}`
                .replace(`{${"rpm_repo_metadata_file_href"}}`, String(rpmRepoMetadataFileHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentRepoMetadataFilesApi - functional programming interface
 * @export
 */
export const ContentRepoMetadataFilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentRepoMetadataFilesApiAxiosParamCreator(configuration)
    return {
        /**
         * RepoMetadataFile Viewset.
         * @summary List repo metadata files
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedrpmRepoMetadataFileResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * RepoMetadataFile Viewset.
         * @summary Inspect a repo metadata file
         * @param {string} rpmRepoMetadataFileHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(rpmRepoMetadataFileHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RpmRepoMetadataFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(rpmRepoMetadataFileHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContentRepoMetadataFilesApi - factory interface
 * @export
 */
export const ContentRepoMetadataFilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentRepoMetadataFilesApiFp(configuration)
    return {
        /**
         * RepoMetadataFile Viewset.
         * @summary List repo metadata files
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedrpmRepoMetadataFileResponseList> {
            return localVarFp.list(limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * RepoMetadataFile Viewset.
         * @summary Inspect a repo metadata file
         * @param {string} rpmRepoMetadataFileHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(rpmRepoMetadataFileHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<RpmRepoMetadataFileResponse> {
            return localVarFp.read(rpmRepoMetadataFileHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentRepoMetadataFilesApi - object-oriented interface
 * @export
 * @class ContentRepoMetadataFilesApi
 * @extends {BaseAPI}
 */
export class ContentRepoMetadataFilesApi extends BaseAPI {
    /**
     * RepoMetadataFile Viewset.
     * @summary List repo metadata files
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [repositoryVersion] Repository Version referenced by HREF
     * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
     * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentRepoMetadataFilesApi
     */
    public list(limit?: number, offset?: number, ordering?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentRepoMetadataFilesApiFp(this.configuration).list(limit, offset, ordering, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * RepoMetadataFile Viewset.
     * @summary Inspect a repo metadata file
     * @param {string} rpmRepoMetadataFileHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentRepoMetadataFilesApi
     */
    public read(rpmRepoMetadataFileHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentRepoMetadataFilesApiFp(this.configuration).read(rpmRepoMetadataFileHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DistributionsRpmApi - axios parameter creator
 * @export
 */
export const DistributionsRpmApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a rpm distribution
         * @param {string} rpmRpmDistributionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (rpmRpmDistributionHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmRpmDistributionHref' is not null or undefined
            assertParamExists('_delete', 'rpmRpmDistributionHref', rpmRpmDistributionHref)
            const localVarPath = `{rpm_rpm_distribution_href}`
                .replace(`{${"rpm_rpm_distribution_href"}}`, String(rpmRpmDistributionHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous create task
         * @summary Create a rpm distribution
         * @param {RpmRpmDistribution} rpmRpmDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (rpmRpmDistribution: RpmRpmDistribution, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmRpmDistribution' is not null or undefined
            assertParamExists('create', 'rpmRpmDistribution', rpmRpmDistribution)
            const localVarPath = `/pulp/api/v3/distributions/rpm/rpm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rpmRpmDistribution, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for RPM Distributions.
         * @summary List rpm distributions
         * @param {string} [basePath] 
         * @param {string} [basePathContains] Filter results where base_path contains value
         * @param {string} [basePathIcontains] Filter results where base_path contains value
         * @param {Array<string>} [basePathIn] Filter results where base_path is in a comma-separated list of values
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] Filter labels by search string
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (basePath?: string, basePathContains?: string, basePathIcontains?: string, basePathIn?: Array<string>, limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/distributions/rpm/rpm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (basePath !== undefined) {
                localVarQueryParameter['base_path'] = basePath;
            }

            if (basePathContains !== undefined) {
                localVarQueryParameter['base_path__contains'] = basePathContains;
            }

            if (basePathIcontains !== undefined) {
                localVarQueryParameter['base_path__icontains'] = basePathIcontains;
            }

            if (basePathIn) {
                localVarQueryParameter['base_path__in'] = basePathIn.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIn) {
                localVarQueryParameter['name__in'] = nameIn.join(COLLECTION_FORMATS.csv);
            }

            if (nameStartswith !== undefined) {
                localVarQueryParameter['name__startswith'] = nameStartswith;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (pulpLabelSelect !== undefined) {
                localVarQueryParameter['pulp_label_select'] = pulpLabelSelect;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a rpm distribution
         * @param {string} rpmRpmDistributionHref 
         * @param {PatchedrpmRpmDistribution} patchedrpmRpmDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate: async (rpmRpmDistributionHref: string, patchedrpmRpmDistribution: PatchedrpmRpmDistribution, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmRpmDistributionHref' is not null or undefined
            assertParamExists('partialUpdate', 'rpmRpmDistributionHref', rpmRpmDistributionHref)
            // verify required parameter 'patchedrpmRpmDistribution' is not null or undefined
            assertParamExists('partialUpdate', 'patchedrpmRpmDistribution', patchedrpmRpmDistribution)
            const localVarPath = `{rpm_rpm_distribution_href}`
                .replace(`{${"rpm_rpm_distribution_href"}}`, String(rpmRpmDistributionHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedrpmRpmDistribution, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for RPM Distributions.
         * @summary Inspect a rpm distribution
         * @param {string} rpmRpmDistributionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (rpmRpmDistributionHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmRpmDistributionHref' is not null or undefined
            assertParamExists('read', 'rpmRpmDistributionHref', rpmRpmDistributionHref)
            const localVarPath = `{rpm_rpm_distribution_href}`
                .replace(`{${"rpm_rpm_distribution_href"}}`, String(rpmRpmDistributionHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a rpm distribution
         * @param {string} rpmRpmDistributionHref 
         * @param {RpmRpmDistribution} rpmRpmDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (rpmRpmDistributionHref: string, rpmRpmDistribution: RpmRpmDistribution, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmRpmDistributionHref' is not null or undefined
            assertParamExists('update', 'rpmRpmDistributionHref', rpmRpmDistributionHref)
            // verify required parameter 'rpmRpmDistribution' is not null or undefined
            assertParamExists('update', 'rpmRpmDistribution', rpmRpmDistribution)
            const localVarPath = `{rpm_rpm_distribution_href}`
                .replace(`{${"rpm_rpm_distribution_href"}}`, String(rpmRpmDistributionHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rpmRpmDistribution, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DistributionsRpmApi - functional programming interface
 * @export
 */
export const DistributionsRpmApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DistributionsRpmApiAxiosParamCreator(configuration)
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a rpm distribution
         * @param {string} rpmRpmDistributionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(rpmRpmDistributionHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(rpmRpmDistributionHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous create task
         * @summary Create a rpm distribution
         * @param {RpmRpmDistribution} rpmRpmDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(rpmRpmDistribution: RpmRpmDistribution, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(rpmRpmDistribution, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for RPM Distributions.
         * @summary List rpm distributions
         * @param {string} [basePath] 
         * @param {string} [basePathContains] Filter results where base_path contains value
         * @param {string} [basePathIcontains] Filter results where base_path contains value
         * @param {Array<string>} [basePathIn] Filter results where base_path is in a comma-separated list of values
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] Filter labels by search string
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(basePath?: string, basePathContains?: string, basePathIcontains?: string, basePathIn?: Array<string>, limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedrpmRpmDistributionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(basePath, basePathContains, basePathIcontains, basePathIn, limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a rpm distribution
         * @param {string} rpmRpmDistributionHref 
         * @param {PatchedrpmRpmDistribution} patchedrpmRpmDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdate(rpmRpmDistributionHref: string, patchedrpmRpmDistribution: PatchedrpmRpmDistribution, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdate(rpmRpmDistributionHref, patchedrpmRpmDistribution, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for RPM Distributions.
         * @summary Inspect a rpm distribution
         * @param {string} rpmRpmDistributionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(rpmRpmDistributionHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RpmRpmDistributionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(rpmRpmDistributionHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a rpm distribution
         * @param {string} rpmRpmDistributionHref 
         * @param {RpmRpmDistribution} rpmRpmDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(rpmRpmDistributionHref: string, rpmRpmDistribution: RpmRpmDistribution, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(rpmRpmDistributionHref, rpmRpmDistribution, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DistributionsRpmApi - factory interface
 * @export
 */
export const DistributionsRpmApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DistributionsRpmApiFp(configuration)
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a rpm distribution
         * @param {string} rpmRpmDistributionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(rpmRpmDistributionHref: string, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp._delete(rpmRpmDistributionHref, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous create task
         * @summary Create a rpm distribution
         * @param {RpmRpmDistribution} rpmRpmDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(rpmRpmDistribution: RpmRpmDistribution, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.create(rpmRpmDistribution, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for RPM Distributions.
         * @summary List rpm distributions
         * @param {string} [basePath] 
         * @param {string} [basePathContains] Filter results where base_path contains value
         * @param {string} [basePathIcontains] Filter results where base_path contains value
         * @param {Array<string>} [basePathIn] Filter results where base_path is in a comma-separated list of values
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] Filter labels by search string
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(basePath?: string, basePathContains?: string, basePathIcontains?: string, basePathIn?: Array<string>, limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedrpmRpmDistributionResponseList> {
            return localVarFp.list(basePath, basePathContains, basePathIcontains, basePathIn, limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a rpm distribution
         * @param {string} rpmRpmDistributionHref 
         * @param {PatchedrpmRpmDistribution} patchedrpmRpmDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate(rpmRpmDistributionHref: string, patchedrpmRpmDistribution: PatchedrpmRpmDistribution, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.partialUpdate(rpmRpmDistributionHref, patchedrpmRpmDistribution, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for RPM Distributions.
         * @summary Inspect a rpm distribution
         * @param {string} rpmRpmDistributionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(rpmRpmDistributionHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<RpmRpmDistributionResponse> {
            return localVarFp.read(rpmRpmDistributionHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a rpm distribution
         * @param {string} rpmRpmDistributionHref 
         * @param {RpmRpmDistribution} rpmRpmDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(rpmRpmDistributionHref: string, rpmRpmDistribution: RpmRpmDistribution, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.update(rpmRpmDistributionHref, rpmRpmDistribution, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DistributionsRpmApi - object-oriented interface
 * @export
 * @class DistributionsRpmApi
 * @extends {BaseAPI}
 */
export class DistributionsRpmApi extends BaseAPI {
    /**
     * Trigger an asynchronous delete task
     * @summary Delete a rpm distribution
     * @param {string} rpmRpmDistributionHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionsRpmApi
     */
    public _delete(rpmRpmDistributionHref: string, options?: any) {
        return DistributionsRpmApiFp(this.configuration)._delete(rpmRpmDistributionHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous create task
     * @summary Create a rpm distribution
     * @param {RpmRpmDistribution} rpmRpmDistribution 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionsRpmApi
     */
    public create(rpmRpmDistribution: RpmRpmDistribution, options?: any) {
        return DistributionsRpmApiFp(this.configuration).create(rpmRpmDistribution, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for RPM Distributions.
     * @summary List rpm distributions
     * @param {string} [basePath] 
     * @param {string} [basePathContains] Filter results where base_path contains value
     * @param {string} [basePathIcontains] Filter results where base_path contains value
     * @param {Array<string>} [basePathIn] Filter results where base_path is in a comma-separated list of values
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] 
     * @param {string} [nameContains] Filter results where name contains value
     * @param {string} [nameIcontains] Filter results where name contains value
     * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
     * @param {string} [nameStartswith] Filter results where name starts with value
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [pulpLabelSelect] Filter labels by search string
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionsRpmApi
     */
    public list(basePath?: string, basePathContains?: string, basePathIcontains?: string, basePathIn?: Array<string>, limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options?: any) {
        return DistributionsRpmApiFp(this.configuration).list(basePath, basePathContains, basePathIcontains, basePathIn, limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous partial update task
     * @summary Update a rpm distribution
     * @param {string} rpmRpmDistributionHref 
     * @param {PatchedrpmRpmDistribution} patchedrpmRpmDistribution 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionsRpmApi
     */
    public partialUpdate(rpmRpmDistributionHref: string, patchedrpmRpmDistribution: PatchedrpmRpmDistribution, options?: any) {
        return DistributionsRpmApiFp(this.configuration).partialUpdate(rpmRpmDistributionHref, patchedrpmRpmDistribution, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for RPM Distributions.
     * @summary Inspect a rpm distribution
     * @param {string} rpmRpmDistributionHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionsRpmApi
     */
    public read(rpmRpmDistributionHref: string, fields?: string, excludeFields?: string, options?: any) {
        return DistributionsRpmApiFp(this.configuration).read(rpmRpmDistributionHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous update task
     * @summary Update a rpm distribution
     * @param {string} rpmRpmDistributionHref 
     * @param {RpmRpmDistribution} rpmRpmDistribution 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionsRpmApi
     */
    public update(rpmRpmDistributionHref: string, rpmRpmDistribution: RpmRpmDistribution, options?: any) {
        return DistributionsRpmApiFp(this.configuration).update(rpmRpmDistributionHref, rpmRpmDistribution, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PublicationsRpmApi - axios parameter creator
 * @export
 */
export const PublicationsRpmApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ViewSet for Rpm Publications.
         * @summary Delete a rpm publication
         * @param {string} rpmRpmPublicationHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (rpmRpmPublicationHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmRpmPublicationHref' is not null or undefined
            assertParamExists('_delete', 'rpmRpmPublicationHref', rpmRpmPublicationHref)
            const localVarPath = `{rpm_rpm_publication_href}`
                .replace(`{${"rpm_rpm_publication_href"}}`, String(rpmRpmPublicationHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous task to create a new RPM content publication.
         * @summary Create a rpm publication
         * @param {RpmRpmPublication} rpmRpmPublication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (rpmRpmPublication: RpmRpmPublication, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmRpmPublication' is not null or undefined
            assertParamExists('create', 'rpmRpmPublication', rpmRpmPublication)
            const localVarPath = `/pulp/api/v3/publications/rpm/rpm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rpmRpmPublication, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for Rpm Publications.
         * @summary List rpm publications
         * @param {string} [content] Content Unit referenced by HREF
         * @param {string} [contentIn] Content Unit referenced by HREF
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpCreated] ISO 8601 formatted dates are supported
         * @param {string} [pulpCreatedGt] Filter results where pulp_created is greater than value
         * @param {string} [pulpCreatedGte] Filter results where pulp_created is greater than or equal to value
         * @param {string} [pulpCreatedLt] Filter results where pulp_created is less than value
         * @param {string} [pulpCreatedLte] Filter results where pulp_created is less than or equal to value
         * @param {Array<string>} [pulpCreatedRange] Filter results where pulp_created is between two comma separated values
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (content?: string, contentIn?: string, limit?: number, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: Array<string>, repositoryVersion?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/publications/rpm/rpm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (content !== undefined) {
                localVarQueryParameter['content'] = content;
            }

            if (contentIn !== undefined) {
                localVarQueryParameter['content__in'] = contentIn;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (pulpCreated !== undefined) {
                localVarQueryParameter['pulp_created'] = (pulpCreated as any instanceof Date) ?
                    (pulpCreated as any).toISOString() :
                    pulpCreated;
            }

            if (pulpCreatedGt !== undefined) {
                localVarQueryParameter['pulp_created__gt'] = (pulpCreatedGt as any instanceof Date) ?
                    (pulpCreatedGt as any).toISOString() :
                    pulpCreatedGt;
            }

            if (pulpCreatedGte !== undefined) {
                localVarQueryParameter['pulp_created__gte'] = (pulpCreatedGte as any instanceof Date) ?
                    (pulpCreatedGte as any).toISOString() :
                    pulpCreatedGte;
            }

            if (pulpCreatedLt !== undefined) {
                localVarQueryParameter['pulp_created__lt'] = (pulpCreatedLt as any instanceof Date) ?
                    (pulpCreatedLt as any).toISOString() :
                    pulpCreatedLt;
            }

            if (pulpCreatedLte !== undefined) {
                localVarQueryParameter['pulp_created__lte'] = (pulpCreatedLte as any instanceof Date) ?
                    (pulpCreatedLte as any).toISOString() :
                    pulpCreatedLte;
            }

            if (pulpCreatedRange) {
                localVarQueryParameter['pulp_created__range'] = pulpCreatedRange.join(COLLECTION_FORMATS.csv);
            }

            if (repositoryVersion !== undefined) {
                localVarQueryParameter['repository_version'] = repositoryVersion;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ViewSet for Rpm Publications.
         * @summary Inspect a rpm publication
         * @param {string} rpmRpmPublicationHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (rpmRpmPublicationHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmRpmPublicationHref' is not null or undefined
            assertParamExists('read', 'rpmRpmPublicationHref', rpmRpmPublicationHref)
            const localVarPath = `{rpm_rpm_publication_href}`
                .replace(`{${"rpm_rpm_publication_href"}}`, String(rpmRpmPublicationHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicationsRpmApi - functional programming interface
 * @export
 */
export const PublicationsRpmApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicationsRpmApiAxiosParamCreator(configuration)
    return {
        /**
         * ViewSet for Rpm Publications.
         * @summary Delete a rpm publication
         * @param {string} rpmRpmPublicationHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(rpmRpmPublicationHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(rpmRpmPublicationHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous task to create a new RPM content publication.
         * @summary Create a rpm publication
         * @param {RpmRpmPublication} rpmRpmPublication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(rpmRpmPublication: RpmRpmPublication, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(rpmRpmPublication, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for Rpm Publications.
         * @summary List rpm publications
         * @param {string} [content] Content Unit referenced by HREF
         * @param {string} [contentIn] Content Unit referenced by HREF
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpCreated] ISO 8601 formatted dates are supported
         * @param {string} [pulpCreatedGt] Filter results where pulp_created is greater than value
         * @param {string} [pulpCreatedGte] Filter results where pulp_created is greater than or equal to value
         * @param {string} [pulpCreatedLt] Filter results where pulp_created is less than value
         * @param {string} [pulpCreatedLte] Filter results where pulp_created is less than or equal to value
         * @param {Array<string>} [pulpCreatedRange] Filter results where pulp_created is between two comma separated values
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(content?: string, contentIn?: string, limit?: number, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: Array<string>, repositoryVersion?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedrpmRpmPublicationResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(content, contentIn, limit, offset, ordering, pulpCreated, pulpCreatedGt, pulpCreatedGte, pulpCreatedLt, pulpCreatedLte, pulpCreatedRange, repositoryVersion, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ViewSet for Rpm Publications.
         * @summary Inspect a rpm publication
         * @param {string} rpmRpmPublicationHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(rpmRpmPublicationHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RpmRpmPublicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(rpmRpmPublicationHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PublicationsRpmApi - factory interface
 * @export
 */
export const PublicationsRpmApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicationsRpmApiFp(configuration)
    return {
        /**
         * ViewSet for Rpm Publications.
         * @summary Delete a rpm publication
         * @param {string} rpmRpmPublicationHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(rpmRpmPublicationHref: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(rpmRpmPublicationHref, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous task to create a new RPM content publication.
         * @summary Create a rpm publication
         * @param {RpmRpmPublication} rpmRpmPublication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(rpmRpmPublication: RpmRpmPublication, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.create(rpmRpmPublication, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for Rpm Publications.
         * @summary List rpm publications
         * @param {string} [content] Content Unit referenced by HREF
         * @param {string} [contentIn] Content Unit referenced by HREF
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpCreated] ISO 8601 formatted dates are supported
         * @param {string} [pulpCreatedGt] Filter results where pulp_created is greater than value
         * @param {string} [pulpCreatedGte] Filter results where pulp_created is greater than or equal to value
         * @param {string} [pulpCreatedLt] Filter results where pulp_created is less than value
         * @param {string} [pulpCreatedLte] Filter results where pulp_created is less than or equal to value
         * @param {Array<string>} [pulpCreatedRange] Filter results where pulp_created is between two comma separated values
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(content?: string, contentIn?: string, limit?: number, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: Array<string>, repositoryVersion?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedrpmRpmPublicationResponseList> {
            return localVarFp.list(content, contentIn, limit, offset, ordering, pulpCreated, pulpCreatedGt, pulpCreatedGte, pulpCreatedLt, pulpCreatedLte, pulpCreatedRange, repositoryVersion, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for Rpm Publications.
         * @summary Inspect a rpm publication
         * @param {string} rpmRpmPublicationHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(rpmRpmPublicationHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<RpmRpmPublicationResponse> {
            return localVarFp.read(rpmRpmPublicationHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublicationsRpmApi - object-oriented interface
 * @export
 * @class PublicationsRpmApi
 * @extends {BaseAPI}
 */
export class PublicationsRpmApi extends BaseAPI {
    /**
     * ViewSet for Rpm Publications.
     * @summary Delete a rpm publication
     * @param {string} rpmRpmPublicationHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationsRpmApi
     */
    public _delete(rpmRpmPublicationHref: string, options?: any) {
        return PublicationsRpmApiFp(this.configuration)._delete(rpmRpmPublicationHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous task to create a new RPM content publication.
     * @summary Create a rpm publication
     * @param {RpmRpmPublication} rpmRpmPublication 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationsRpmApi
     */
    public create(rpmRpmPublication: RpmRpmPublication, options?: any) {
        return PublicationsRpmApiFp(this.configuration).create(rpmRpmPublication, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for Rpm Publications.
     * @summary List rpm publications
     * @param {string} [content] Content Unit referenced by HREF
     * @param {string} [contentIn] Content Unit referenced by HREF
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [pulpCreated] ISO 8601 formatted dates are supported
     * @param {string} [pulpCreatedGt] Filter results where pulp_created is greater than value
     * @param {string} [pulpCreatedGte] Filter results where pulp_created is greater than or equal to value
     * @param {string} [pulpCreatedLt] Filter results where pulp_created is less than value
     * @param {string} [pulpCreatedLte] Filter results where pulp_created is less than or equal to value
     * @param {Array<string>} [pulpCreatedRange] Filter results where pulp_created is between two comma separated values
     * @param {string} [repositoryVersion] Repository Version referenced by HREF
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationsRpmApi
     */
    public list(content?: string, contentIn?: string, limit?: number, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: Array<string>, repositoryVersion?: string, fields?: string, excludeFields?: string, options?: any) {
        return PublicationsRpmApiFp(this.configuration).list(content, contentIn, limit, offset, ordering, pulpCreated, pulpCreatedGt, pulpCreatedGte, pulpCreatedLt, pulpCreatedLte, pulpCreatedRange, repositoryVersion, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ViewSet for Rpm Publications.
     * @summary Inspect a rpm publication
     * @param {string} rpmRpmPublicationHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationsRpmApi
     */
    public read(rpmRpmPublicationHref: string, fields?: string, excludeFields?: string, options?: any) {
        return PublicationsRpmApiFp(this.configuration).read(rpmRpmPublicationHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RemotesRpmApi - axios parameter creator
 * @export
 */
export const RemotesRpmApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a rpm remote
         * @param {string} rpmRpmRemoteHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (rpmRpmRemoteHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmRpmRemoteHref' is not null or undefined
            assertParamExists('_delete', 'rpmRpmRemoteHref', rpmRpmRemoteHref)
            const localVarPath = `{rpm_rpm_remote_href}`
                .replace(`{${"rpm_rpm_remote_href"}}`, String(rpmRpmRemoteHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A ViewSet for RpmRemote.
         * @summary Create a rpm remote
         * @param {RpmRpmRemote} rpmRpmRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (rpmRpmRemote: RpmRpmRemote, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmRpmRemote' is not null or undefined
            assertParamExists('create', 'rpmRpmRemote', rpmRpmRemote)
            const localVarPath = `/pulp/api/v3/remotes/rpm/rpm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rpmRpmRemote, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A ViewSet for RpmRemote.
         * @summary List rpm remotes
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] Filter labels by search string
         * @param {string} [pulpLastUpdated] ISO 8601 formatted dates are supported
         * @param {string} [pulpLastUpdatedGt] Filter results where pulp_last_updated is greater than value
         * @param {string} [pulpLastUpdatedGte] Filter results where pulp_last_updated is greater than or equal to value
         * @param {string} [pulpLastUpdatedLt] Filter results where pulp_last_updated is less than value
         * @param {string} [pulpLastUpdatedLte] Filter results where pulp_last_updated is less than or equal to value
         * @param {Array<string>} [pulpLastUpdatedRange] Filter results where pulp_last_updated is between two comma separated values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, pulpLastUpdated?: string, pulpLastUpdatedGt?: string, pulpLastUpdatedGte?: string, pulpLastUpdatedLt?: string, pulpLastUpdatedLte?: string, pulpLastUpdatedRange?: Array<string>, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/remotes/rpm/rpm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIn) {
                localVarQueryParameter['name__in'] = nameIn.join(COLLECTION_FORMATS.csv);
            }

            if (nameStartswith !== undefined) {
                localVarQueryParameter['name__startswith'] = nameStartswith;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (pulpLabelSelect !== undefined) {
                localVarQueryParameter['pulp_label_select'] = pulpLabelSelect;
            }

            if (pulpLastUpdated !== undefined) {
                localVarQueryParameter['pulp_last_updated'] = (pulpLastUpdated as any instanceof Date) ?
                    (pulpLastUpdated as any).toISOString() :
                    pulpLastUpdated;
            }

            if (pulpLastUpdatedGt !== undefined) {
                localVarQueryParameter['pulp_last_updated__gt'] = (pulpLastUpdatedGt as any instanceof Date) ?
                    (pulpLastUpdatedGt as any).toISOString() :
                    pulpLastUpdatedGt;
            }

            if (pulpLastUpdatedGte !== undefined) {
                localVarQueryParameter['pulp_last_updated__gte'] = (pulpLastUpdatedGte as any instanceof Date) ?
                    (pulpLastUpdatedGte as any).toISOString() :
                    pulpLastUpdatedGte;
            }

            if (pulpLastUpdatedLt !== undefined) {
                localVarQueryParameter['pulp_last_updated__lt'] = (pulpLastUpdatedLt as any instanceof Date) ?
                    (pulpLastUpdatedLt as any).toISOString() :
                    pulpLastUpdatedLt;
            }

            if (pulpLastUpdatedLte !== undefined) {
                localVarQueryParameter['pulp_last_updated__lte'] = (pulpLastUpdatedLte as any instanceof Date) ?
                    (pulpLastUpdatedLte as any).toISOString() :
                    pulpLastUpdatedLte;
            }

            if (pulpLastUpdatedRange) {
                localVarQueryParameter['pulp_last_updated__range'] = pulpLastUpdatedRange.join(COLLECTION_FORMATS.csv);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a rpm remote
         * @param {string} rpmRpmRemoteHref 
         * @param {PatchedrpmRpmRemote} patchedrpmRpmRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate: async (rpmRpmRemoteHref: string, patchedrpmRpmRemote: PatchedrpmRpmRemote, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmRpmRemoteHref' is not null or undefined
            assertParamExists('partialUpdate', 'rpmRpmRemoteHref', rpmRpmRemoteHref)
            // verify required parameter 'patchedrpmRpmRemote' is not null or undefined
            assertParamExists('partialUpdate', 'patchedrpmRpmRemote', patchedrpmRpmRemote)
            const localVarPath = `{rpm_rpm_remote_href}`
                .replace(`{${"rpm_rpm_remote_href"}}`, String(rpmRpmRemoteHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedrpmRpmRemote, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A ViewSet for RpmRemote.
         * @summary Inspect a rpm remote
         * @param {string} rpmRpmRemoteHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (rpmRpmRemoteHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmRpmRemoteHref' is not null or undefined
            assertParamExists('read', 'rpmRpmRemoteHref', rpmRpmRemoteHref)
            const localVarPath = `{rpm_rpm_remote_href}`
                .replace(`{${"rpm_rpm_remote_href"}}`, String(rpmRpmRemoteHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a rpm remote
         * @param {string} rpmRpmRemoteHref 
         * @param {RpmRpmRemote} rpmRpmRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (rpmRpmRemoteHref: string, rpmRpmRemote: RpmRpmRemote, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmRpmRemoteHref' is not null or undefined
            assertParamExists('update', 'rpmRpmRemoteHref', rpmRpmRemoteHref)
            // verify required parameter 'rpmRpmRemote' is not null or undefined
            assertParamExists('update', 'rpmRpmRemote', rpmRpmRemote)
            const localVarPath = `{rpm_rpm_remote_href}`
                .replace(`{${"rpm_rpm_remote_href"}}`, String(rpmRpmRemoteHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rpmRpmRemote, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RemotesRpmApi - functional programming interface
 * @export
 */
export const RemotesRpmApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RemotesRpmApiAxiosParamCreator(configuration)
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a rpm remote
         * @param {string} rpmRpmRemoteHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(rpmRpmRemoteHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(rpmRpmRemoteHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A ViewSet for RpmRemote.
         * @summary Create a rpm remote
         * @param {RpmRpmRemote} rpmRpmRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(rpmRpmRemote: RpmRpmRemote, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RpmRpmRemoteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(rpmRpmRemote, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A ViewSet for RpmRemote.
         * @summary List rpm remotes
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] Filter labels by search string
         * @param {string} [pulpLastUpdated] ISO 8601 formatted dates are supported
         * @param {string} [pulpLastUpdatedGt] Filter results where pulp_last_updated is greater than value
         * @param {string} [pulpLastUpdatedGte] Filter results where pulp_last_updated is greater than or equal to value
         * @param {string} [pulpLastUpdatedLt] Filter results where pulp_last_updated is less than value
         * @param {string} [pulpLastUpdatedLte] Filter results where pulp_last_updated is less than or equal to value
         * @param {Array<string>} [pulpLastUpdatedRange] Filter results where pulp_last_updated is between two comma separated values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, pulpLastUpdated?: string, pulpLastUpdatedGt?: string, pulpLastUpdatedGte?: string, pulpLastUpdatedLt?: string, pulpLastUpdatedLte?: string, pulpLastUpdatedRange?: Array<string>, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedrpmRpmRemoteResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, pulpLastUpdated, pulpLastUpdatedGt, pulpLastUpdatedGte, pulpLastUpdatedLt, pulpLastUpdatedLte, pulpLastUpdatedRange, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a rpm remote
         * @param {string} rpmRpmRemoteHref 
         * @param {PatchedrpmRpmRemote} patchedrpmRpmRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdate(rpmRpmRemoteHref: string, patchedrpmRpmRemote: PatchedrpmRpmRemote, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdate(rpmRpmRemoteHref, patchedrpmRpmRemote, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A ViewSet for RpmRemote.
         * @summary Inspect a rpm remote
         * @param {string} rpmRpmRemoteHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(rpmRpmRemoteHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RpmRpmRemoteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(rpmRpmRemoteHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a rpm remote
         * @param {string} rpmRpmRemoteHref 
         * @param {RpmRpmRemote} rpmRpmRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(rpmRpmRemoteHref: string, rpmRpmRemote: RpmRpmRemote, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(rpmRpmRemoteHref, rpmRpmRemote, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RemotesRpmApi - factory interface
 * @export
 */
export const RemotesRpmApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RemotesRpmApiFp(configuration)
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a rpm remote
         * @param {string} rpmRpmRemoteHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(rpmRpmRemoteHref: string, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp._delete(rpmRpmRemoteHref, options).then((request) => request(axios, basePath));
        },
        /**
         * A ViewSet for RpmRemote.
         * @summary Create a rpm remote
         * @param {RpmRpmRemote} rpmRpmRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(rpmRpmRemote: RpmRpmRemote, options?: any): AxiosPromise<RpmRpmRemoteResponse> {
            return localVarFp.create(rpmRpmRemote, options).then((request) => request(axios, basePath));
        },
        /**
         * A ViewSet for RpmRemote.
         * @summary List rpm remotes
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] Filter labels by search string
         * @param {string} [pulpLastUpdated] ISO 8601 formatted dates are supported
         * @param {string} [pulpLastUpdatedGt] Filter results where pulp_last_updated is greater than value
         * @param {string} [pulpLastUpdatedGte] Filter results where pulp_last_updated is greater than or equal to value
         * @param {string} [pulpLastUpdatedLt] Filter results where pulp_last_updated is less than value
         * @param {string} [pulpLastUpdatedLte] Filter results where pulp_last_updated is less than or equal to value
         * @param {Array<string>} [pulpLastUpdatedRange] Filter results where pulp_last_updated is between two comma separated values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, pulpLastUpdated?: string, pulpLastUpdatedGt?: string, pulpLastUpdatedGte?: string, pulpLastUpdatedLt?: string, pulpLastUpdatedLte?: string, pulpLastUpdatedRange?: Array<string>, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedrpmRpmRemoteResponseList> {
            return localVarFp.list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, pulpLastUpdated, pulpLastUpdatedGt, pulpLastUpdatedGte, pulpLastUpdatedLt, pulpLastUpdatedLte, pulpLastUpdatedRange, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a rpm remote
         * @param {string} rpmRpmRemoteHref 
         * @param {PatchedrpmRpmRemote} patchedrpmRpmRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate(rpmRpmRemoteHref: string, patchedrpmRpmRemote: PatchedrpmRpmRemote, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.partialUpdate(rpmRpmRemoteHref, patchedrpmRpmRemote, options).then((request) => request(axios, basePath));
        },
        /**
         * A ViewSet for RpmRemote.
         * @summary Inspect a rpm remote
         * @param {string} rpmRpmRemoteHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(rpmRpmRemoteHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<RpmRpmRemoteResponse> {
            return localVarFp.read(rpmRpmRemoteHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a rpm remote
         * @param {string} rpmRpmRemoteHref 
         * @param {RpmRpmRemote} rpmRpmRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(rpmRpmRemoteHref: string, rpmRpmRemote: RpmRpmRemote, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.update(rpmRpmRemoteHref, rpmRpmRemote, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RemotesRpmApi - object-oriented interface
 * @export
 * @class RemotesRpmApi
 * @extends {BaseAPI}
 */
export class RemotesRpmApi extends BaseAPI {
    /**
     * Trigger an asynchronous delete task
     * @summary Delete a rpm remote
     * @param {string} rpmRpmRemoteHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemotesRpmApi
     */
    public _delete(rpmRpmRemoteHref: string, options?: any) {
        return RemotesRpmApiFp(this.configuration)._delete(rpmRpmRemoteHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A ViewSet for RpmRemote.
     * @summary Create a rpm remote
     * @param {RpmRpmRemote} rpmRpmRemote 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemotesRpmApi
     */
    public create(rpmRpmRemote: RpmRpmRemote, options?: any) {
        return RemotesRpmApiFp(this.configuration).create(rpmRpmRemote, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A ViewSet for RpmRemote.
     * @summary List rpm remotes
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] 
     * @param {string} [nameContains] Filter results where name contains value
     * @param {string} [nameIcontains] Filter results where name contains value
     * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
     * @param {string} [nameStartswith] Filter results where name starts with value
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [pulpLabelSelect] Filter labels by search string
     * @param {string} [pulpLastUpdated] ISO 8601 formatted dates are supported
     * @param {string} [pulpLastUpdatedGt] Filter results where pulp_last_updated is greater than value
     * @param {string} [pulpLastUpdatedGte] Filter results where pulp_last_updated is greater than or equal to value
     * @param {string} [pulpLastUpdatedLt] Filter results where pulp_last_updated is less than value
     * @param {string} [pulpLastUpdatedLte] Filter results where pulp_last_updated is less than or equal to value
     * @param {Array<string>} [pulpLastUpdatedRange] Filter results where pulp_last_updated is between two comma separated values
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemotesRpmApi
     */
    public list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, pulpLastUpdated?: string, pulpLastUpdatedGt?: string, pulpLastUpdatedGte?: string, pulpLastUpdatedLt?: string, pulpLastUpdatedLte?: string, pulpLastUpdatedRange?: Array<string>, fields?: string, excludeFields?: string, options?: any) {
        return RemotesRpmApiFp(this.configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, pulpLastUpdated, pulpLastUpdatedGt, pulpLastUpdatedGte, pulpLastUpdatedLt, pulpLastUpdatedLte, pulpLastUpdatedRange, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous partial update task
     * @summary Update a rpm remote
     * @param {string} rpmRpmRemoteHref 
     * @param {PatchedrpmRpmRemote} patchedrpmRpmRemote 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemotesRpmApi
     */
    public partialUpdate(rpmRpmRemoteHref: string, patchedrpmRpmRemote: PatchedrpmRpmRemote, options?: any) {
        return RemotesRpmApiFp(this.configuration).partialUpdate(rpmRpmRemoteHref, patchedrpmRpmRemote, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A ViewSet for RpmRemote.
     * @summary Inspect a rpm remote
     * @param {string} rpmRpmRemoteHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemotesRpmApi
     */
    public read(rpmRpmRemoteHref: string, fields?: string, excludeFields?: string, options?: any) {
        return RemotesRpmApiFp(this.configuration).read(rpmRpmRemoteHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous update task
     * @summary Update a rpm remote
     * @param {string} rpmRpmRemoteHref 
     * @param {RpmRpmRemote} rpmRpmRemote 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemotesRpmApi
     */
    public update(rpmRpmRemoteHref: string, rpmRpmRemote: RpmRpmRemote, options?: any) {
        return RemotesRpmApiFp(this.configuration).update(rpmRpmRemoteHref, rpmRpmRemote, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RemotesUlnApi - axios parameter creator
 * @export
 */
export const RemotesUlnApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete an uln remote
         * @param {string} rpmUlnRemoteHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (rpmUlnRemoteHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmUlnRemoteHref' is not null or undefined
            assertParamExists('_delete', 'rpmUlnRemoteHref', rpmUlnRemoteHref)
            const localVarPath = `{rpm_uln_remote_href}`
                .replace(`{${"rpm_uln_remote_href"}}`, String(rpmUlnRemoteHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A ViewSet for UlnRemote.
         * @summary Create an uln remote
         * @param {RpmUlnRemote} rpmUlnRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (rpmUlnRemote: RpmUlnRemote, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmUlnRemote' is not null or undefined
            assertParamExists('create', 'rpmUlnRemote', rpmUlnRemote)
            const localVarPath = `/pulp/api/v3/remotes/rpm/uln/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rpmUlnRemote, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A ViewSet for UlnRemote.
         * @summary List uln remotes
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] Filter labels by search string
         * @param {string} [pulpLastUpdated] ISO 8601 formatted dates are supported
         * @param {string} [pulpLastUpdatedGt] Filter results where pulp_last_updated is greater than value
         * @param {string} [pulpLastUpdatedGte] Filter results where pulp_last_updated is greater than or equal to value
         * @param {string} [pulpLastUpdatedLt] Filter results where pulp_last_updated is less than value
         * @param {string} [pulpLastUpdatedLte] Filter results where pulp_last_updated is less than or equal to value
         * @param {Array<string>} [pulpLastUpdatedRange] Filter results where pulp_last_updated is between two comma separated values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, pulpLastUpdated?: string, pulpLastUpdatedGt?: string, pulpLastUpdatedGte?: string, pulpLastUpdatedLt?: string, pulpLastUpdatedLte?: string, pulpLastUpdatedRange?: Array<string>, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/remotes/rpm/uln/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIn) {
                localVarQueryParameter['name__in'] = nameIn.join(COLLECTION_FORMATS.csv);
            }

            if (nameStartswith !== undefined) {
                localVarQueryParameter['name__startswith'] = nameStartswith;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (pulpLabelSelect !== undefined) {
                localVarQueryParameter['pulp_label_select'] = pulpLabelSelect;
            }

            if (pulpLastUpdated !== undefined) {
                localVarQueryParameter['pulp_last_updated'] = (pulpLastUpdated as any instanceof Date) ?
                    (pulpLastUpdated as any).toISOString() :
                    pulpLastUpdated;
            }

            if (pulpLastUpdatedGt !== undefined) {
                localVarQueryParameter['pulp_last_updated__gt'] = (pulpLastUpdatedGt as any instanceof Date) ?
                    (pulpLastUpdatedGt as any).toISOString() :
                    pulpLastUpdatedGt;
            }

            if (pulpLastUpdatedGte !== undefined) {
                localVarQueryParameter['pulp_last_updated__gte'] = (pulpLastUpdatedGte as any instanceof Date) ?
                    (pulpLastUpdatedGte as any).toISOString() :
                    pulpLastUpdatedGte;
            }

            if (pulpLastUpdatedLt !== undefined) {
                localVarQueryParameter['pulp_last_updated__lt'] = (pulpLastUpdatedLt as any instanceof Date) ?
                    (pulpLastUpdatedLt as any).toISOString() :
                    pulpLastUpdatedLt;
            }

            if (pulpLastUpdatedLte !== undefined) {
                localVarQueryParameter['pulp_last_updated__lte'] = (pulpLastUpdatedLte as any instanceof Date) ?
                    (pulpLastUpdatedLte as any).toISOString() :
                    pulpLastUpdatedLte;
            }

            if (pulpLastUpdatedRange) {
                localVarQueryParameter['pulp_last_updated__range'] = pulpLastUpdatedRange.join(COLLECTION_FORMATS.csv);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update an uln remote
         * @param {string} rpmUlnRemoteHref 
         * @param {PatchedrpmUlnRemote} patchedrpmUlnRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate: async (rpmUlnRemoteHref: string, patchedrpmUlnRemote: PatchedrpmUlnRemote, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmUlnRemoteHref' is not null or undefined
            assertParamExists('partialUpdate', 'rpmUlnRemoteHref', rpmUlnRemoteHref)
            // verify required parameter 'patchedrpmUlnRemote' is not null or undefined
            assertParamExists('partialUpdate', 'patchedrpmUlnRemote', patchedrpmUlnRemote)
            const localVarPath = `{rpm_uln_remote_href}`
                .replace(`{${"rpm_uln_remote_href"}}`, String(rpmUlnRemoteHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedrpmUlnRemote, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A ViewSet for UlnRemote.
         * @summary Inspect an uln remote
         * @param {string} rpmUlnRemoteHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (rpmUlnRemoteHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmUlnRemoteHref' is not null or undefined
            assertParamExists('read', 'rpmUlnRemoteHref', rpmUlnRemoteHref)
            const localVarPath = `{rpm_uln_remote_href}`
                .replace(`{${"rpm_uln_remote_href"}}`, String(rpmUlnRemoteHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update an uln remote
         * @param {string} rpmUlnRemoteHref 
         * @param {RpmUlnRemote} rpmUlnRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (rpmUlnRemoteHref: string, rpmUlnRemote: RpmUlnRemote, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmUlnRemoteHref' is not null or undefined
            assertParamExists('update', 'rpmUlnRemoteHref', rpmUlnRemoteHref)
            // verify required parameter 'rpmUlnRemote' is not null or undefined
            assertParamExists('update', 'rpmUlnRemote', rpmUlnRemote)
            const localVarPath = `{rpm_uln_remote_href}`
                .replace(`{${"rpm_uln_remote_href"}}`, String(rpmUlnRemoteHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rpmUlnRemote, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RemotesUlnApi - functional programming interface
 * @export
 */
export const RemotesUlnApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RemotesUlnApiAxiosParamCreator(configuration)
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete an uln remote
         * @param {string} rpmUlnRemoteHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(rpmUlnRemoteHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(rpmUlnRemoteHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A ViewSet for UlnRemote.
         * @summary Create an uln remote
         * @param {RpmUlnRemote} rpmUlnRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(rpmUlnRemote: RpmUlnRemote, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RpmUlnRemoteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(rpmUlnRemote, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A ViewSet for UlnRemote.
         * @summary List uln remotes
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] Filter labels by search string
         * @param {string} [pulpLastUpdated] ISO 8601 formatted dates are supported
         * @param {string} [pulpLastUpdatedGt] Filter results where pulp_last_updated is greater than value
         * @param {string} [pulpLastUpdatedGte] Filter results where pulp_last_updated is greater than or equal to value
         * @param {string} [pulpLastUpdatedLt] Filter results where pulp_last_updated is less than value
         * @param {string} [pulpLastUpdatedLte] Filter results where pulp_last_updated is less than or equal to value
         * @param {Array<string>} [pulpLastUpdatedRange] Filter results where pulp_last_updated is between two comma separated values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, pulpLastUpdated?: string, pulpLastUpdatedGt?: string, pulpLastUpdatedGte?: string, pulpLastUpdatedLt?: string, pulpLastUpdatedLte?: string, pulpLastUpdatedRange?: Array<string>, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedrpmUlnRemoteResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, pulpLastUpdated, pulpLastUpdatedGt, pulpLastUpdatedGte, pulpLastUpdatedLt, pulpLastUpdatedLte, pulpLastUpdatedRange, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update an uln remote
         * @param {string} rpmUlnRemoteHref 
         * @param {PatchedrpmUlnRemote} patchedrpmUlnRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdate(rpmUlnRemoteHref: string, patchedrpmUlnRemote: PatchedrpmUlnRemote, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdate(rpmUlnRemoteHref, patchedrpmUlnRemote, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A ViewSet for UlnRemote.
         * @summary Inspect an uln remote
         * @param {string} rpmUlnRemoteHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(rpmUlnRemoteHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RpmUlnRemoteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(rpmUlnRemoteHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update an uln remote
         * @param {string} rpmUlnRemoteHref 
         * @param {RpmUlnRemote} rpmUlnRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(rpmUlnRemoteHref: string, rpmUlnRemote: RpmUlnRemote, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(rpmUlnRemoteHref, rpmUlnRemote, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RemotesUlnApi - factory interface
 * @export
 */
export const RemotesUlnApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RemotesUlnApiFp(configuration)
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete an uln remote
         * @param {string} rpmUlnRemoteHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(rpmUlnRemoteHref: string, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp._delete(rpmUlnRemoteHref, options).then((request) => request(axios, basePath));
        },
        /**
         * A ViewSet for UlnRemote.
         * @summary Create an uln remote
         * @param {RpmUlnRemote} rpmUlnRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(rpmUlnRemote: RpmUlnRemote, options?: any): AxiosPromise<RpmUlnRemoteResponse> {
            return localVarFp.create(rpmUlnRemote, options).then((request) => request(axios, basePath));
        },
        /**
         * A ViewSet for UlnRemote.
         * @summary List uln remotes
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] Filter labels by search string
         * @param {string} [pulpLastUpdated] ISO 8601 formatted dates are supported
         * @param {string} [pulpLastUpdatedGt] Filter results where pulp_last_updated is greater than value
         * @param {string} [pulpLastUpdatedGte] Filter results where pulp_last_updated is greater than or equal to value
         * @param {string} [pulpLastUpdatedLt] Filter results where pulp_last_updated is less than value
         * @param {string} [pulpLastUpdatedLte] Filter results where pulp_last_updated is less than or equal to value
         * @param {Array<string>} [pulpLastUpdatedRange] Filter results where pulp_last_updated is between two comma separated values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, pulpLastUpdated?: string, pulpLastUpdatedGt?: string, pulpLastUpdatedGte?: string, pulpLastUpdatedLt?: string, pulpLastUpdatedLte?: string, pulpLastUpdatedRange?: Array<string>, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedrpmUlnRemoteResponseList> {
            return localVarFp.list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, pulpLastUpdated, pulpLastUpdatedGt, pulpLastUpdatedGte, pulpLastUpdatedLt, pulpLastUpdatedLte, pulpLastUpdatedRange, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update an uln remote
         * @param {string} rpmUlnRemoteHref 
         * @param {PatchedrpmUlnRemote} patchedrpmUlnRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate(rpmUlnRemoteHref: string, patchedrpmUlnRemote: PatchedrpmUlnRemote, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.partialUpdate(rpmUlnRemoteHref, patchedrpmUlnRemote, options).then((request) => request(axios, basePath));
        },
        /**
         * A ViewSet for UlnRemote.
         * @summary Inspect an uln remote
         * @param {string} rpmUlnRemoteHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(rpmUlnRemoteHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<RpmUlnRemoteResponse> {
            return localVarFp.read(rpmUlnRemoteHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update an uln remote
         * @param {string} rpmUlnRemoteHref 
         * @param {RpmUlnRemote} rpmUlnRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(rpmUlnRemoteHref: string, rpmUlnRemote: RpmUlnRemote, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.update(rpmUlnRemoteHref, rpmUlnRemote, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RemotesUlnApi - object-oriented interface
 * @export
 * @class RemotesUlnApi
 * @extends {BaseAPI}
 */
export class RemotesUlnApi extends BaseAPI {
    /**
     * Trigger an asynchronous delete task
     * @summary Delete an uln remote
     * @param {string} rpmUlnRemoteHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemotesUlnApi
     */
    public _delete(rpmUlnRemoteHref: string, options?: any) {
        return RemotesUlnApiFp(this.configuration)._delete(rpmUlnRemoteHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A ViewSet for UlnRemote.
     * @summary Create an uln remote
     * @param {RpmUlnRemote} rpmUlnRemote 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemotesUlnApi
     */
    public create(rpmUlnRemote: RpmUlnRemote, options?: any) {
        return RemotesUlnApiFp(this.configuration).create(rpmUlnRemote, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A ViewSet for UlnRemote.
     * @summary List uln remotes
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] 
     * @param {string} [nameContains] Filter results where name contains value
     * @param {string} [nameIcontains] Filter results where name contains value
     * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
     * @param {string} [nameStartswith] Filter results where name starts with value
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [pulpLabelSelect] Filter labels by search string
     * @param {string} [pulpLastUpdated] ISO 8601 formatted dates are supported
     * @param {string} [pulpLastUpdatedGt] Filter results where pulp_last_updated is greater than value
     * @param {string} [pulpLastUpdatedGte] Filter results where pulp_last_updated is greater than or equal to value
     * @param {string} [pulpLastUpdatedLt] Filter results where pulp_last_updated is less than value
     * @param {string} [pulpLastUpdatedLte] Filter results where pulp_last_updated is less than or equal to value
     * @param {Array<string>} [pulpLastUpdatedRange] Filter results where pulp_last_updated is between two comma separated values
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemotesUlnApi
     */
    public list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, pulpLastUpdated?: string, pulpLastUpdatedGt?: string, pulpLastUpdatedGte?: string, pulpLastUpdatedLt?: string, pulpLastUpdatedLte?: string, pulpLastUpdatedRange?: Array<string>, fields?: string, excludeFields?: string, options?: any) {
        return RemotesUlnApiFp(this.configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, pulpLastUpdated, pulpLastUpdatedGt, pulpLastUpdatedGte, pulpLastUpdatedLt, pulpLastUpdatedLte, pulpLastUpdatedRange, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous partial update task
     * @summary Update an uln remote
     * @param {string} rpmUlnRemoteHref 
     * @param {PatchedrpmUlnRemote} patchedrpmUlnRemote 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemotesUlnApi
     */
    public partialUpdate(rpmUlnRemoteHref: string, patchedrpmUlnRemote: PatchedrpmUlnRemote, options?: any) {
        return RemotesUlnApiFp(this.configuration).partialUpdate(rpmUlnRemoteHref, patchedrpmUlnRemote, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A ViewSet for UlnRemote.
     * @summary Inspect an uln remote
     * @param {string} rpmUlnRemoteHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemotesUlnApi
     */
    public read(rpmUlnRemoteHref: string, fields?: string, excludeFields?: string, options?: any) {
        return RemotesUlnApiFp(this.configuration).read(rpmUlnRemoteHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous update task
     * @summary Update an uln remote
     * @param {string} rpmUlnRemoteHref 
     * @param {RpmUlnRemote} rpmUlnRemote 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemotesUlnApi
     */
    public update(rpmUlnRemoteHref: string, rpmUlnRemote: RpmUlnRemote, options?: any) {
        return RemotesUlnApiFp(this.configuration).update(rpmUlnRemoteHref, rpmUlnRemote, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RepositoriesRpmApi - axios parameter creator
 * @export
 */
export const RepositoriesRpmApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a rpm repository
         * @param {string} rpmRpmRepositoryHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (rpmRpmRepositoryHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmRpmRepositoryHref' is not null or undefined
            assertParamExists('_delete', 'rpmRpmRepositoryHref', rpmRpmRepositoryHref)
            const localVarPath = `{rpm_rpm_repository_href}`
                .replace(`{${"rpm_rpm_repository_href"}}`, String(rpmRpmRepositoryHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A ViewSet for RpmRepository.
         * @summary Create a rpm repository
         * @param {RpmRpmRepository} rpmRpmRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (rpmRpmRepository: RpmRpmRepository, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmRpmRepository' is not null or undefined
            assertParamExists('create', 'rpmRpmRepository', rpmRpmRepository)
            const localVarPath = `/pulp/api/v3/repositories/rpm/rpm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rpmRpmRepository, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A ViewSet for RpmRepository.
         * @summary List rpm repositorys
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] Filter labels by search string
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/repositories/rpm/rpm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIn) {
                localVarQueryParameter['name__in'] = nameIn.join(COLLECTION_FORMATS.csv);
            }

            if (nameStartswith !== undefined) {
                localVarQueryParameter['name__startswith'] = nameStartswith;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (pulpLabelSelect !== undefined) {
                localVarQueryParameter['pulp_label_select'] = pulpLabelSelect;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous task to create a new repository version.
         * @summary Modify Repository Content
         * @param {string} rpmRpmRepositoryHref 
         * @param {RepositoryAddRemoveContent} repositoryAddRemoveContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modify: async (rpmRpmRepositoryHref: string, repositoryAddRemoveContent: RepositoryAddRemoveContent, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmRpmRepositoryHref' is not null or undefined
            assertParamExists('modify', 'rpmRpmRepositoryHref', rpmRpmRepositoryHref)
            // verify required parameter 'repositoryAddRemoveContent' is not null or undefined
            assertParamExists('modify', 'repositoryAddRemoveContent', repositoryAddRemoveContent)
            const localVarPath = `{rpm_rpm_repository_href}modify/`
                .replace(`{${"rpm_rpm_repository_href"}}`, String(rpmRpmRepositoryHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repositoryAddRemoveContent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a rpm repository
         * @param {string} rpmRpmRepositoryHref 
         * @param {PatchedrpmRpmRepository} patchedrpmRpmRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate: async (rpmRpmRepositoryHref: string, patchedrpmRpmRepository: PatchedrpmRpmRepository, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmRpmRepositoryHref' is not null or undefined
            assertParamExists('partialUpdate', 'rpmRpmRepositoryHref', rpmRpmRepositoryHref)
            // verify required parameter 'patchedrpmRpmRepository' is not null or undefined
            assertParamExists('partialUpdate', 'patchedrpmRpmRepository', patchedrpmRpmRepository)
            const localVarPath = `{rpm_rpm_repository_href}`
                .replace(`{${"rpm_rpm_repository_href"}}`, String(rpmRpmRepositoryHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedrpmRpmRepository, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A ViewSet for RpmRepository.
         * @summary Inspect a rpm repository
         * @param {string} rpmRpmRepositoryHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (rpmRpmRepositoryHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmRpmRepositoryHref' is not null or undefined
            assertParamExists('read', 'rpmRpmRepositoryHref', rpmRpmRepositoryHref)
            const localVarPath = `{rpm_rpm_repository_href}`
                .replace(`{${"rpm_rpm_repository_href"}}`, String(rpmRpmRepositoryHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous task to sync RPM content.
         * @summary Sync from remote
         * @param {string} rpmRpmRepositoryHref 
         * @param {RpmRepositorySyncURL} rpmRepositorySyncURL 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sync: async (rpmRpmRepositoryHref: string, rpmRepositorySyncURL: RpmRepositorySyncURL, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmRpmRepositoryHref' is not null or undefined
            assertParamExists('sync', 'rpmRpmRepositoryHref', rpmRpmRepositoryHref)
            // verify required parameter 'rpmRepositorySyncURL' is not null or undefined
            assertParamExists('sync', 'rpmRepositorySyncURL', rpmRepositorySyncURL)
            const localVarPath = `{rpm_rpm_repository_href}sync/`
                .replace(`{${"rpm_rpm_repository_href"}}`, String(rpmRpmRepositoryHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rpmRepositorySyncURL, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a rpm repository
         * @param {string} rpmRpmRepositoryHref 
         * @param {RpmRpmRepository} rpmRpmRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (rpmRpmRepositoryHref: string, rpmRpmRepository: RpmRpmRepository, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmRpmRepositoryHref' is not null or undefined
            assertParamExists('update', 'rpmRpmRepositoryHref', rpmRpmRepositoryHref)
            // verify required parameter 'rpmRpmRepository' is not null or undefined
            assertParamExists('update', 'rpmRpmRepository', rpmRpmRepository)
            const localVarPath = `{rpm_rpm_repository_href}`
                .replace(`{${"rpm_rpm_repository_href"}}`, String(rpmRpmRepositoryHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rpmRpmRepository, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoriesRpmApi - functional programming interface
 * @export
 */
export const RepositoriesRpmApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepositoriesRpmApiAxiosParamCreator(configuration)
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a rpm repository
         * @param {string} rpmRpmRepositoryHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(rpmRpmRepositoryHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(rpmRpmRepositoryHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A ViewSet for RpmRepository.
         * @summary Create a rpm repository
         * @param {RpmRpmRepository} rpmRpmRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(rpmRpmRepository: RpmRpmRepository, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RpmRpmRepositoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(rpmRpmRepository, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A ViewSet for RpmRepository.
         * @summary List rpm repositorys
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] Filter labels by search string
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedrpmRpmRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous task to create a new repository version.
         * @summary Modify Repository Content
         * @param {string} rpmRpmRepositoryHref 
         * @param {RepositoryAddRemoveContent} repositoryAddRemoveContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modify(rpmRpmRepositoryHref: string, repositoryAddRemoveContent: RepositoryAddRemoveContent, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modify(rpmRpmRepositoryHref, repositoryAddRemoveContent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a rpm repository
         * @param {string} rpmRpmRepositoryHref 
         * @param {PatchedrpmRpmRepository} patchedrpmRpmRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdate(rpmRpmRepositoryHref: string, patchedrpmRpmRepository: PatchedrpmRpmRepository, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdate(rpmRpmRepositoryHref, patchedrpmRpmRepository, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A ViewSet for RpmRepository.
         * @summary Inspect a rpm repository
         * @param {string} rpmRpmRepositoryHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(rpmRpmRepositoryHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RpmRpmRepositoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(rpmRpmRepositoryHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous task to sync RPM content.
         * @summary Sync from remote
         * @param {string} rpmRpmRepositoryHref 
         * @param {RpmRepositorySyncURL} rpmRepositorySyncURL 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sync(rpmRpmRepositoryHref: string, rpmRepositorySyncURL: RpmRepositorySyncURL, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sync(rpmRpmRepositoryHref, rpmRepositorySyncURL, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a rpm repository
         * @param {string} rpmRpmRepositoryHref 
         * @param {RpmRpmRepository} rpmRpmRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(rpmRpmRepositoryHref: string, rpmRpmRepository: RpmRpmRepository, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(rpmRpmRepositoryHref, rpmRpmRepository, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RepositoriesRpmApi - factory interface
 * @export
 */
export const RepositoriesRpmApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepositoriesRpmApiFp(configuration)
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a rpm repository
         * @param {string} rpmRpmRepositoryHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(rpmRpmRepositoryHref: string, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp._delete(rpmRpmRepositoryHref, options).then((request) => request(axios, basePath));
        },
        /**
         * A ViewSet for RpmRepository.
         * @summary Create a rpm repository
         * @param {RpmRpmRepository} rpmRpmRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(rpmRpmRepository: RpmRpmRepository, options?: any): AxiosPromise<RpmRpmRepositoryResponse> {
            return localVarFp.create(rpmRpmRepository, options).then((request) => request(axios, basePath));
        },
        /**
         * A ViewSet for RpmRepository.
         * @summary List rpm repositorys
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] Filter labels by search string
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedrpmRpmRepositoryResponseList> {
            return localVarFp.list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous task to create a new repository version.
         * @summary Modify Repository Content
         * @param {string} rpmRpmRepositoryHref 
         * @param {RepositoryAddRemoveContent} repositoryAddRemoveContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modify(rpmRpmRepositoryHref: string, repositoryAddRemoveContent: RepositoryAddRemoveContent, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.modify(rpmRpmRepositoryHref, repositoryAddRemoveContent, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a rpm repository
         * @param {string} rpmRpmRepositoryHref 
         * @param {PatchedrpmRpmRepository} patchedrpmRpmRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate(rpmRpmRepositoryHref: string, patchedrpmRpmRepository: PatchedrpmRpmRepository, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.partialUpdate(rpmRpmRepositoryHref, patchedrpmRpmRepository, options).then((request) => request(axios, basePath));
        },
        /**
         * A ViewSet for RpmRepository.
         * @summary Inspect a rpm repository
         * @param {string} rpmRpmRepositoryHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(rpmRpmRepositoryHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<RpmRpmRepositoryResponse> {
            return localVarFp.read(rpmRpmRepositoryHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous task to sync RPM content.
         * @summary Sync from remote
         * @param {string} rpmRpmRepositoryHref 
         * @param {RpmRepositorySyncURL} rpmRepositorySyncURL 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sync(rpmRpmRepositoryHref: string, rpmRepositorySyncURL: RpmRepositorySyncURL, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.sync(rpmRpmRepositoryHref, rpmRepositorySyncURL, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a rpm repository
         * @param {string} rpmRpmRepositoryHref 
         * @param {RpmRpmRepository} rpmRpmRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(rpmRpmRepositoryHref: string, rpmRpmRepository: RpmRpmRepository, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.update(rpmRpmRepositoryHref, rpmRpmRepository, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoriesRpmApi - object-oriented interface
 * @export
 * @class RepositoriesRpmApi
 * @extends {BaseAPI}
 */
export class RepositoriesRpmApi extends BaseAPI {
    /**
     * Trigger an asynchronous delete task
     * @summary Delete a rpm repository
     * @param {string} rpmRpmRepositoryHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesRpmApi
     */
    public _delete(rpmRpmRepositoryHref: string, options?: any) {
        return RepositoriesRpmApiFp(this.configuration)._delete(rpmRpmRepositoryHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A ViewSet for RpmRepository.
     * @summary Create a rpm repository
     * @param {RpmRpmRepository} rpmRpmRepository 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesRpmApi
     */
    public create(rpmRpmRepository: RpmRpmRepository, options?: any) {
        return RepositoriesRpmApiFp(this.configuration).create(rpmRpmRepository, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A ViewSet for RpmRepository.
     * @summary List rpm repositorys
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] 
     * @param {string} [nameContains] Filter results where name contains value
     * @param {string} [nameIcontains] Filter results where name contains value
     * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
     * @param {string} [nameStartswith] Filter results where name starts with value
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [pulpLabelSelect] Filter labels by search string
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesRpmApi
     */
    public list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options?: any) {
        return RepositoriesRpmApiFp(this.configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous task to create a new repository version.
     * @summary Modify Repository Content
     * @param {string} rpmRpmRepositoryHref 
     * @param {RepositoryAddRemoveContent} repositoryAddRemoveContent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesRpmApi
     */
    public modify(rpmRpmRepositoryHref: string, repositoryAddRemoveContent: RepositoryAddRemoveContent, options?: any) {
        return RepositoriesRpmApiFp(this.configuration).modify(rpmRpmRepositoryHref, repositoryAddRemoveContent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous partial update task
     * @summary Update a rpm repository
     * @param {string} rpmRpmRepositoryHref 
     * @param {PatchedrpmRpmRepository} patchedrpmRpmRepository 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesRpmApi
     */
    public partialUpdate(rpmRpmRepositoryHref: string, patchedrpmRpmRepository: PatchedrpmRpmRepository, options?: any) {
        return RepositoriesRpmApiFp(this.configuration).partialUpdate(rpmRpmRepositoryHref, patchedrpmRpmRepository, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A ViewSet for RpmRepository.
     * @summary Inspect a rpm repository
     * @param {string} rpmRpmRepositoryHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesRpmApi
     */
    public read(rpmRpmRepositoryHref: string, fields?: string, excludeFields?: string, options?: any) {
        return RepositoriesRpmApiFp(this.configuration).read(rpmRpmRepositoryHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous task to sync RPM content.
     * @summary Sync from remote
     * @param {string} rpmRpmRepositoryHref 
     * @param {RpmRepositorySyncURL} rpmRepositorySyncURL 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesRpmApi
     */
    public sync(rpmRpmRepositoryHref: string, rpmRepositorySyncURL: RpmRepositorySyncURL, options?: any) {
        return RepositoriesRpmApiFp(this.configuration).sync(rpmRpmRepositoryHref, rpmRepositorySyncURL, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous update task
     * @summary Update a rpm repository
     * @param {string} rpmRpmRepositoryHref 
     * @param {RpmRpmRepository} rpmRpmRepository 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesRpmApi
     */
    public update(rpmRpmRepositoryHref: string, rpmRpmRepository: RpmRpmRepository, options?: any) {
        return RepositoriesRpmApiFp(this.configuration).update(rpmRpmRepositoryHref, rpmRpmRepository, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RepositoriesRpmVersionsApi - axios parameter creator
 * @export
 */
export const RepositoriesRpmVersionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous task to delete a repository version.
         * @summary Delete a repository version
         * @param {string} rpmRpmRepositoryVersionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (rpmRpmRepositoryVersionHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmRpmRepositoryVersionHref' is not null or undefined
            assertParamExists('_delete', 'rpmRpmRepositoryVersionHref', rpmRpmRepositoryVersionHref)
            const localVarPath = `{rpm_rpm_repository_version_href}`
                .replace(`{${"rpm_rpm_repository_version_href"}}`, String(rpmRpmRepositoryVersionHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * RpmRepositoryVersion represents a single rpm repository version.
         * @summary List repository versions
         * @param {string} rpmRpmRepositoryHref 
         * @param {string} [content] Content Unit referenced by HREF
         * @param {string} [contentIn] Content Unit referenced by HREF
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [number] 
         * @param {number} [numberGt] Filter results where number is greater than value
         * @param {number} [numberGte] Filter results where number is greater than or equal to value
         * @param {number} [numberLt] Filter results where number is less than value
         * @param {number} [numberLte] Filter results where number is less than or equal to value
         * @param {Array<number>} [numberRange] Filter results where number is between two comma separated values
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpCreated] ISO 8601 formatted dates are supported
         * @param {string} [pulpCreatedGt] Filter results where pulp_created is greater than value
         * @param {string} [pulpCreatedGte] Filter results where pulp_created is greater than or equal to value
         * @param {string} [pulpCreatedLt] Filter results where pulp_created is less than value
         * @param {string} [pulpCreatedLte] Filter results where pulp_created is less than or equal to value
         * @param {Array<string>} [pulpCreatedRange] Filter results where pulp_created is between two comma separated values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (rpmRpmRepositoryHref: string, content?: string, contentIn?: string, limit?: number, number?: number, numberGt?: number, numberGte?: number, numberLt?: number, numberLte?: number, numberRange?: Array<number>, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: Array<string>, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmRpmRepositoryHref' is not null or undefined
            assertParamExists('list', 'rpmRpmRepositoryHref', rpmRpmRepositoryHref)
            const localVarPath = `{rpm_rpm_repository_href}versions/`
                .replace(`{${"rpm_rpm_repository_href"}}`, String(rpmRpmRepositoryHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (content !== undefined) {
                localVarQueryParameter['content'] = content;
            }

            if (contentIn !== undefined) {
                localVarQueryParameter['content__in'] = contentIn;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }

            if (numberGt !== undefined) {
                localVarQueryParameter['number__gt'] = numberGt;
            }

            if (numberGte !== undefined) {
                localVarQueryParameter['number__gte'] = numberGte;
            }

            if (numberLt !== undefined) {
                localVarQueryParameter['number__lt'] = numberLt;
            }

            if (numberLte !== undefined) {
                localVarQueryParameter['number__lte'] = numberLte;
            }

            if (numberRange) {
                localVarQueryParameter['number__range'] = numberRange.join(COLLECTION_FORMATS.csv);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (pulpCreated !== undefined) {
                localVarQueryParameter['pulp_created'] = (pulpCreated as any instanceof Date) ?
                    (pulpCreated as any).toISOString() :
                    pulpCreated;
            }

            if (pulpCreatedGt !== undefined) {
                localVarQueryParameter['pulp_created__gt'] = (pulpCreatedGt as any instanceof Date) ?
                    (pulpCreatedGt as any).toISOString() :
                    pulpCreatedGt;
            }

            if (pulpCreatedGte !== undefined) {
                localVarQueryParameter['pulp_created__gte'] = (pulpCreatedGte as any instanceof Date) ?
                    (pulpCreatedGte as any).toISOString() :
                    pulpCreatedGte;
            }

            if (pulpCreatedLt !== undefined) {
                localVarQueryParameter['pulp_created__lt'] = (pulpCreatedLt as any instanceof Date) ?
                    (pulpCreatedLt as any).toISOString() :
                    pulpCreatedLt;
            }

            if (pulpCreatedLte !== undefined) {
                localVarQueryParameter['pulp_created__lte'] = (pulpCreatedLte as any instanceof Date) ?
                    (pulpCreatedLte as any).toISOString() :
                    pulpCreatedLte;
            }

            if (pulpCreatedRange) {
                localVarQueryParameter['pulp_created__range'] = pulpCreatedRange.join(COLLECTION_FORMATS.csv);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * RpmRepositoryVersion represents a single rpm repository version.
         * @summary Inspect a repository version
         * @param {string} rpmRpmRepositoryVersionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (rpmRpmRepositoryVersionHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmRpmRepositoryVersionHref' is not null or undefined
            assertParamExists('read', 'rpmRpmRepositoryVersionHref', rpmRpmRepositoryVersionHref)
            const localVarPath = `{rpm_rpm_repository_version_href}`
                .replace(`{${"rpm_rpm_repository_version_href"}}`, String(rpmRpmRepositoryVersionHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous task to repair a repository version.
         * @param {string} rpmRpmRepositoryVersionHref 
         * @param {RepositoryVersion} repositoryVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repair: async (rpmRpmRepositoryVersionHref: string, repositoryVersion: RepositoryVersion, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rpmRpmRepositoryVersionHref' is not null or undefined
            assertParamExists('repair', 'rpmRpmRepositoryVersionHref', rpmRpmRepositoryVersionHref)
            // verify required parameter 'repositoryVersion' is not null or undefined
            assertParamExists('repair', 'repositoryVersion', repositoryVersion)
            const localVarPath = `{rpm_rpm_repository_version_href}repair/`
                .replace(`{${"rpm_rpm_repository_version_href"}}`, String(rpmRpmRepositoryVersionHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repositoryVersion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoriesRpmVersionsApi - functional programming interface
 * @export
 */
export const RepositoriesRpmVersionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepositoriesRpmVersionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Trigger an asynchronous task to delete a repository version.
         * @summary Delete a repository version
         * @param {string} rpmRpmRepositoryVersionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(rpmRpmRepositoryVersionHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(rpmRpmRepositoryVersionHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * RpmRepositoryVersion represents a single rpm repository version.
         * @summary List repository versions
         * @param {string} rpmRpmRepositoryHref 
         * @param {string} [content] Content Unit referenced by HREF
         * @param {string} [contentIn] Content Unit referenced by HREF
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [number] 
         * @param {number} [numberGt] Filter results where number is greater than value
         * @param {number} [numberGte] Filter results where number is greater than or equal to value
         * @param {number} [numberLt] Filter results where number is less than value
         * @param {number} [numberLte] Filter results where number is less than or equal to value
         * @param {Array<number>} [numberRange] Filter results where number is between two comma separated values
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpCreated] ISO 8601 formatted dates are supported
         * @param {string} [pulpCreatedGt] Filter results where pulp_created is greater than value
         * @param {string} [pulpCreatedGte] Filter results where pulp_created is greater than or equal to value
         * @param {string} [pulpCreatedLt] Filter results where pulp_created is less than value
         * @param {string} [pulpCreatedLte] Filter results where pulp_created is less than or equal to value
         * @param {Array<string>} [pulpCreatedRange] Filter results where pulp_created is between two comma separated values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(rpmRpmRepositoryHref: string, content?: string, contentIn?: string, limit?: number, number?: number, numberGt?: number, numberGte?: number, numberLt?: number, numberLte?: number, numberRange?: Array<number>, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: Array<string>, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRepositoryVersionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(rpmRpmRepositoryHref, content, contentIn, limit, number, numberGt, numberGte, numberLt, numberLte, numberRange, offset, ordering, pulpCreated, pulpCreatedGt, pulpCreatedGte, pulpCreatedLt, pulpCreatedLte, pulpCreatedRange, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * RpmRepositoryVersion represents a single rpm repository version.
         * @summary Inspect a repository version
         * @param {string} rpmRpmRepositoryVersionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(rpmRpmRepositoryVersionHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(rpmRpmRepositoryVersionHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous task to repair a repository version.
         * @param {string} rpmRpmRepositoryVersionHref 
         * @param {RepositoryVersion} repositoryVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repair(rpmRpmRepositoryVersionHref: string, repositoryVersion: RepositoryVersion, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repair(rpmRpmRepositoryVersionHref, repositoryVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RepositoriesRpmVersionsApi - factory interface
 * @export
 */
export const RepositoriesRpmVersionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepositoriesRpmVersionsApiFp(configuration)
    return {
        /**
         * Trigger an asynchronous task to delete a repository version.
         * @summary Delete a repository version
         * @param {string} rpmRpmRepositoryVersionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(rpmRpmRepositoryVersionHref: string, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp._delete(rpmRpmRepositoryVersionHref, options).then((request) => request(axios, basePath));
        },
        /**
         * RpmRepositoryVersion represents a single rpm repository version.
         * @summary List repository versions
         * @param {string} rpmRpmRepositoryHref 
         * @param {string} [content] Content Unit referenced by HREF
         * @param {string} [contentIn] Content Unit referenced by HREF
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [number] 
         * @param {number} [numberGt] Filter results where number is greater than value
         * @param {number} [numberGte] Filter results where number is greater than or equal to value
         * @param {number} [numberLt] Filter results where number is less than value
         * @param {number} [numberLte] Filter results where number is less than or equal to value
         * @param {Array<number>} [numberRange] Filter results where number is between two comma separated values
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpCreated] ISO 8601 formatted dates are supported
         * @param {string} [pulpCreatedGt] Filter results where pulp_created is greater than value
         * @param {string} [pulpCreatedGte] Filter results where pulp_created is greater than or equal to value
         * @param {string} [pulpCreatedLt] Filter results where pulp_created is less than value
         * @param {string} [pulpCreatedLte] Filter results where pulp_created is less than or equal to value
         * @param {Array<string>} [pulpCreatedRange] Filter results where pulp_created is between two comma separated values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(rpmRpmRepositoryHref: string, content?: string, contentIn?: string, limit?: number, number?: number, numberGt?: number, numberGte?: number, numberLt?: number, numberLte?: number, numberRange?: Array<number>, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: Array<string>, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedRepositoryVersionResponseList> {
            return localVarFp.list(rpmRpmRepositoryHref, content, contentIn, limit, number, numberGt, numberGte, numberLt, numberLte, numberRange, offset, ordering, pulpCreated, pulpCreatedGt, pulpCreatedGte, pulpCreatedLt, pulpCreatedLte, pulpCreatedRange, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * RpmRepositoryVersion represents a single rpm repository version.
         * @summary Inspect a repository version
         * @param {string} rpmRpmRepositoryVersionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(rpmRpmRepositoryVersionHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<RepositoryVersionResponse> {
            return localVarFp.read(rpmRpmRepositoryVersionHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous task to repair a repository version.
         * @param {string} rpmRpmRepositoryVersionHref 
         * @param {RepositoryVersion} repositoryVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repair(rpmRpmRepositoryVersionHref: string, repositoryVersion: RepositoryVersion, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.repair(rpmRpmRepositoryVersionHref, repositoryVersion, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoriesRpmVersionsApi - object-oriented interface
 * @export
 * @class RepositoriesRpmVersionsApi
 * @extends {BaseAPI}
 */
export class RepositoriesRpmVersionsApi extends BaseAPI {
    /**
     * Trigger an asynchronous task to delete a repository version.
     * @summary Delete a repository version
     * @param {string} rpmRpmRepositoryVersionHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesRpmVersionsApi
     */
    public _delete(rpmRpmRepositoryVersionHref: string, options?: any) {
        return RepositoriesRpmVersionsApiFp(this.configuration)._delete(rpmRpmRepositoryVersionHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * RpmRepositoryVersion represents a single rpm repository version.
     * @summary List repository versions
     * @param {string} rpmRpmRepositoryHref 
     * @param {string} [content] Content Unit referenced by HREF
     * @param {string} [contentIn] Content Unit referenced by HREF
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [number] 
     * @param {number} [numberGt] Filter results where number is greater than value
     * @param {number} [numberGte] Filter results where number is greater than or equal to value
     * @param {number} [numberLt] Filter results where number is less than value
     * @param {number} [numberLte] Filter results where number is less than or equal to value
     * @param {Array<number>} [numberRange] Filter results where number is between two comma separated values
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [pulpCreated] ISO 8601 formatted dates are supported
     * @param {string} [pulpCreatedGt] Filter results where pulp_created is greater than value
     * @param {string} [pulpCreatedGte] Filter results where pulp_created is greater than or equal to value
     * @param {string} [pulpCreatedLt] Filter results where pulp_created is less than value
     * @param {string} [pulpCreatedLte] Filter results where pulp_created is less than or equal to value
     * @param {Array<string>} [pulpCreatedRange] Filter results where pulp_created is between two comma separated values
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesRpmVersionsApi
     */
    public list(rpmRpmRepositoryHref: string, content?: string, contentIn?: string, limit?: number, number?: number, numberGt?: number, numberGte?: number, numberLt?: number, numberLte?: number, numberRange?: Array<number>, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: Array<string>, fields?: string, excludeFields?: string, options?: any) {
        return RepositoriesRpmVersionsApiFp(this.configuration).list(rpmRpmRepositoryHref, content, contentIn, limit, number, numberGt, numberGte, numberLt, numberLte, numberRange, offset, ordering, pulpCreated, pulpCreatedGt, pulpCreatedGte, pulpCreatedLt, pulpCreatedLte, pulpCreatedRange, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * RpmRepositoryVersion represents a single rpm repository version.
     * @summary Inspect a repository version
     * @param {string} rpmRpmRepositoryVersionHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesRpmVersionsApi
     */
    public read(rpmRpmRepositoryVersionHref: string, fields?: string, excludeFields?: string, options?: any) {
        return RepositoriesRpmVersionsApiFp(this.configuration).read(rpmRpmRepositoryVersionHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous task to repair a repository version.
     * @param {string} rpmRpmRepositoryVersionHref 
     * @param {RepositoryVersion} repositoryVersion 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesRpmVersionsApi
     */
    public repair(rpmRpmRepositoryVersionHref: string, repositoryVersion: RepositoryVersion, options?: any) {
        return RepositoriesRpmVersionsApiFp(this.configuration).repair(rpmRpmRepositoryVersionHref, repositoryVersion, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RpmCopyApi - axios parameter creator
 * @export
 */
export const RpmCopyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous task to copy RPM contentfrom one repository into another, creating a newrepository version.
         * @summary Copy content
         * @param {Copy} copy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContent: async (copy: Copy, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'copy' is not null or undefined
            assertParamExists('copyContent', 'copy', copy)
            const localVarPath = `/pulp/api/v3/rpm/copy/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(copy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RpmCopyApi - functional programming interface
 * @export
 */
export const RpmCopyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RpmCopyApiAxiosParamCreator(configuration)
    return {
        /**
         * Trigger an asynchronous task to copy RPM contentfrom one repository into another, creating a newrepository version.
         * @summary Copy content
         * @param {Copy} copy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copyContent(copy: Copy, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.copyContent(copy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RpmCopyApi - factory interface
 * @export
 */
export const RpmCopyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RpmCopyApiFp(configuration)
    return {
        /**
         * Trigger an asynchronous task to copy RPM contentfrom one repository into another, creating a newrepository version.
         * @summary Copy content
         * @param {Copy} copy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContent(copy: Copy, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.copyContent(copy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RpmCopyApi - object-oriented interface
 * @export
 * @class RpmCopyApi
 * @extends {BaseAPI}
 */
export class RpmCopyApi extends BaseAPI {
    /**
     * Trigger an asynchronous task to copy RPM contentfrom one repository into another, creating a newrepository version.
     * @summary Copy content
     * @param {Copy} copy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RpmCopyApi
     */
    public copyContent(copy: Copy, options?: any) {
        return RpmCopyApiFp(this.configuration).copyContent(copy, options).then((request) => request(this.axios, this.basePath));
    }
}



