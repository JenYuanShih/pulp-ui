/* tslint:disable */
/* eslint-disable */
/**
 * Pulp 3 API
 * Fetch, Upload, Organize, and Distribute Software Packages
 *
 * The version of the OpenAPI document: v3
 * Contact: pulp-list@redhat.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Serializer for asynchronous operations.
 * @export
 * @interface AsyncOperationResponse
 */
export interface AsyncOperationResponse {
    /**
     * The href of the task.
     * @type {string}
     * @memberof AsyncOperationResponse
     */
    task: string;
}
/**
 * Serializer for the RepositoryVersion content summary
 * @export
 * @interface ContentSummary
 */
export interface ContentSummary {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ContentSummary
     */
    added: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ContentSummary
     */
    removed: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ContentSummary
     */
    present: { [key: string]: object; };
}
/**
 * Serializer for the RepositoryVersion content summary
 * @export
 * @interface ContentSummaryResponse
 */
export interface ContentSummaryResponse {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ContentSummaryResponse
     */
    added: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ContentSummaryResponse
     */
    removed: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ContentSummaryResponse
     */
    present: { [key: string]: object; };
}
/**
 * Serializer for File alternate content source.
 * @export
 * @interface FileFileAlternateContentSource
 */
export interface FileFileAlternateContentSource {
    /**
     * Name of Alternate Content Source.
     * @type {string}
     * @memberof FileFileAlternateContentSource
     */
    name: string;
    /**
     * Date of last refresh of AlternateContentSource.
     * @type {string}
     * @memberof FileFileAlternateContentSource
     */
    last_refreshed?: string | null;
    /**
     * List of paths that will be appended to the Remote url when searching for content.
     * @type {Array<string>}
     * @memberof FileFileAlternateContentSource
     */
    paths?: Array<string>;
    /**
     * The remote to provide alternate content source.
     * @type {string}
     * @memberof FileFileAlternateContentSource
     */
    remote: string;
}
/**
 * Serializer for File alternate content source.
 * @export
 * @interface FileFileAlternateContentSourceResponse
 */
export interface FileFileAlternateContentSourceResponse {
    /**
     * 
     * @type {string}
     * @memberof FileFileAlternateContentSourceResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof FileFileAlternateContentSourceResponse
     */
    pulp_created?: string;
    /**
     * Name of Alternate Content Source.
     * @type {string}
     * @memberof FileFileAlternateContentSourceResponse
     */
    name: string;
    /**
     * Date of last refresh of AlternateContentSource.
     * @type {string}
     * @memberof FileFileAlternateContentSourceResponse
     */
    last_refreshed?: string | null;
    /**
     * List of paths that will be appended to the Remote url when searching for content.
     * @type {Array<string>}
     * @memberof FileFileAlternateContentSourceResponse
     */
    paths?: Array<string>;
    /**
     * The remote to provide alternate content source.
     * @type {string}
     * @memberof FileFileAlternateContentSourceResponse
     */
    remote: string;
}
/**
 * Serializer for File Content.
 * @export
 * @interface FileFileContentResponse
 */
export interface FileFileContentResponse {
    /**
     * 
     * @type {string}
     * @memberof FileFileContentResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof FileFileContentResponse
     */
    pulp_created?: string;
    /**
     * Artifact file representing the physical content
     * @type {string}
     * @memberof FileFileContentResponse
     */
    artifact?: string;
    /**
     * Path where the artifact is located relative to distributions base_path
     * @type {string}
     * @memberof FileFileContentResponse
     */
    relative_path: string;
    /**
     * The MD5 checksum if available.
     * @type {string}
     * @memberof FileFileContentResponse
     */
    md5?: string;
    /**
     * The SHA-1 checksum if available.
     * @type {string}
     * @memberof FileFileContentResponse
     */
    sha1?: string;
    /**
     * The SHA-224 checksum if available.
     * @type {string}
     * @memberof FileFileContentResponse
     */
    sha224?: string;
    /**
     * The SHA-256 checksum if available.
     * @type {string}
     * @memberof FileFileContentResponse
     */
    sha256?: string;
    /**
     * The SHA-384 checksum if available.
     * @type {string}
     * @memberof FileFileContentResponse
     */
    sha384?: string;
    /**
     * The SHA-512 checksum if available.
     * @type {string}
     * @memberof FileFileContentResponse
     */
    sha512?: string;
}
/**
 * Serializer for File Distributions.
 * @export
 * @interface FileFileDistribution
 */
export interface FileFileDistribution {
    /**
     * The base (relative) path component of the published url. Avoid paths that                     overlap with other distribution base paths (e.g. \"foo\" and \"foo/bar\")
     * @type {string}
     * @memberof FileFileDistribution
     */
    base_path: string;
    /**
     * An optional content-guard.
     * @type {string}
     * @memberof FileFileDistribution
     */
    content_guard?: string | null;
    /**
     * 
     * @type {object}
     * @memberof FileFileDistribution
     */
    pulp_labels?: object;
    /**
     * A unique name. Ex, `rawhide` and `stable`.
     * @type {string}
     * @memberof FileFileDistribution
     */
    name: string;
    /**
     * The latest RepositoryVersion for this Repository will be served.
     * @type {string}
     * @memberof FileFileDistribution
     */
    repository?: string | null;
    /**
     * Publication to be served
     * @type {string}
     * @memberof FileFileDistribution
     */
    publication?: string | null;
}
/**
 * Serializer for File Distributions.
 * @export
 * @interface FileFileDistributionResponse
 */
export interface FileFileDistributionResponse {
    /**
     * 
     * @type {string}
     * @memberof FileFileDistributionResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof FileFileDistributionResponse
     */
    pulp_created?: string;
    /**
     * The base (relative) path component of the published url. Avoid paths that                     overlap with other distribution base paths (e.g. \"foo\" and \"foo/bar\")
     * @type {string}
     * @memberof FileFileDistributionResponse
     */
    base_path: string;
    /**
     * The URL for accessing the publication as defined by this distribution.
     * @type {string}
     * @memberof FileFileDistributionResponse
     */
    base_url?: string;
    /**
     * An optional content-guard.
     * @type {string}
     * @memberof FileFileDistributionResponse
     */
    content_guard?: string | null;
    /**
     * 
     * @type {object}
     * @memberof FileFileDistributionResponse
     */
    pulp_labels?: object;
    /**
     * A unique name. Ex, `rawhide` and `stable`.
     * @type {string}
     * @memberof FileFileDistributionResponse
     */
    name: string;
    /**
     * The latest RepositoryVersion for this Repository will be served.
     * @type {string}
     * @memberof FileFileDistributionResponse
     */
    repository?: string | null;
    /**
     * Publication to be served
     * @type {string}
     * @memberof FileFileDistributionResponse
     */
    publication?: string | null;
}
/**
 * Serializer for File Publications.
 * @export
 * @interface FileFilePublication
 */
export interface FileFilePublication {
    /**
     * 
     * @type {string}
     * @memberof FileFilePublication
     */
    repository_version?: string;
    /**
     * A URI of the repository to be published.
     * @type {string}
     * @memberof FileFilePublication
     */
    repository?: string;
    /**
     * Filename to use for manifest file containing metadata for all the files.
     * @type {string}
     * @memberof FileFilePublication
     */
    manifest?: string;
}
/**
 * Serializer for File Publications.
 * @export
 * @interface FileFilePublicationResponse
 */
export interface FileFilePublicationResponse {
    /**
     * 
     * @type {string}
     * @memberof FileFilePublicationResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof FileFilePublicationResponse
     */
    pulp_created?: string;
    /**
     * 
     * @type {string}
     * @memberof FileFilePublicationResponse
     */
    repository_version?: string;
    /**
     * A URI of the repository to be published.
     * @type {string}
     * @memberof FileFilePublicationResponse
     */
    repository?: string;
    /**
     * This publication is currently hosted as defined by these distributions.
     * @type {Array<string>}
     * @memberof FileFilePublicationResponse
     */
    distributions?: Array<string>;
    /**
     * Filename to use for manifest file containing metadata for all the files.
     * @type {string}
     * @memberof FileFilePublicationResponse
     */
    manifest?: string;
}
/**
 * Serializer for File Remotes.
 * @export
 * @interface FileFileRemote
 */
export interface FileFileRemote {
    /**
     * A unique name for this remote.
     * @type {string}
     * @memberof FileFileRemote
     */
    name: string;
    /**
     * The URL of an external content source.
     * @type {string}
     * @memberof FileFileRemote
     */
    url: string;
    /**
     * A PEM encoded CA certificate used to validate the server certificate presented by the remote server.
     * @type {string}
     * @memberof FileFileRemote
     */
    ca_cert?: string | null;
    /**
     * A PEM encoded client certificate used for authentication.
     * @type {string}
     * @memberof FileFileRemote
     */
    client_cert?: string | null;
    /**
     * A PEM encoded private key used for authentication.
     * @type {string}
     * @memberof FileFileRemote
     */
    client_key?: string | null;
    /**
     * If True, TLS peer validation must be performed.
     * @type {boolean}
     * @memberof FileFileRemote
     */
    tls_validation?: boolean;
    /**
     * The proxy URL. Format: scheme://host:port
     * @type {string}
     * @memberof FileFileRemote
     */
    proxy_url?: string | null;
    /**
     * The username to authenticte to the proxy.
     * @type {string}
     * @memberof FileFileRemote
     */
    proxy_username?: string | null;
    /**
     * The password to authenticte to the proxy.
     * @type {string}
     * @memberof FileFileRemote
     */
    proxy_password?: string | null;
    /**
     * The username to be used for authentication when syncing.
     * @type {string}
     * @memberof FileFileRemote
     */
    username?: string | null;
    /**
     * The password to be used for authentication when syncing.
     * @type {string}
     * @memberof FileFileRemote
     */
    password?: string | null;
    /**
     * 
     * @type {object}
     * @memberof FileFileRemote
     */
    pulp_labels?: object;
    /**
     * Total number of simultaneous connections. If not set then the default value will be used.
     * @type {number}
     * @memberof FileFileRemote
     */
    download_concurrency?: number | null;
    /**
     * Maximum number of retry attempts after a download failure. If not set then the default value (3) will be used.
     * @type {number}
     * @memberof FileFileRemote
     */
    max_retries?: number | null;
    /**
     * The policy to use when downloading content. The possible values include: \'immediate\', \'on_demand\', and \'streamed\'. \'immediate\' is the default.
     * @type {PolicyEnum}
     * @memberof FileFileRemote
     */
    policy?: PolicyEnum;
    /**
     * aiohttp.ClientTimeout.total (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof FileFileRemote
     */
    total_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.connect (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof FileFileRemote
     */
    connect_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.sock_connect (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof FileFileRemote
     */
    sock_connect_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.sock_read (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof FileFileRemote
     */
    sock_read_timeout?: number | null;
    /**
     * Headers for aiohttp.Clientsession
     * @type {Array<object>}
     * @memberof FileFileRemote
     */
    headers?: Array<object>;
    /**
     * Limits total download rate in requests per second
     * @type {number}
     * @memberof FileFileRemote
     */
    rate_limit?: number | null;
}
/**
 * Serializer for File Remotes.
 * @export
 * @interface FileFileRemoteResponse
 */
export interface FileFileRemoteResponse {
    /**
     * 
     * @type {string}
     * @memberof FileFileRemoteResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof FileFileRemoteResponse
     */
    pulp_created?: string;
    /**
     * A unique name for this remote.
     * @type {string}
     * @memberof FileFileRemoteResponse
     */
    name: string;
    /**
     * The URL of an external content source.
     * @type {string}
     * @memberof FileFileRemoteResponse
     */
    url: string;
    /**
     * A PEM encoded CA certificate used to validate the server certificate presented by the remote server.
     * @type {string}
     * @memberof FileFileRemoteResponse
     */
    ca_cert?: string | null;
    /**
     * A PEM encoded client certificate used for authentication.
     * @type {string}
     * @memberof FileFileRemoteResponse
     */
    client_cert?: string | null;
    /**
     * If True, TLS peer validation must be performed.
     * @type {boolean}
     * @memberof FileFileRemoteResponse
     */
    tls_validation?: boolean;
    /**
     * The proxy URL. Format: scheme://host:port
     * @type {string}
     * @memberof FileFileRemoteResponse
     */
    proxy_url?: string | null;
    /**
     * 
     * @type {object}
     * @memberof FileFileRemoteResponse
     */
    pulp_labels?: object;
    /**
     * Timestamp of the most recent update of the remote.
     * @type {string}
     * @memberof FileFileRemoteResponse
     */
    pulp_last_updated?: string;
    /**
     * Total number of simultaneous connections. If not set then the default value will be used.
     * @type {number}
     * @memberof FileFileRemoteResponse
     */
    download_concurrency?: number | null;
    /**
     * Maximum number of retry attempts after a download failure. If not set then the default value (3) will be used.
     * @type {number}
     * @memberof FileFileRemoteResponse
     */
    max_retries?: number | null;
    /**
     * The policy to use when downloading content. The possible values include: \'immediate\', \'on_demand\', and \'streamed\'. \'immediate\' is the default.
     * @type {PolicyEnum}
     * @memberof FileFileRemoteResponse
     */
    policy?: PolicyEnum;
    /**
     * aiohttp.ClientTimeout.total (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof FileFileRemoteResponse
     */
    total_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.connect (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof FileFileRemoteResponse
     */
    connect_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.sock_connect (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof FileFileRemoteResponse
     */
    sock_connect_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.sock_read (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof FileFileRemoteResponse
     */
    sock_read_timeout?: number | null;
    /**
     * Headers for aiohttp.Clientsession
     * @type {Array<object>}
     * @memberof FileFileRemoteResponse
     */
    headers?: Array<object>;
    /**
     * Limits total download rate in requests per second
     * @type {number}
     * @memberof FileFileRemoteResponse
     */
    rate_limit?: number | null;
}
/**
 * Serializer for File Repositories.
 * @export
 * @interface FileFileRepository
 */
export interface FileFileRepository {
    /**
     * 
     * @type {object}
     * @memberof FileFileRepository
     */
    pulp_labels?: object;
    /**
     * A unique name for this repository.
     * @type {string}
     * @memberof FileFileRepository
     */
    name: string;
    /**
     * An optional description.
     * @type {string}
     * @memberof FileFileRepository
     */
    description?: string | null;
    /**
     * Retain X versions of the repository. Default is null which retains all versions. This is provided as a tech preview in Pulp 3 and may change in the future.
     * @type {number}
     * @memberof FileFileRepository
     */
    retain_repo_versions?: number | null;
    /**
     * An optional remote to use by default when syncing.
     * @type {string}
     * @memberof FileFileRepository
     */
    remote?: string | null;
    /**
     * Whether to automatically create publications for new repository versions, and update any distributions pointing to this repository.
     * @type {boolean}
     * @memberof FileFileRepository
     */
    autopublish?: boolean;
    /**
     * Filename to use for manifest file containing metadata for all the files.
     * @type {string}
     * @memberof FileFileRepository
     */
    manifest?: string;
}
/**
 * Serializer for File Repositories.
 * @export
 * @interface FileFileRepositoryResponse
 */
export interface FileFileRepositoryResponse {
    /**
     * 
     * @type {string}
     * @memberof FileFileRepositoryResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof FileFileRepositoryResponse
     */
    pulp_created?: string;
    /**
     * 
     * @type {string}
     * @memberof FileFileRepositoryResponse
     */
    versions_href?: string;
    /**
     * 
     * @type {object}
     * @memberof FileFileRepositoryResponse
     */
    pulp_labels?: object;
    /**
     * 
     * @type {string}
     * @memberof FileFileRepositoryResponse
     */
    latest_version_href?: string;
    /**
     * A unique name for this repository.
     * @type {string}
     * @memberof FileFileRepositoryResponse
     */
    name: string;
    /**
     * An optional description.
     * @type {string}
     * @memberof FileFileRepositoryResponse
     */
    description?: string | null;
    /**
     * Retain X versions of the repository. Default is null which retains all versions. This is provided as a tech preview in Pulp 3 and may change in the future.
     * @type {number}
     * @memberof FileFileRepositoryResponse
     */
    retain_repo_versions?: number | null;
    /**
     * An optional remote to use by default when syncing.
     * @type {string}
     * @memberof FileFileRepositoryResponse
     */
    remote?: string | null;
    /**
     * Whether to automatically create publications for new repository versions, and update any distributions pointing to this repository.
     * @type {boolean}
     * @memberof FileFileRepositoryResponse
     */
    autopublish?: boolean;
    /**
     * Filename to use for manifest file containing metadata for all the files.
     * @type {string}
     * @memberof FileFileRepositoryResponse
     */
    manifest?: string;
}
/**
 * 
 * @export
 * @interface PaginatedRepositoryVersionResponseList
 */
export interface PaginatedRepositoryVersionResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRepositoryVersionResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRepositoryVersionResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRepositoryVersionResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RepositoryVersionResponse>}
     * @memberof PaginatedRepositoryVersionResponseList
     */
    results?: Array<RepositoryVersionResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedfileFileAlternateContentSourceResponseList
 */
export interface PaginatedfileFileAlternateContentSourceResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedfileFileAlternateContentSourceResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedfileFileAlternateContentSourceResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedfileFileAlternateContentSourceResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<FileFileAlternateContentSourceResponse>}
     * @memberof PaginatedfileFileAlternateContentSourceResponseList
     */
    results?: Array<FileFileAlternateContentSourceResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedfileFileContentResponseList
 */
export interface PaginatedfileFileContentResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedfileFileContentResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedfileFileContentResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedfileFileContentResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<FileFileContentResponse>}
     * @memberof PaginatedfileFileContentResponseList
     */
    results?: Array<FileFileContentResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedfileFileDistributionResponseList
 */
export interface PaginatedfileFileDistributionResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedfileFileDistributionResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedfileFileDistributionResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedfileFileDistributionResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<FileFileDistributionResponse>}
     * @memberof PaginatedfileFileDistributionResponseList
     */
    results?: Array<FileFileDistributionResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedfileFilePublicationResponseList
 */
export interface PaginatedfileFilePublicationResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedfileFilePublicationResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedfileFilePublicationResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedfileFilePublicationResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<FileFilePublicationResponse>}
     * @memberof PaginatedfileFilePublicationResponseList
     */
    results?: Array<FileFilePublicationResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedfileFileRemoteResponseList
 */
export interface PaginatedfileFileRemoteResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedfileFileRemoteResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedfileFileRemoteResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedfileFileRemoteResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<FileFileRemoteResponse>}
     * @memberof PaginatedfileFileRemoteResponseList
     */
    results?: Array<FileFileRemoteResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedfileFileRepositoryResponseList
 */
export interface PaginatedfileFileRepositoryResponseList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedfileFileRepositoryResponseList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedfileFileRepositoryResponseList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedfileFileRepositoryResponseList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<FileFileRepositoryResponse>}
     * @memberof PaginatedfileFileRepositoryResponseList
     */
    results?: Array<FileFileRepositoryResponse>;
}
/**
 * Serializer for File alternate content source.
 * @export
 * @interface PatchedfileFileAlternateContentSource
 */
export interface PatchedfileFileAlternateContentSource {
    /**
     * Name of Alternate Content Source.
     * @type {string}
     * @memberof PatchedfileFileAlternateContentSource
     */
    name?: string;
    /**
     * Date of last refresh of AlternateContentSource.
     * @type {string}
     * @memberof PatchedfileFileAlternateContentSource
     */
    last_refreshed?: string | null;
    /**
     * List of paths that will be appended to the Remote url when searching for content.
     * @type {Array<string>}
     * @memberof PatchedfileFileAlternateContentSource
     */
    paths?: Array<string>;
    /**
     * The remote to provide alternate content source.
     * @type {string}
     * @memberof PatchedfileFileAlternateContentSource
     */
    remote?: string;
}
/**
 * Serializer for File Distributions.
 * @export
 * @interface PatchedfileFileDistribution
 */
export interface PatchedfileFileDistribution {
    /**
     * The base (relative) path component of the published url. Avoid paths that                     overlap with other distribution base paths (e.g. \"foo\" and \"foo/bar\")
     * @type {string}
     * @memberof PatchedfileFileDistribution
     */
    base_path?: string;
    /**
     * An optional content-guard.
     * @type {string}
     * @memberof PatchedfileFileDistribution
     */
    content_guard?: string | null;
    /**
     * 
     * @type {object}
     * @memberof PatchedfileFileDistribution
     */
    pulp_labels?: object;
    /**
     * A unique name. Ex, `rawhide` and `stable`.
     * @type {string}
     * @memberof PatchedfileFileDistribution
     */
    name?: string;
    /**
     * The latest RepositoryVersion for this Repository will be served.
     * @type {string}
     * @memberof PatchedfileFileDistribution
     */
    repository?: string | null;
    /**
     * Publication to be served
     * @type {string}
     * @memberof PatchedfileFileDistribution
     */
    publication?: string | null;
}
/**
 * Serializer for File Remotes.
 * @export
 * @interface PatchedfileFileRemote
 */
export interface PatchedfileFileRemote {
    /**
     * A unique name for this remote.
     * @type {string}
     * @memberof PatchedfileFileRemote
     */
    name?: string;
    /**
     * The URL of an external content source.
     * @type {string}
     * @memberof PatchedfileFileRemote
     */
    url?: string;
    /**
     * A PEM encoded CA certificate used to validate the server certificate presented by the remote server.
     * @type {string}
     * @memberof PatchedfileFileRemote
     */
    ca_cert?: string | null;
    /**
     * A PEM encoded client certificate used for authentication.
     * @type {string}
     * @memberof PatchedfileFileRemote
     */
    client_cert?: string | null;
    /**
     * A PEM encoded private key used for authentication.
     * @type {string}
     * @memberof PatchedfileFileRemote
     */
    client_key?: string | null;
    /**
     * If True, TLS peer validation must be performed.
     * @type {boolean}
     * @memberof PatchedfileFileRemote
     */
    tls_validation?: boolean;
    /**
     * The proxy URL. Format: scheme://host:port
     * @type {string}
     * @memberof PatchedfileFileRemote
     */
    proxy_url?: string | null;
    /**
     * The username to authenticte to the proxy.
     * @type {string}
     * @memberof PatchedfileFileRemote
     */
    proxy_username?: string | null;
    /**
     * The password to authenticte to the proxy.
     * @type {string}
     * @memberof PatchedfileFileRemote
     */
    proxy_password?: string | null;
    /**
     * The username to be used for authentication when syncing.
     * @type {string}
     * @memberof PatchedfileFileRemote
     */
    username?: string | null;
    /**
     * The password to be used for authentication when syncing.
     * @type {string}
     * @memberof PatchedfileFileRemote
     */
    password?: string | null;
    /**
     * 
     * @type {object}
     * @memberof PatchedfileFileRemote
     */
    pulp_labels?: object;
    /**
     * Total number of simultaneous connections. If not set then the default value will be used.
     * @type {number}
     * @memberof PatchedfileFileRemote
     */
    download_concurrency?: number | null;
    /**
     * Maximum number of retry attempts after a download failure. If not set then the default value (3) will be used.
     * @type {number}
     * @memberof PatchedfileFileRemote
     */
    max_retries?: number | null;
    /**
     * The policy to use when downloading content. The possible values include: \'immediate\', \'on_demand\', and \'streamed\'. \'immediate\' is the default.
     * @type {PolicyEnum}
     * @memberof PatchedfileFileRemote
     */
    policy?: PolicyEnum;
    /**
     * aiohttp.ClientTimeout.total (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof PatchedfileFileRemote
     */
    total_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.connect (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof PatchedfileFileRemote
     */
    connect_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.sock_connect (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof PatchedfileFileRemote
     */
    sock_connect_timeout?: number | null;
    /**
     * aiohttp.ClientTimeout.sock_read (q.v.) for download-connections. The default is null, which will cause the default from the aiohttp library to be used.
     * @type {number}
     * @memberof PatchedfileFileRemote
     */
    sock_read_timeout?: number | null;
    /**
     * Headers for aiohttp.Clientsession
     * @type {Array<object>}
     * @memberof PatchedfileFileRemote
     */
    headers?: Array<object>;
    /**
     * Limits total download rate in requests per second
     * @type {number}
     * @memberof PatchedfileFileRemote
     */
    rate_limit?: number | null;
}
/**
 * Serializer for File Repositories.
 * @export
 * @interface PatchedfileFileRepository
 */
export interface PatchedfileFileRepository {
    /**
     * 
     * @type {object}
     * @memberof PatchedfileFileRepository
     */
    pulp_labels?: object;
    /**
     * A unique name for this repository.
     * @type {string}
     * @memberof PatchedfileFileRepository
     */
    name?: string;
    /**
     * An optional description.
     * @type {string}
     * @memberof PatchedfileFileRepository
     */
    description?: string | null;
    /**
     * Retain X versions of the repository. Default is null which retains all versions. This is provided as a tech preview in Pulp 3 and may change in the future.
     * @type {number}
     * @memberof PatchedfileFileRepository
     */
    retain_repo_versions?: number | null;
    /**
     * An optional remote to use by default when syncing.
     * @type {string}
     * @memberof PatchedfileFileRepository
     */
    remote?: string | null;
    /**
     * Whether to automatically create publications for new repository versions, and update any distributions pointing to this repository.
     * @type {boolean}
     * @memberof PatchedfileFileRepository
     */
    autopublish?: boolean;
    /**
     * Filename to use for manifest file containing metadata for all the files.
     * @type {string}
     * @memberof PatchedfileFileRepository
     */
    manifest?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum PolicyEnum {
    Immediate = 'immediate',
    OnDemand = 'on_demand',
    Streamed = 'streamed'
}

/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface RepositoryAddRemoveContent
 */
export interface RepositoryAddRemoveContent {
    /**
     * A list of content units to add to a new repository version. This content is added after remove_content_units are removed.
     * @type {Array<any>}
     * @memberof RepositoryAddRemoveContent
     */
    add_content_units?: Array<any>;
    /**
     * A list of content units to remove from the latest repository version. You may also specify \'*\' as an entry to remove all content. This content is removed before add_content_units are added.
     * @type {Array<any>}
     * @memberof RepositoryAddRemoveContent
     */
    remove_content_units?: Array<any>;
    /**
     * A repository version whose content will be used as the initial set of content for the new repository version
     * @type {string}
     * @memberof RepositoryAddRemoveContent
     */
    base_version?: string;
}
/**
 * A mixin for validating unknown serializers\' fields.
 * @export
 * @interface RepositorySyncURL
 */
export interface RepositorySyncURL {
    /**
     * A remote to sync from. This will override a remote set on repository.
     * @type {string}
     * @memberof RepositorySyncURL
     */
    remote?: string;
    /**
     * If ``True``, synchronization will remove all content that is not present in the remote repository. If ``False``, sync will be additive only.
     * @type {boolean}
     * @memberof RepositorySyncURL
     */
    mirror?: boolean;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface RepositoryVersion
 */
export interface RepositoryVersion {
    /**
     * A repository version whose content was used as the initial set of content for this repository version
     * @type {string}
     * @memberof RepositoryVersion
     */
    base_version?: string;
}
/**
 * Base serializer for use with :class:`pulpcore.app.models.Model`  This ensures that all Serializers provide values for the \'pulp_href` field.  The class provides a default for the ``ref_name`` attribute in the ModelSerializers\'s ``Meta`` class. This ensures that the OpenAPI definitions of plugins are namespaced properly.
 * @export
 * @interface RepositoryVersionResponse
 */
export interface RepositoryVersionResponse {
    /**
     * 
     * @type {string}
     * @memberof RepositoryVersionResponse
     */
    pulp_href?: string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof RepositoryVersionResponse
     */
    pulp_created?: string;
    /**
     * 
     * @type {number}
     * @memberof RepositoryVersionResponse
     */
    number?: number;
    /**
     * 
     * @type {string}
     * @memberof RepositoryVersionResponse
     */
    repository?: string;
    /**
     * A repository version whose content was used as the initial set of content for this repository version
     * @type {string}
     * @memberof RepositoryVersionResponse
     */
    base_version?: string;
    /**
     * Various count summaries of the content in the version and the HREF to view them.
     * @type {ContentSummaryResponse}
     * @memberof RepositoryVersionResponse
     */
    content_summary?: ContentSummaryResponse;
}

/**
 * AcsFileApi - axios parameter creator
 * @export
 */
export const AcsFileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
         * @summary Delete a file alternate content source
         * @param {string} fileFileAlternateContentSourceHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (fileFileAlternateContentSourceHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileAlternateContentSourceHref' is not null or undefined
            assertParamExists('_delete', 'fileFileAlternateContentSourceHref', fileFileAlternateContentSourceHref)
            const localVarPath = `{file_file_alternate_content_source_href}`
                .replace(`{${"file_file_alternate_content_source_href"}}`, String(fileFileAlternateContentSourceHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
         * @summary Create a file alternate content source
         * @param {FileFileAlternateContentSource} fileFileAlternateContentSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (fileFileAlternateContentSource: FileFileAlternateContentSource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileAlternateContentSource' is not null or undefined
            assertParamExists('create', 'fileFileAlternateContentSource', fileFileAlternateContentSource)
            const localVarPath = `/pulp/api/v3/acs/file/file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileFileAlternateContentSource, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
         * @summary List file alternate content sources
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/acs/file/file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIn) {
                localVarQueryParameter['name__in'] = nameIn.join(COLLECTION_FORMATS.csv);
            }

            if (nameStartswith !== undefined) {
                localVarQueryParameter['name__startswith'] = nameStartswith;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
         * @summary Update a file alternate content source
         * @param {string} fileFileAlternateContentSourceHref 
         * @param {PatchedfileFileAlternateContentSource} patchedfileFileAlternateContentSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate: async (fileFileAlternateContentSourceHref: string, patchedfileFileAlternateContentSource: PatchedfileFileAlternateContentSource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileAlternateContentSourceHref' is not null or undefined
            assertParamExists('partialUpdate', 'fileFileAlternateContentSourceHref', fileFileAlternateContentSourceHref)
            // verify required parameter 'patchedfileFileAlternateContentSource' is not null or undefined
            assertParamExists('partialUpdate', 'patchedfileFileAlternateContentSource', patchedfileFileAlternateContentSource)
            const localVarPath = `{file_file_alternate_content_source_href}`
                .replace(`{${"file_file_alternate_content_source_href"}}`, String(fileFileAlternateContentSourceHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedfileFileAlternateContentSource, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
         * @summary Inspect a file alternate content source
         * @param {string} fileFileAlternateContentSourceHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (fileFileAlternateContentSourceHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileAlternateContentSourceHref' is not null or undefined
            assertParamExists('read', 'fileFileAlternateContentSourceHref', fileFileAlternateContentSourceHref)
            const localVarPath = `{file_file_alternate_content_source_href}`
                .replace(`{${"file_file_alternate_content_source_href"}}`, String(fileFileAlternateContentSourceHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
         * @param {string} fileFileAlternateContentSourceHref 
         * @param {FileFileAlternateContentSource} fileFileAlternateContentSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh: async (fileFileAlternateContentSourceHref: string, fileFileAlternateContentSource: FileFileAlternateContentSource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileAlternateContentSourceHref' is not null or undefined
            assertParamExists('refresh', 'fileFileAlternateContentSourceHref', fileFileAlternateContentSourceHref)
            // verify required parameter 'fileFileAlternateContentSource' is not null or undefined
            assertParamExists('refresh', 'fileFileAlternateContentSource', fileFileAlternateContentSource)
            const localVarPath = `{file_file_alternate_content_source_href}refresh/`
                .replace(`{${"file_file_alternate_content_source_href"}}`, String(fileFileAlternateContentSourceHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileFileAlternateContentSource, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
         * @summary Update a file alternate content source
         * @param {string} fileFileAlternateContentSourceHref 
         * @param {FileFileAlternateContentSource} fileFileAlternateContentSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (fileFileAlternateContentSourceHref: string, fileFileAlternateContentSource: FileFileAlternateContentSource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileAlternateContentSourceHref' is not null or undefined
            assertParamExists('update', 'fileFileAlternateContentSourceHref', fileFileAlternateContentSourceHref)
            // verify required parameter 'fileFileAlternateContentSource' is not null or undefined
            assertParamExists('update', 'fileFileAlternateContentSource', fileFileAlternateContentSource)
            const localVarPath = `{file_file_alternate_content_source_href}`
                .replace(`{${"file_file_alternate_content_source_href"}}`, String(fileFileAlternateContentSourceHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileFileAlternateContentSource, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AcsFileApi - functional programming interface
 * @export
 */
export const AcsFileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AcsFileApiAxiosParamCreator(configuration)
    return {
        /**
         * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
         * @summary Delete a file alternate content source
         * @param {string} fileFileAlternateContentSourceHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(fileFileAlternateContentSourceHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(fileFileAlternateContentSourceHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
         * @summary Create a file alternate content source
         * @param {FileFileAlternateContentSource} fileFileAlternateContentSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(fileFileAlternateContentSource: FileFileAlternateContentSource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFileAlternateContentSourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(fileFileAlternateContentSource, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
         * @summary List file alternate content sources
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedfileFileAlternateContentSourceResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
         * @summary Update a file alternate content source
         * @param {string} fileFileAlternateContentSourceHref 
         * @param {PatchedfileFileAlternateContentSource} patchedfileFileAlternateContentSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdate(fileFileAlternateContentSourceHref: string, patchedfileFileAlternateContentSource: PatchedfileFileAlternateContentSource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFileAlternateContentSourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdate(fileFileAlternateContentSourceHref, patchedfileFileAlternateContentSource, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
         * @summary Inspect a file alternate content source
         * @param {string} fileFileAlternateContentSourceHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(fileFileAlternateContentSourceHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFileAlternateContentSourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(fileFileAlternateContentSourceHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
         * @param {string} fileFileAlternateContentSourceHref 
         * @param {FileFileAlternateContentSource} fileFileAlternateContentSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refresh(fileFileAlternateContentSourceHref: string, fileFileAlternateContentSource: FileFileAlternateContentSource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFileAlternateContentSourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refresh(fileFileAlternateContentSourceHref, fileFileAlternateContentSource, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
         * @summary Update a file alternate content source
         * @param {string} fileFileAlternateContentSourceHref 
         * @param {FileFileAlternateContentSource} fileFileAlternateContentSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(fileFileAlternateContentSourceHref: string, fileFileAlternateContentSource: FileFileAlternateContentSource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFileAlternateContentSourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(fileFileAlternateContentSourceHref, fileFileAlternateContentSource, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AcsFileApi - factory interface
 * @export
 */
export const AcsFileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AcsFileApiFp(configuration)
    return {
        /**
         * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
         * @summary Delete a file alternate content source
         * @param {string} fileFileAlternateContentSourceHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(fileFileAlternateContentSourceHref: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(fileFileAlternateContentSourceHref, options).then((request) => request(axios, basePath));
        },
        /**
         * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
         * @summary Create a file alternate content source
         * @param {FileFileAlternateContentSource} fileFileAlternateContentSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(fileFileAlternateContentSource: FileFileAlternateContentSource, options?: any): AxiosPromise<FileFileAlternateContentSourceResponse> {
            return localVarFp.create(fileFileAlternateContentSource, options).then((request) => request(axios, basePath));
        },
        /**
         * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
         * @summary List file alternate content sources
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedfileFileAlternateContentSourceResponseList> {
            return localVarFp.list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
         * @summary Update a file alternate content source
         * @param {string} fileFileAlternateContentSourceHref 
         * @param {PatchedfileFileAlternateContentSource} patchedfileFileAlternateContentSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate(fileFileAlternateContentSourceHref: string, patchedfileFileAlternateContentSource: PatchedfileFileAlternateContentSource, options?: any): AxiosPromise<FileFileAlternateContentSourceResponse> {
            return localVarFp.partialUpdate(fileFileAlternateContentSourceHref, patchedfileFileAlternateContentSource, options).then((request) => request(axios, basePath));
        },
        /**
         * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
         * @summary Inspect a file alternate content source
         * @param {string} fileFileAlternateContentSourceHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(fileFileAlternateContentSourceHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<FileFileAlternateContentSourceResponse> {
            return localVarFp.read(fileFileAlternateContentSourceHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
         * @param {string} fileFileAlternateContentSourceHref 
         * @param {FileFileAlternateContentSource} fileFileAlternateContentSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh(fileFileAlternateContentSourceHref: string, fileFileAlternateContentSource: FileFileAlternateContentSource, options?: any): AxiosPromise<FileFileAlternateContentSourceResponse> {
            return localVarFp.refresh(fileFileAlternateContentSourceHref, fileFileAlternateContentSource, options).then((request) => request(axios, basePath));
        },
        /**
         * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
         * @summary Update a file alternate content source
         * @param {string} fileFileAlternateContentSourceHref 
         * @param {FileFileAlternateContentSource} fileFileAlternateContentSource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(fileFileAlternateContentSourceHref: string, fileFileAlternateContentSource: FileFileAlternateContentSource, options?: any): AxiosPromise<FileFileAlternateContentSourceResponse> {
            return localVarFp.update(fileFileAlternateContentSourceHref, fileFileAlternateContentSource, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AcsFileApi - object-oriented interface
 * @export
 * @class AcsFileApi
 * @extends {BaseAPI}
 */
export class AcsFileApi extends BaseAPI {
    /**
     * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
     * @summary Delete a file alternate content source
     * @param {string} fileFileAlternateContentSourceHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AcsFileApi
     */
    public _delete(fileFileAlternateContentSourceHref: string, options?: any) {
        return AcsFileApiFp(this.configuration)._delete(fileFileAlternateContentSourceHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
     * @summary Create a file alternate content source
     * @param {FileFileAlternateContentSource} fileFileAlternateContentSource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AcsFileApi
     */
    public create(fileFileAlternateContentSource: FileFileAlternateContentSource, options?: any) {
        return AcsFileApiFp(this.configuration).create(fileFileAlternateContentSource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
     * @summary List file alternate content sources
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] 
     * @param {string} [nameContains] Filter results where name contains value
     * @param {string} [nameIcontains] Filter results where name contains value
     * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
     * @param {string} [nameStartswith] Filter results where name starts with value
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AcsFileApi
     */
    public list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, fields?: string, excludeFields?: string, options?: any) {
        return AcsFileApiFp(this.configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
     * @summary Update a file alternate content source
     * @param {string} fileFileAlternateContentSourceHref 
     * @param {PatchedfileFileAlternateContentSource} patchedfileFileAlternateContentSource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AcsFileApi
     */
    public partialUpdate(fileFileAlternateContentSourceHref: string, patchedfileFileAlternateContentSource: PatchedfileFileAlternateContentSource, options?: any) {
        return AcsFileApiFp(this.configuration).partialUpdate(fileFileAlternateContentSourceHref, patchedfileFileAlternateContentSource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
     * @summary Inspect a file alternate content source
     * @param {string} fileFileAlternateContentSourceHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AcsFileApi
     */
    public read(fileFileAlternateContentSourceHref: string, fields?: string, excludeFields?: string, options?: any) {
        return AcsFileApiFp(this.configuration).read(fileFileAlternateContentSourceHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
     * @param {string} fileFileAlternateContentSourceHref 
     * @param {FileFileAlternateContentSource} fileFileAlternateContentSource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AcsFileApi
     */
    public refresh(fileFileAlternateContentSourceHref: string, fileFileAlternateContentSource: FileFileAlternateContentSource, options?: any) {
        return AcsFileApiFp(this.configuration).refresh(fileFileAlternateContentSourceHref, fileFileAlternateContentSource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Alternate Content Source ViewSet for File  ACS support is provided as a tech preview in pulp_file.
     * @summary Update a file alternate content source
     * @param {string} fileFileAlternateContentSourceHref 
     * @param {FileFileAlternateContentSource} fileFileAlternateContentSource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AcsFileApi
     */
    public update(fileFileAlternateContentSourceHref: string, fileFileAlternateContentSource: FileFileAlternateContentSource, options?: any) {
        return AcsFileApiFp(this.configuration).update(fileFileAlternateContentSourceHref, fileFileAlternateContentSource, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentFilesApi - axios parameter creator
 * @export
 */
export const ContentFilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous task to create content,optionally create new repository version.
         * @summary Create a file content
         * @param {string} relativePath Path where the artifact is located relative to distributions base_path
         * @param {string} [artifact] Artifact file representing the physical content
         * @param {any} [file] An uploaded file that may be turned into the artifact of the content unit.
         * @param {string} [repository] A URI of a repository the new content unit should be associated with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (relativePath: string, artifact?: string, file?: any, repository?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'relativePath' is not null or undefined
            assertParamExists('create', 'relativePath', relativePath)
            const localVarPath = `/pulp/api/v3/content/file/files/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


            if (artifact !== undefined) { 
                localVarFormParams.append('artifact', artifact as any);
            }
    
            if (relativePath !== undefined) { 
                localVarFormParams.append('relative_path', relativePath as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (repository !== undefined) { 
                localVarFormParams.append('repository', repository as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  FileContent represents a single file and its metadata, which can be added and removed from repositories.
         * @summary List file contents
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [relativePath] Filter results where relative_path matches value
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [sha256] 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, ordering?: string, relativePath?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, sha256?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/content/file/files/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (relativePath !== undefined) {
                localVarQueryParameter['relative_path'] = relativePath;
            }

            if (repositoryVersion !== undefined) {
                localVarQueryParameter['repository_version'] = repositoryVersion;
            }

            if (repositoryVersionAdded !== undefined) {
                localVarQueryParameter['repository_version_added'] = repositoryVersionAdded;
            }

            if (repositoryVersionRemoved !== undefined) {
                localVarQueryParameter['repository_version_removed'] = repositoryVersionRemoved;
            }

            if (sha256 !== undefined) {
                localVarQueryParameter['sha256'] = sha256;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  FileContent represents a single file and its metadata, which can be added and removed from repositories.
         * @summary Inspect a file content
         * @param {string} fileFileContentHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (fileFileContentHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileContentHref' is not null or undefined
            assertParamExists('read', 'fileFileContentHref', fileFileContentHref)
            const localVarPath = `{file_file_content_href}`
                .replace(`{${"file_file_content_href"}}`, String(fileFileContentHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentFilesApi - functional programming interface
 * @export
 */
export const ContentFilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentFilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Trigger an asynchronous task to create content,optionally create new repository version.
         * @summary Create a file content
         * @param {string} relativePath Path where the artifact is located relative to distributions base_path
         * @param {string} [artifact] Artifact file representing the physical content
         * @param {any} [file] An uploaded file that may be turned into the artifact of the content unit.
         * @param {string} [repository] A URI of a repository the new content unit should be associated with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(relativePath: string, artifact?: string, file?: any, repository?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(relativePath, artifact, file, repository, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  FileContent represents a single file and its metadata, which can be added and removed from repositories.
         * @summary List file contents
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [relativePath] Filter results where relative_path matches value
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [sha256] 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, ordering?: string, relativePath?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, sha256?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedfileFileContentResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, offset, ordering, relativePath, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, sha256, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  FileContent represents a single file and its metadata, which can be added and removed from repositories.
         * @summary Inspect a file content
         * @param {string} fileFileContentHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(fileFileContentHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFileContentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(fileFileContentHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContentFilesApi - factory interface
 * @export
 */
export const ContentFilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentFilesApiFp(configuration)
    return {
        /**
         * Trigger an asynchronous task to create content,optionally create new repository version.
         * @summary Create a file content
         * @param {string} relativePath Path where the artifact is located relative to distributions base_path
         * @param {string} [artifact] Artifact file representing the physical content
         * @param {any} [file] An uploaded file that may be turned into the artifact of the content unit.
         * @param {string} [repository] A URI of a repository the new content unit should be associated with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(relativePath: string, artifact?: string, file?: any, repository?: string, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.create(relativePath, artifact, file, repository, options).then((request) => request(axios, basePath));
        },
        /**
         *  FileContent represents a single file and its metadata, which can be added and removed from repositories.
         * @summary List file contents
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [relativePath] Filter results where relative_path matches value
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
         * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
         * @param {string} [sha256] 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, ordering?: string, relativePath?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, sha256?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedfileFileContentResponseList> {
            return localVarFp.list(limit, offset, ordering, relativePath, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, sha256, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         *  FileContent represents a single file and its metadata, which can be added and removed from repositories.
         * @summary Inspect a file content
         * @param {string} fileFileContentHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(fileFileContentHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<FileFileContentResponse> {
            return localVarFp.read(fileFileContentHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentFilesApi - object-oriented interface
 * @export
 * @class ContentFilesApi
 * @extends {BaseAPI}
 */
export class ContentFilesApi extends BaseAPI {
    /**
     * Trigger an asynchronous task to create content,optionally create new repository version.
     * @summary Create a file content
     * @param {string} relativePath Path where the artifact is located relative to distributions base_path
     * @param {string} [artifact] Artifact file representing the physical content
     * @param {any} [file] An uploaded file that may be turned into the artifact of the content unit.
     * @param {string} [repository] A URI of a repository the new content unit should be associated with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentFilesApi
     */
    public create(relativePath: string, artifact?: string, file?: any, repository?: string, options?: any) {
        return ContentFilesApiFp(this.configuration).create(relativePath, artifact, file, repository, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  FileContent represents a single file and its metadata, which can be added and removed from repositories.
     * @summary List file contents
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [relativePath] Filter results where relative_path matches value
     * @param {string} [repositoryVersion] Repository Version referenced by HREF
     * @param {string} [repositoryVersionAdded] Repository Version referenced by HREF
     * @param {string} [repositoryVersionRemoved] Repository Version referenced by HREF
     * @param {string} [sha256] 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentFilesApi
     */
    public list(limit?: number, offset?: number, ordering?: string, relativePath?: string, repositoryVersion?: string, repositoryVersionAdded?: string, repositoryVersionRemoved?: string, sha256?: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentFilesApiFp(this.configuration).list(limit, offset, ordering, relativePath, repositoryVersion, repositoryVersionAdded, repositoryVersionRemoved, sha256, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  FileContent represents a single file and its metadata, which can be added and removed from repositories.
     * @summary Inspect a file content
     * @param {string} fileFileContentHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentFilesApi
     */
    public read(fileFileContentHref: string, fields?: string, excludeFields?: string, options?: any) {
        return ContentFilesApiFp(this.configuration).read(fileFileContentHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DistributionsFileApi - axios parameter creator
 * @export
 */
export const DistributionsFileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a file distribution
         * @param {string} fileFileDistributionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (fileFileDistributionHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileDistributionHref' is not null or undefined
            assertParamExists('_delete', 'fileFileDistributionHref', fileFileDistributionHref)
            const localVarPath = `{file_file_distribution_href}`
                .replace(`{${"file_file_distribution_href"}}`, String(fileFileDistributionHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous create task
         * @summary Create a file distribution
         * @param {FileFileDistribution} fileFileDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (fileFileDistribution: FileFileDistribution, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileDistribution' is not null or undefined
            assertParamExists('create', 'fileFileDistribution', fileFileDistribution)
            const localVarPath = `/pulp/api/v3/distributions/file/file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileFileDistribution, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  FileDistributions host File Publications which makes the metadata and the referenced File Content available to HTTP clients. Additionally, a FileDistribution with an associated FilePublication can be the target url of a File Remote , allowing another instance of Pulp to sync the content.
         * @summary List file distributions
         * @param {string} [basePath] 
         * @param {string} [basePathContains] Filter results where base_path contains value
         * @param {string} [basePathIcontains] Filter results where base_path contains value
         * @param {Array<string>} [basePathIn] Filter results where base_path is in a comma-separated list of values
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] Filter labels by search string
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (basePath?: string, basePathContains?: string, basePathIcontains?: string, basePathIn?: Array<string>, limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/distributions/file/file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (basePath !== undefined) {
                localVarQueryParameter['base_path'] = basePath;
            }

            if (basePathContains !== undefined) {
                localVarQueryParameter['base_path__contains'] = basePathContains;
            }

            if (basePathIcontains !== undefined) {
                localVarQueryParameter['base_path__icontains'] = basePathIcontains;
            }

            if (basePathIn) {
                localVarQueryParameter['base_path__in'] = basePathIn.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIn) {
                localVarQueryParameter['name__in'] = nameIn.join(COLLECTION_FORMATS.csv);
            }

            if (nameStartswith !== undefined) {
                localVarQueryParameter['name__startswith'] = nameStartswith;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (pulpLabelSelect !== undefined) {
                localVarQueryParameter['pulp_label_select'] = pulpLabelSelect;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a file distribution
         * @param {string} fileFileDistributionHref 
         * @param {PatchedfileFileDistribution} patchedfileFileDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate: async (fileFileDistributionHref: string, patchedfileFileDistribution: PatchedfileFileDistribution, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileDistributionHref' is not null or undefined
            assertParamExists('partialUpdate', 'fileFileDistributionHref', fileFileDistributionHref)
            // verify required parameter 'patchedfileFileDistribution' is not null or undefined
            assertParamExists('partialUpdate', 'patchedfileFileDistribution', patchedfileFileDistribution)
            const localVarPath = `{file_file_distribution_href}`
                .replace(`{${"file_file_distribution_href"}}`, String(fileFileDistributionHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedfileFileDistribution, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  FileDistributions host File Publications which makes the metadata and the referenced File Content available to HTTP clients. Additionally, a FileDistribution with an associated FilePublication can be the target url of a File Remote , allowing another instance of Pulp to sync the content.
         * @summary Inspect a file distribution
         * @param {string} fileFileDistributionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (fileFileDistributionHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileDistributionHref' is not null or undefined
            assertParamExists('read', 'fileFileDistributionHref', fileFileDistributionHref)
            const localVarPath = `{file_file_distribution_href}`
                .replace(`{${"file_file_distribution_href"}}`, String(fileFileDistributionHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a file distribution
         * @param {string} fileFileDistributionHref 
         * @param {FileFileDistribution} fileFileDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (fileFileDistributionHref: string, fileFileDistribution: FileFileDistribution, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileDistributionHref' is not null or undefined
            assertParamExists('update', 'fileFileDistributionHref', fileFileDistributionHref)
            // verify required parameter 'fileFileDistribution' is not null or undefined
            assertParamExists('update', 'fileFileDistribution', fileFileDistribution)
            const localVarPath = `{file_file_distribution_href}`
                .replace(`{${"file_file_distribution_href"}}`, String(fileFileDistributionHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileFileDistribution, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DistributionsFileApi - functional programming interface
 * @export
 */
export const DistributionsFileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DistributionsFileApiAxiosParamCreator(configuration)
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a file distribution
         * @param {string} fileFileDistributionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(fileFileDistributionHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(fileFileDistributionHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous create task
         * @summary Create a file distribution
         * @param {FileFileDistribution} fileFileDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(fileFileDistribution: FileFileDistribution, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(fileFileDistribution, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  FileDistributions host File Publications which makes the metadata and the referenced File Content available to HTTP clients. Additionally, a FileDistribution with an associated FilePublication can be the target url of a File Remote , allowing another instance of Pulp to sync the content.
         * @summary List file distributions
         * @param {string} [basePath] 
         * @param {string} [basePathContains] Filter results where base_path contains value
         * @param {string} [basePathIcontains] Filter results where base_path contains value
         * @param {Array<string>} [basePathIn] Filter results where base_path is in a comma-separated list of values
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] Filter labels by search string
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(basePath?: string, basePathContains?: string, basePathIcontains?: string, basePathIn?: Array<string>, limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedfileFileDistributionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(basePath, basePathContains, basePathIcontains, basePathIn, limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a file distribution
         * @param {string} fileFileDistributionHref 
         * @param {PatchedfileFileDistribution} patchedfileFileDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdate(fileFileDistributionHref: string, patchedfileFileDistribution: PatchedfileFileDistribution, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdate(fileFileDistributionHref, patchedfileFileDistribution, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  FileDistributions host File Publications which makes the metadata and the referenced File Content available to HTTP clients. Additionally, a FileDistribution with an associated FilePublication can be the target url of a File Remote , allowing another instance of Pulp to sync the content.
         * @summary Inspect a file distribution
         * @param {string} fileFileDistributionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(fileFileDistributionHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFileDistributionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(fileFileDistributionHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a file distribution
         * @param {string} fileFileDistributionHref 
         * @param {FileFileDistribution} fileFileDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(fileFileDistributionHref: string, fileFileDistribution: FileFileDistribution, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(fileFileDistributionHref, fileFileDistribution, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DistributionsFileApi - factory interface
 * @export
 */
export const DistributionsFileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DistributionsFileApiFp(configuration)
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a file distribution
         * @param {string} fileFileDistributionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(fileFileDistributionHref: string, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp._delete(fileFileDistributionHref, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous create task
         * @summary Create a file distribution
         * @param {FileFileDistribution} fileFileDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(fileFileDistribution: FileFileDistribution, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.create(fileFileDistribution, options).then((request) => request(axios, basePath));
        },
        /**
         *  FileDistributions host File Publications which makes the metadata and the referenced File Content available to HTTP clients. Additionally, a FileDistribution with an associated FilePublication can be the target url of a File Remote , allowing another instance of Pulp to sync the content.
         * @summary List file distributions
         * @param {string} [basePath] 
         * @param {string} [basePathContains] Filter results where base_path contains value
         * @param {string} [basePathIcontains] Filter results where base_path contains value
         * @param {Array<string>} [basePathIn] Filter results where base_path is in a comma-separated list of values
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] Filter labels by search string
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(basePath?: string, basePathContains?: string, basePathIcontains?: string, basePathIn?: Array<string>, limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedfileFileDistributionResponseList> {
            return localVarFp.list(basePath, basePathContains, basePathIcontains, basePathIn, limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a file distribution
         * @param {string} fileFileDistributionHref 
         * @param {PatchedfileFileDistribution} patchedfileFileDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate(fileFileDistributionHref: string, patchedfileFileDistribution: PatchedfileFileDistribution, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.partialUpdate(fileFileDistributionHref, patchedfileFileDistribution, options).then((request) => request(axios, basePath));
        },
        /**
         *  FileDistributions host File Publications which makes the metadata and the referenced File Content available to HTTP clients. Additionally, a FileDistribution with an associated FilePublication can be the target url of a File Remote , allowing another instance of Pulp to sync the content.
         * @summary Inspect a file distribution
         * @param {string} fileFileDistributionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(fileFileDistributionHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<FileFileDistributionResponse> {
            return localVarFp.read(fileFileDistributionHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a file distribution
         * @param {string} fileFileDistributionHref 
         * @param {FileFileDistribution} fileFileDistribution 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(fileFileDistributionHref: string, fileFileDistribution: FileFileDistribution, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.update(fileFileDistributionHref, fileFileDistribution, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DistributionsFileApi - object-oriented interface
 * @export
 * @class DistributionsFileApi
 * @extends {BaseAPI}
 */
export class DistributionsFileApi extends BaseAPI {
    /**
     * Trigger an asynchronous delete task
     * @summary Delete a file distribution
     * @param {string} fileFileDistributionHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionsFileApi
     */
    public _delete(fileFileDistributionHref: string, options?: any) {
        return DistributionsFileApiFp(this.configuration)._delete(fileFileDistributionHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous create task
     * @summary Create a file distribution
     * @param {FileFileDistribution} fileFileDistribution 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionsFileApi
     */
    public create(fileFileDistribution: FileFileDistribution, options?: any) {
        return DistributionsFileApiFp(this.configuration).create(fileFileDistribution, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  FileDistributions host File Publications which makes the metadata and the referenced File Content available to HTTP clients. Additionally, a FileDistribution with an associated FilePublication can be the target url of a File Remote , allowing another instance of Pulp to sync the content.
     * @summary List file distributions
     * @param {string} [basePath] 
     * @param {string} [basePathContains] Filter results where base_path contains value
     * @param {string} [basePathIcontains] Filter results where base_path contains value
     * @param {Array<string>} [basePathIn] Filter results where base_path is in a comma-separated list of values
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] 
     * @param {string} [nameContains] Filter results where name contains value
     * @param {string} [nameIcontains] Filter results where name contains value
     * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
     * @param {string} [nameStartswith] Filter results where name starts with value
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [pulpLabelSelect] Filter labels by search string
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionsFileApi
     */
    public list(basePath?: string, basePathContains?: string, basePathIcontains?: string, basePathIn?: Array<string>, limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options?: any) {
        return DistributionsFileApiFp(this.configuration).list(basePath, basePathContains, basePathIcontains, basePathIn, limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous partial update task
     * @summary Update a file distribution
     * @param {string} fileFileDistributionHref 
     * @param {PatchedfileFileDistribution} patchedfileFileDistribution 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionsFileApi
     */
    public partialUpdate(fileFileDistributionHref: string, patchedfileFileDistribution: PatchedfileFileDistribution, options?: any) {
        return DistributionsFileApiFp(this.configuration).partialUpdate(fileFileDistributionHref, patchedfileFileDistribution, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  FileDistributions host File Publications which makes the metadata and the referenced File Content available to HTTP clients. Additionally, a FileDistribution with an associated FilePublication can be the target url of a File Remote , allowing another instance of Pulp to sync the content.
     * @summary Inspect a file distribution
     * @param {string} fileFileDistributionHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionsFileApi
     */
    public read(fileFileDistributionHref: string, fields?: string, excludeFields?: string, options?: any) {
        return DistributionsFileApiFp(this.configuration).read(fileFileDistributionHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous update task
     * @summary Update a file distribution
     * @param {string} fileFileDistributionHref 
     * @param {FileFileDistribution} fileFileDistribution 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DistributionsFileApi
     */
    public update(fileFileDistributionHref: string, fileFileDistribution: FileFileDistribution, options?: any) {
        return DistributionsFileApiFp(this.configuration).update(fileFileDistributionHref, fileFileDistribution, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PublicationsFileApi - axios parameter creator
 * @export
 */
export const PublicationsFileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  A FilePublication contains metadata about all the File Content in a particular File Repository Version. Once a FilePublication has been created, it can be hosted using the File Distribution API.
         * @summary Delete a file publication
         * @param {string} fileFilePublicationHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (fileFilePublicationHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFilePublicationHref' is not null or undefined
            assertParamExists('_delete', 'fileFilePublicationHref', fileFilePublicationHref)
            const localVarPath = `{file_file_publication_href}`
                .replace(`{${"file_file_publication_href"}}`, String(fileFilePublicationHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous task to publish file content.
         * @summary Create a file publication
         * @param {FileFilePublication} fileFilePublication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (fileFilePublication: FileFilePublication, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFilePublication' is not null or undefined
            assertParamExists('create', 'fileFilePublication', fileFilePublication)
            const localVarPath = `/pulp/api/v3/publications/file/file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileFilePublication, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  A FilePublication contains metadata about all the File Content in a particular File Repository Version. Once a FilePublication has been created, it can be hosted using the File Distribution API.
         * @summary List file publications
         * @param {string} [content] Content Unit referenced by HREF
         * @param {string} [contentIn] Content Unit referenced by HREF
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpCreated] ISO 8601 formatted dates are supported
         * @param {string} [pulpCreatedGt] Filter results where pulp_created is greater than value
         * @param {string} [pulpCreatedGte] Filter results where pulp_created is greater than or equal to value
         * @param {string} [pulpCreatedLt] Filter results where pulp_created is less than value
         * @param {string} [pulpCreatedLte] Filter results where pulp_created is less than or equal to value
         * @param {Array<string>} [pulpCreatedRange] Filter results where pulp_created is between two comma separated values
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (content?: string, contentIn?: string, limit?: number, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: Array<string>, repositoryVersion?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/publications/file/file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (content !== undefined) {
                localVarQueryParameter['content'] = content;
            }

            if (contentIn !== undefined) {
                localVarQueryParameter['content__in'] = contentIn;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (pulpCreated !== undefined) {
                localVarQueryParameter['pulp_created'] = (pulpCreated as any instanceof Date) ?
                    (pulpCreated as any).toISOString() :
                    pulpCreated;
            }

            if (pulpCreatedGt !== undefined) {
                localVarQueryParameter['pulp_created__gt'] = (pulpCreatedGt as any instanceof Date) ?
                    (pulpCreatedGt as any).toISOString() :
                    pulpCreatedGt;
            }

            if (pulpCreatedGte !== undefined) {
                localVarQueryParameter['pulp_created__gte'] = (pulpCreatedGte as any instanceof Date) ?
                    (pulpCreatedGte as any).toISOString() :
                    pulpCreatedGte;
            }

            if (pulpCreatedLt !== undefined) {
                localVarQueryParameter['pulp_created__lt'] = (pulpCreatedLt as any instanceof Date) ?
                    (pulpCreatedLt as any).toISOString() :
                    pulpCreatedLt;
            }

            if (pulpCreatedLte !== undefined) {
                localVarQueryParameter['pulp_created__lte'] = (pulpCreatedLte as any instanceof Date) ?
                    (pulpCreatedLte as any).toISOString() :
                    pulpCreatedLte;
            }

            if (pulpCreatedRange) {
                localVarQueryParameter['pulp_created__range'] = pulpCreatedRange.join(COLLECTION_FORMATS.csv);
            }

            if (repositoryVersion !== undefined) {
                localVarQueryParameter['repository_version'] = repositoryVersion;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  A FilePublication contains metadata about all the File Content in a particular File Repository Version. Once a FilePublication has been created, it can be hosted using the File Distribution API.
         * @summary Inspect a file publication
         * @param {string} fileFilePublicationHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (fileFilePublicationHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFilePublicationHref' is not null or undefined
            assertParamExists('read', 'fileFilePublicationHref', fileFilePublicationHref)
            const localVarPath = `{file_file_publication_href}`
                .replace(`{${"file_file_publication_href"}}`, String(fileFilePublicationHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicationsFileApi - functional programming interface
 * @export
 */
export const PublicationsFileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicationsFileApiAxiosParamCreator(configuration)
    return {
        /**
         *  A FilePublication contains metadata about all the File Content in a particular File Repository Version. Once a FilePublication has been created, it can be hosted using the File Distribution API.
         * @summary Delete a file publication
         * @param {string} fileFilePublicationHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(fileFilePublicationHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(fileFilePublicationHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous task to publish file content.
         * @summary Create a file publication
         * @param {FileFilePublication} fileFilePublication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(fileFilePublication: FileFilePublication, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(fileFilePublication, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  A FilePublication contains metadata about all the File Content in a particular File Repository Version. Once a FilePublication has been created, it can be hosted using the File Distribution API.
         * @summary List file publications
         * @param {string} [content] Content Unit referenced by HREF
         * @param {string} [contentIn] Content Unit referenced by HREF
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpCreated] ISO 8601 formatted dates are supported
         * @param {string} [pulpCreatedGt] Filter results where pulp_created is greater than value
         * @param {string} [pulpCreatedGte] Filter results where pulp_created is greater than or equal to value
         * @param {string} [pulpCreatedLt] Filter results where pulp_created is less than value
         * @param {string} [pulpCreatedLte] Filter results where pulp_created is less than or equal to value
         * @param {Array<string>} [pulpCreatedRange] Filter results where pulp_created is between two comma separated values
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(content?: string, contentIn?: string, limit?: number, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: Array<string>, repositoryVersion?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedfileFilePublicationResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(content, contentIn, limit, offset, ordering, pulpCreated, pulpCreatedGt, pulpCreatedGte, pulpCreatedLt, pulpCreatedLte, pulpCreatedRange, repositoryVersion, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  A FilePublication contains metadata about all the File Content in a particular File Repository Version. Once a FilePublication has been created, it can be hosted using the File Distribution API.
         * @summary Inspect a file publication
         * @param {string} fileFilePublicationHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(fileFilePublicationHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFilePublicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(fileFilePublicationHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PublicationsFileApi - factory interface
 * @export
 */
export const PublicationsFileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicationsFileApiFp(configuration)
    return {
        /**
         *  A FilePublication contains metadata about all the File Content in a particular File Repository Version. Once a FilePublication has been created, it can be hosted using the File Distribution API.
         * @summary Delete a file publication
         * @param {string} fileFilePublicationHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(fileFilePublicationHref: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(fileFilePublicationHref, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous task to publish file content.
         * @summary Create a file publication
         * @param {FileFilePublication} fileFilePublication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(fileFilePublication: FileFilePublication, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.create(fileFilePublication, options).then((request) => request(axios, basePath));
        },
        /**
         *  A FilePublication contains metadata about all the File Content in a particular File Repository Version. Once a FilePublication has been created, it can be hosted using the File Distribution API.
         * @summary List file publications
         * @param {string} [content] Content Unit referenced by HREF
         * @param {string} [contentIn] Content Unit referenced by HREF
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpCreated] ISO 8601 formatted dates are supported
         * @param {string} [pulpCreatedGt] Filter results where pulp_created is greater than value
         * @param {string} [pulpCreatedGte] Filter results where pulp_created is greater than or equal to value
         * @param {string} [pulpCreatedLt] Filter results where pulp_created is less than value
         * @param {string} [pulpCreatedLte] Filter results where pulp_created is less than or equal to value
         * @param {Array<string>} [pulpCreatedRange] Filter results where pulp_created is between two comma separated values
         * @param {string} [repositoryVersion] Repository Version referenced by HREF
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(content?: string, contentIn?: string, limit?: number, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: Array<string>, repositoryVersion?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedfileFilePublicationResponseList> {
            return localVarFp.list(content, contentIn, limit, offset, ordering, pulpCreated, pulpCreatedGt, pulpCreatedGte, pulpCreatedLt, pulpCreatedLte, pulpCreatedRange, repositoryVersion, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         *  A FilePublication contains metadata about all the File Content in a particular File Repository Version. Once a FilePublication has been created, it can be hosted using the File Distribution API.
         * @summary Inspect a file publication
         * @param {string} fileFilePublicationHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(fileFilePublicationHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<FileFilePublicationResponse> {
            return localVarFp.read(fileFilePublicationHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublicationsFileApi - object-oriented interface
 * @export
 * @class PublicationsFileApi
 * @extends {BaseAPI}
 */
export class PublicationsFileApi extends BaseAPI {
    /**
     *  A FilePublication contains metadata about all the File Content in a particular File Repository Version. Once a FilePublication has been created, it can be hosted using the File Distribution API.
     * @summary Delete a file publication
     * @param {string} fileFilePublicationHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationsFileApi
     */
    public _delete(fileFilePublicationHref: string, options?: any) {
        return PublicationsFileApiFp(this.configuration)._delete(fileFilePublicationHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous task to publish file content.
     * @summary Create a file publication
     * @param {FileFilePublication} fileFilePublication 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationsFileApi
     */
    public create(fileFilePublication: FileFilePublication, options?: any) {
        return PublicationsFileApiFp(this.configuration).create(fileFilePublication, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  A FilePublication contains metadata about all the File Content in a particular File Repository Version. Once a FilePublication has been created, it can be hosted using the File Distribution API.
     * @summary List file publications
     * @param {string} [content] Content Unit referenced by HREF
     * @param {string} [contentIn] Content Unit referenced by HREF
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [pulpCreated] ISO 8601 formatted dates are supported
     * @param {string} [pulpCreatedGt] Filter results where pulp_created is greater than value
     * @param {string} [pulpCreatedGte] Filter results where pulp_created is greater than or equal to value
     * @param {string} [pulpCreatedLt] Filter results where pulp_created is less than value
     * @param {string} [pulpCreatedLte] Filter results where pulp_created is less than or equal to value
     * @param {Array<string>} [pulpCreatedRange] Filter results where pulp_created is between two comma separated values
     * @param {string} [repositoryVersion] Repository Version referenced by HREF
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationsFileApi
     */
    public list(content?: string, contentIn?: string, limit?: number, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: Array<string>, repositoryVersion?: string, fields?: string, excludeFields?: string, options?: any) {
        return PublicationsFileApiFp(this.configuration).list(content, contentIn, limit, offset, ordering, pulpCreated, pulpCreatedGt, pulpCreatedGte, pulpCreatedLt, pulpCreatedLte, pulpCreatedRange, repositoryVersion, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  A FilePublication contains metadata about all the File Content in a particular File Repository Version. Once a FilePublication has been created, it can be hosted using the File Distribution API.
     * @summary Inspect a file publication
     * @param {string} fileFilePublicationHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationsFileApi
     */
    public read(fileFilePublicationHref: string, fields?: string, excludeFields?: string, options?: any) {
        return PublicationsFileApiFp(this.configuration).read(fileFilePublicationHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RemotesFileApi - axios parameter creator
 * @export
 */
export const RemotesFileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a file remote
         * @param {string} fileFileRemoteHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (fileFileRemoteHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRemoteHref' is not null or undefined
            assertParamExists('_delete', 'fileFileRemoteHref', fileFileRemoteHref)
            const localVarPath = `{file_file_remote_href}`
                .replace(`{${"file_file_remote_href"}}`, String(fileFileRemoteHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  FileRemote represents an external source of File Content.  The target url of a FileRemote must contain a file manifest, which contains the metadata for all files at the source.
         * @summary Create a file remote
         * @param {FileFileRemote} fileFileRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (fileFileRemote: FileFileRemote, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRemote' is not null or undefined
            assertParamExists('create', 'fileFileRemote', fileFileRemote)
            const localVarPath = `/pulp/api/v3/remotes/file/file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileFileRemote, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  FileRemote represents an external source of File Content.  The target url of a FileRemote must contain a file manifest, which contains the metadata for all files at the source.
         * @summary List file remotes
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] Filter labels by search string
         * @param {string} [pulpLastUpdated] ISO 8601 formatted dates are supported
         * @param {string} [pulpLastUpdatedGt] Filter results where pulp_last_updated is greater than value
         * @param {string} [pulpLastUpdatedGte] Filter results where pulp_last_updated is greater than or equal to value
         * @param {string} [pulpLastUpdatedLt] Filter results where pulp_last_updated is less than value
         * @param {string} [pulpLastUpdatedLte] Filter results where pulp_last_updated is less than or equal to value
         * @param {Array<string>} [pulpLastUpdatedRange] Filter results where pulp_last_updated is between two comma separated values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, pulpLastUpdated?: string, pulpLastUpdatedGt?: string, pulpLastUpdatedGte?: string, pulpLastUpdatedLt?: string, pulpLastUpdatedLte?: string, pulpLastUpdatedRange?: Array<string>, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/remotes/file/file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIn) {
                localVarQueryParameter['name__in'] = nameIn.join(COLLECTION_FORMATS.csv);
            }

            if (nameStartswith !== undefined) {
                localVarQueryParameter['name__startswith'] = nameStartswith;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (pulpLabelSelect !== undefined) {
                localVarQueryParameter['pulp_label_select'] = pulpLabelSelect;
            }

            if (pulpLastUpdated !== undefined) {
                localVarQueryParameter['pulp_last_updated'] = (pulpLastUpdated as any instanceof Date) ?
                    (pulpLastUpdated as any).toISOString() :
                    pulpLastUpdated;
            }

            if (pulpLastUpdatedGt !== undefined) {
                localVarQueryParameter['pulp_last_updated__gt'] = (pulpLastUpdatedGt as any instanceof Date) ?
                    (pulpLastUpdatedGt as any).toISOString() :
                    pulpLastUpdatedGt;
            }

            if (pulpLastUpdatedGte !== undefined) {
                localVarQueryParameter['pulp_last_updated__gte'] = (pulpLastUpdatedGte as any instanceof Date) ?
                    (pulpLastUpdatedGte as any).toISOString() :
                    pulpLastUpdatedGte;
            }

            if (pulpLastUpdatedLt !== undefined) {
                localVarQueryParameter['pulp_last_updated__lt'] = (pulpLastUpdatedLt as any instanceof Date) ?
                    (pulpLastUpdatedLt as any).toISOString() :
                    pulpLastUpdatedLt;
            }

            if (pulpLastUpdatedLte !== undefined) {
                localVarQueryParameter['pulp_last_updated__lte'] = (pulpLastUpdatedLte as any instanceof Date) ?
                    (pulpLastUpdatedLte as any).toISOString() :
                    pulpLastUpdatedLte;
            }

            if (pulpLastUpdatedRange) {
                localVarQueryParameter['pulp_last_updated__range'] = pulpLastUpdatedRange.join(COLLECTION_FORMATS.csv);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a file remote
         * @param {string} fileFileRemoteHref 
         * @param {PatchedfileFileRemote} patchedfileFileRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate: async (fileFileRemoteHref: string, patchedfileFileRemote: PatchedfileFileRemote, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRemoteHref' is not null or undefined
            assertParamExists('partialUpdate', 'fileFileRemoteHref', fileFileRemoteHref)
            // verify required parameter 'patchedfileFileRemote' is not null or undefined
            assertParamExists('partialUpdate', 'patchedfileFileRemote', patchedfileFileRemote)
            const localVarPath = `{file_file_remote_href}`
                .replace(`{${"file_file_remote_href"}}`, String(fileFileRemoteHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedfileFileRemote, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  FileRemote represents an external source of File Content.  The target url of a FileRemote must contain a file manifest, which contains the metadata for all files at the source.
         * @summary Inspect a file remote
         * @param {string} fileFileRemoteHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (fileFileRemoteHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRemoteHref' is not null or undefined
            assertParamExists('read', 'fileFileRemoteHref', fileFileRemoteHref)
            const localVarPath = `{file_file_remote_href}`
                .replace(`{${"file_file_remote_href"}}`, String(fileFileRemoteHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a file remote
         * @param {string} fileFileRemoteHref 
         * @param {FileFileRemote} fileFileRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (fileFileRemoteHref: string, fileFileRemote: FileFileRemote, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRemoteHref' is not null or undefined
            assertParamExists('update', 'fileFileRemoteHref', fileFileRemoteHref)
            // verify required parameter 'fileFileRemote' is not null or undefined
            assertParamExists('update', 'fileFileRemote', fileFileRemote)
            const localVarPath = `{file_file_remote_href}`
                .replace(`{${"file_file_remote_href"}}`, String(fileFileRemoteHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileFileRemote, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RemotesFileApi - functional programming interface
 * @export
 */
export const RemotesFileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RemotesFileApiAxiosParamCreator(configuration)
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a file remote
         * @param {string} fileFileRemoteHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(fileFileRemoteHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(fileFileRemoteHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  FileRemote represents an external source of File Content.  The target url of a FileRemote must contain a file manifest, which contains the metadata for all files at the source.
         * @summary Create a file remote
         * @param {FileFileRemote} fileFileRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(fileFileRemote: FileFileRemote, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFileRemoteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(fileFileRemote, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  FileRemote represents an external source of File Content.  The target url of a FileRemote must contain a file manifest, which contains the metadata for all files at the source.
         * @summary List file remotes
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] Filter labels by search string
         * @param {string} [pulpLastUpdated] ISO 8601 formatted dates are supported
         * @param {string} [pulpLastUpdatedGt] Filter results where pulp_last_updated is greater than value
         * @param {string} [pulpLastUpdatedGte] Filter results where pulp_last_updated is greater than or equal to value
         * @param {string} [pulpLastUpdatedLt] Filter results where pulp_last_updated is less than value
         * @param {string} [pulpLastUpdatedLte] Filter results where pulp_last_updated is less than or equal to value
         * @param {Array<string>} [pulpLastUpdatedRange] Filter results where pulp_last_updated is between two comma separated values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, pulpLastUpdated?: string, pulpLastUpdatedGt?: string, pulpLastUpdatedGte?: string, pulpLastUpdatedLt?: string, pulpLastUpdatedLte?: string, pulpLastUpdatedRange?: Array<string>, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedfileFileRemoteResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, pulpLastUpdated, pulpLastUpdatedGt, pulpLastUpdatedGte, pulpLastUpdatedLt, pulpLastUpdatedLte, pulpLastUpdatedRange, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a file remote
         * @param {string} fileFileRemoteHref 
         * @param {PatchedfileFileRemote} patchedfileFileRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdate(fileFileRemoteHref: string, patchedfileFileRemote: PatchedfileFileRemote, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdate(fileFileRemoteHref, patchedfileFileRemote, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  FileRemote represents an external source of File Content.  The target url of a FileRemote must contain a file manifest, which contains the metadata for all files at the source.
         * @summary Inspect a file remote
         * @param {string} fileFileRemoteHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(fileFileRemoteHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFileRemoteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(fileFileRemoteHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a file remote
         * @param {string} fileFileRemoteHref 
         * @param {FileFileRemote} fileFileRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(fileFileRemoteHref: string, fileFileRemote: FileFileRemote, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(fileFileRemoteHref, fileFileRemote, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RemotesFileApi - factory interface
 * @export
 */
export const RemotesFileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RemotesFileApiFp(configuration)
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a file remote
         * @param {string} fileFileRemoteHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(fileFileRemoteHref: string, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp._delete(fileFileRemoteHref, options).then((request) => request(axios, basePath));
        },
        /**
         *  FileRemote represents an external source of File Content.  The target url of a FileRemote must contain a file manifest, which contains the metadata for all files at the source.
         * @summary Create a file remote
         * @param {FileFileRemote} fileFileRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(fileFileRemote: FileFileRemote, options?: any): AxiosPromise<FileFileRemoteResponse> {
            return localVarFp.create(fileFileRemote, options).then((request) => request(axios, basePath));
        },
        /**
         *  FileRemote represents an external source of File Content.  The target url of a FileRemote must contain a file manifest, which contains the metadata for all files at the source.
         * @summary List file remotes
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] Filter labels by search string
         * @param {string} [pulpLastUpdated] ISO 8601 formatted dates are supported
         * @param {string} [pulpLastUpdatedGt] Filter results where pulp_last_updated is greater than value
         * @param {string} [pulpLastUpdatedGte] Filter results where pulp_last_updated is greater than or equal to value
         * @param {string} [pulpLastUpdatedLt] Filter results where pulp_last_updated is less than value
         * @param {string} [pulpLastUpdatedLte] Filter results where pulp_last_updated is less than or equal to value
         * @param {Array<string>} [pulpLastUpdatedRange] Filter results where pulp_last_updated is between two comma separated values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, pulpLastUpdated?: string, pulpLastUpdatedGt?: string, pulpLastUpdatedGte?: string, pulpLastUpdatedLt?: string, pulpLastUpdatedLte?: string, pulpLastUpdatedRange?: Array<string>, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedfileFileRemoteResponseList> {
            return localVarFp.list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, pulpLastUpdated, pulpLastUpdatedGt, pulpLastUpdatedGte, pulpLastUpdatedLt, pulpLastUpdatedLte, pulpLastUpdatedRange, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a file remote
         * @param {string} fileFileRemoteHref 
         * @param {PatchedfileFileRemote} patchedfileFileRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate(fileFileRemoteHref: string, patchedfileFileRemote: PatchedfileFileRemote, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.partialUpdate(fileFileRemoteHref, patchedfileFileRemote, options).then((request) => request(axios, basePath));
        },
        /**
         *  FileRemote represents an external source of File Content.  The target url of a FileRemote must contain a file manifest, which contains the metadata for all files at the source.
         * @summary Inspect a file remote
         * @param {string} fileFileRemoteHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(fileFileRemoteHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<FileFileRemoteResponse> {
            return localVarFp.read(fileFileRemoteHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a file remote
         * @param {string} fileFileRemoteHref 
         * @param {FileFileRemote} fileFileRemote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(fileFileRemoteHref: string, fileFileRemote: FileFileRemote, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.update(fileFileRemoteHref, fileFileRemote, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RemotesFileApi - object-oriented interface
 * @export
 * @class RemotesFileApi
 * @extends {BaseAPI}
 */
export class RemotesFileApi extends BaseAPI {
    /**
     * Trigger an asynchronous delete task
     * @summary Delete a file remote
     * @param {string} fileFileRemoteHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemotesFileApi
     */
    public _delete(fileFileRemoteHref: string, options?: any) {
        return RemotesFileApiFp(this.configuration)._delete(fileFileRemoteHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  FileRemote represents an external source of File Content.  The target url of a FileRemote must contain a file manifest, which contains the metadata for all files at the source.
     * @summary Create a file remote
     * @param {FileFileRemote} fileFileRemote 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemotesFileApi
     */
    public create(fileFileRemote: FileFileRemote, options?: any) {
        return RemotesFileApiFp(this.configuration).create(fileFileRemote, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  FileRemote represents an external source of File Content.  The target url of a FileRemote must contain a file manifest, which contains the metadata for all files at the source.
     * @summary List file remotes
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] 
     * @param {string} [nameContains] Filter results where name contains value
     * @param {string} [nameIcontains] Filter results where name contains value
     * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
     * @param {string} [nameStartswith] Filter results where name starts with value
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [pulpLabelSelect] Filter labels by search string
     * @param {string} [pulpLastUpdated] ISO 8601 formatted dates are supported
     * @param {string} [pulpLastUpdatedGt] Filter results where pulp_last_updated is greater than value
     * @param {string} [pulpLastUpdatedGte] Filter results where pulp_last_updated is greater than or equal to value
     * @param {string} [pulpLastUpdatedLt] Filter results where pulp_last_updated is less than value
     * @param {string} [pulpLastUpdatedLte] Filter results where pulp_last_updated is less than or equal to value
     * @param {Array<string>} [pulpLastUpdatedRange] Filter results where pulp_last_updated is between two comma separated values
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemotesFileApi
     */
    public list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, pulpLastUpdated?: string, pulpLastUpdatedGt?: string, pulpLastUpdatedGte?: string, pulpLastUpdatedLt?: string, pulpLastUpdatedLte?: string, pulpLastUpdatedRange?: Array<string>, fields?: string, excludeFields?: string, options?: any) {
        return RemotesFileApiFp(this.configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, pulpLastUpdated, pulpLastUpdatedGt, pulpLastUpdatedGte, pulpLastUpdatedLt, pulpLastUpdatedLte, pulpLastUpdatedRange, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous partial update task
     * @summary Update a file remote
     * @param {string} fileFileRemoteHref 
     * @param {PatchedfileFileRemote} patchedfileFileRemote 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemotesFileApi
     */
    public partialUpdate(fileFileRemoteHref: string, patchedfileFileRemote: PatchedfileFileRemote, options?: any) {
        return RemotesFileApiFp(this.configuration).partialUpdate(fileFileRemoteHref, patchedfileFileRemote, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  FileRemote represents an external source of File Content.  The target url of a FileRemote must contain a file manifest, which contains the metadata for all files at the source.
     * @summary Inspect a file remote
     * @param {string} fileFileRemoteHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemotesFileApi
     */
    public read(fileFileRemoteHref: string, fields?: string, excludeFields?: string, options?: any) {
        return RemotesFileApiFp(this.configuration).read(fileFileRemoteHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous update task
     * @summary Update a file remote
     * @param {string} fileFileRemoteHref 
     * @param {FileFileRemote} fileFileRemote 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemotesFileApi
     */
    public update(fileFileRemoteHref: string, fileFileRemote: FileFileRemote, options?: any) {
        return RemotesFileApiFp(this.configuration).update(fileFileRemoteHref, fileFileRemote, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RepositoriesFileApi - axios parameter creator
 * @export
 */
export const RepositoriesFileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a file repository
         * @param {string} fileFileRepositoryHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (fileFileRepositoryHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRepositoryHref' is not null or undefined
            assertParamExists('_delete', 'fileFileRepositoryHref', fileFileRepositoryHref)
            const localVarPath = `{file_file_repository_href}`
                .replace(`{${"file_file_repository_href"}}`, String(fileFileRepositoryHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  FileRepository represents a single file repository, to which content can be synced, added, or removed.
         * @summary Create a file repository
         * @param {FileFileRepository} fileFileRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (fileFileRepository: FileFileRepository, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRepository' is not null or undefined
            assertParamExists('create', 'fileFileRepository', fileFileRepository)
            const localVarPath = `/pulp/api/v3/repositories/file/file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileFileRepository, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  FileRepository represents a single file repository, to which content can be synced, added, or removed.
         * @summary List file repositorys
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] Filter labels by search string
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pulp/api/v3/repositories/file/file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameContains !== undefined) {
                localVarQueryParameter['name__contains'] = nameContains;
            }

            if (nameIcontains !== undefined) {
                localVarQueryParameter['name__icontains'] = nameIcontains;
            }

            if (nameIn) {
                localVarQueryParameter['name__in'] = nameIn.join(COLLECTION_FORMATS.csv);
            }

            if (nameStartswith !== undefined) {
                localVarQueryParameter['name__startswith'] = nameStartswith;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (pulpLabelSelect !== undefined) {
                localVarQueryParameter['pulp_label_select'] = pulpLabelSelect;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous task to create a new repository version.
         * @summary Modify Repository Content
         * @param {string} fileFileRepositoryHref 
         * @param {RepositoryAddRemoveContent} repositoryAddRemoveContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modify: async (fileFileRepositoryHref: string, repositoryAddRemoveContent: RepositoryAddRemoveContent, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRepositoryHref' is not null or undefined
            assertParamExists('modify', 'fileFileRepositoryHref', fileFileRepositoryHref)
            // verify required parameter 'repositoryAddRemoveContent' is not null or undefined
            assertParamExists('modify', 'repositoryAddRemoveContent', repositoryAddRemoveContent)
            const localVarPath = `{file_file_repository_href}modify/`
                .replace(`{${"file_file_repository_href"}}`, String(fileFileRepositoryHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repositoryAddRemoveContent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a file repository
         * @param {string} fileFileRepositoryHref 
         * @param {PatchedfileFileRepository} patchedfileFileRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate: async (fileFileRepositoryHref: string, patchedfileFileRepository: PatchedfileFileRepository, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRepositoryHref' is not null or undefined
            assertParamExists('partialUpdate', 'fileFileRepositoryHref', fileFileRepositoryHref)
            // verify required parameter 'patchedfileFileRepository' is not null or undefined
            assertParamExists('partialUpdate', 'patchedfileFileRepository', patchedfileFileRepository)
            const localVarPath = `{file_file_repository_href}`
                .replace(`{${"file_file_repository_href"}}`, String(fileFileRepositoryHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedfileFileRepository, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  FileRepository represents a single file repository, to which content can be synced, added, or removed.
         * @summary Inspect a file repository
         * @param {string} fileFileRepositoryHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (fileFileRepositoryHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRepositoryHref' is not null or undefined
            assertParamExists('read', 'fileFileRepositoryHref', fileFileRepositoryHref)
            const localVarPath = `{file_file_repository_href}`
                .replace(`{${"file_file_repository_href"}}`, String(fileFileRepositoryHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous task to sync file content.
         * @param {string} fileFileRepositoryHref 
         * @param {RepositorySyncURL} repositorySyncURL 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sync: async (fileFileRepositoryHref: string, repositorySyncURL: RepositorySyncURL, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRepositoryHref' is not null or undefined
            assertParamExists('sync', 'fileFileRepositoryHref', fileFileRepositoryHref)
            // verify required parameter 'repositorySyncURL' is not null or undefined
            assertParamExists('sync', 'repositorySyncURL', repositorySyncURL)
            const localVarPath = `{file_file_repository_href}sync/`
                .replace(`{${"file_file_repository_href"}}`, String(fileFileRepositoryHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repositorySyncURL, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a file repository
         * @param {string} fileFileRepositoryHref 
         * @param {FileFileRepository} fileFileRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (fileFileRepositoryHref: string, fileFileRepository: FileFileRepository, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRepositoryHref' is not null or undefined
            assertParamExists('update', 'fileFileRepositoryHref', fileFileRepositoryHref)
            // verify required parameter 'fileFileRepository' is not null or undefined
            assertParamExists('update', 'fileFileRepository', fileFileRepository)
            const localVarPath = `{file_file_repository_href}`
                .replace(`{${"file_file_repository_href"}}`, String(fileFileRepositoryHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileFileRepository, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoriesFileApi - functional programming interface
 * @export
 */
export const RepositoriesFileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepositoriesFileApiAxiosParamCreator(configuration)
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a file repository
         * @param {string} fileFileRepositoryHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(fileFileRepositoryHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(fileFileRepositoryHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  FileRepository represents a single file repository, to which content can be synced, added, or removed.
         * @summary Create a file repository
         * @param {FileFileRepository} fileFileRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(fileFileRepository: FileFileRepository, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFileRepositoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(fileFileRepository, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  FileRepository represents a single file repository, to which content can be synced, added, or removed.
         * @summary List file repositorys
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] Filter labels by search string
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedfileFileRepositoryResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous task to create a new repository version.
         * @summary Modify Repository Content
         * @param {string} fileFileRepositoryHref 
         * @param {RepositoryAddRemoveContent} repositoryAddRemoveContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modify(fileFileRepositoryHref: string, repositoryAddRemoveContent: RepositoryAddRemoveContent, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modify(fileFileRepositoryHref, repositoryAddRemoveContent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a file repository
         * @param {string} fileFileRepositoryHref 
         * @param {PatchedfileFileRepository} patchedfileFileRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdate(fileFileRepositoryHref: string, patchedfileFileRepository: PatchedfileFileRepository, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdate(fileFileRepositoryHref, patchedfileFileRepository, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  FileRepository represents a single file repository, to which content can be synced, added, or removed.
         * @summary Inspect a file repository
         * @param {string} fileFileRepositoryHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(fileFileRepositoryHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFileRepositoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(fileFileRepositoryHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous task to sync file content.
         * @param {string} fileFileRepositoryHref 
         * @param {RepositorySyncURL} repositorySyncURL 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sync(fileFileRepositoryHref: string, repositorySyncURL: RepositorySyncURL, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sync(fileFileRepositoryHref, repositorySyncURL, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a file repository
         * @param {string} fileFileRepositoryHref 
         * @param {FileFileRepository} fileFileRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(fileFileRepositoryHref: string, fileFileRepository: FileFileRepository, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(fileFileRepositoryHref, fileFileRepository, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RepositoriesFileApi - factory interface
 * @export
 */
export const RepositoriesFileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepositoriesFileApiFp(configuration)
    return {
        /**
         * Trigger an asynchronous delete task
         * @summary Delete a file repository
         * @param {string} fileFileRepositoryHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(fileFileRepositoryHref: string, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp._delete(fileFileRepositoryHref, options).then((request) => request(axios, basePath));
        },
        /**
         *  FileRepository represents a single file repository, to which content can be synced, added, or removed.
         * @summary Create a file repository
         * @param {FileFileRepository} fileFileRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(fileFileRepository: FileFileRepository, options?: any): AxiosPromise<FileFileRepositoryResponse> {
            return localVarFp.create(fileFileRepository, options).then((request) => request(axios, basePath));
        },
        /**
         *  FileRepository represents a single file repository, to which content can be synced, added, or removed.
         * @summary List file repositorys
         * @param {number} [limit] Number of results to return per page.
         * @param {string} [name] 
         * @param {string} [nameContains] Filter results where name contains value
         * @param {string} [nameIcontains] Filter results where name contains value
         * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
         * @param {string} [nameStartswith] Filter results where name starts with value
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpLabelSelect] Filter labels by search string
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedfileFileRepositoryResponseList> {
            return localVarFp.list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous task to create a new repository version.
         * @summary Modify Repository Content
         * @param {string} fileFileRepositoryHref 
         * @param {RepositoryAddRemoveContent} repositoryAddRemoveContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modify(fileFileRepositoryHref: string, repositoryAddRemoveContent: RepositoryAddRemoveContent, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.modify(fileFileRepositoryHref, repositoryAddRemoveContent, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous partial update task
         * @summary Update a file repository
         * @param {string} fileFileRepositoryHref 
         * @param {PatchedfileFileRepository} patchedfileFileRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdate(fileFileRepositoryHref: string, patchedfileFileRepository: PatchedfileFileRepository, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.partialUpdate(fileFileRepositoryHref, patchedfileFileRepository, options).then((request) => request(axios, basePath));
        },
        /**
         *  FileRepository represents a single file repository, to which content can be synced, added, or removed.
         * @summary Inspect a file repository
         * @param {string} fileFileRepositoryHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(fileFileRepositoryHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<FileFileRepositoryResponse> {
            return localVarFp.read(fileFileRepositoryHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous task to sync file content.
         * @param {string} fileFileRepositoryHref 
         * @param {RepositorySyncURL} repositorySyncURL 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sync(fileFileRepositoryHref: string, repositorySyncURL: RepositorySyncURL, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.sync(fileFileRepositoryHref, repositorySyncURL, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous update task
         * @summary Update a file repository
         * @param {string} fileFileRepositoryHref 
         * @param {FileFileRepository} fileFileRepository 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(fileFileRepositoryHref: string, fileFileRepository: FileFileRepository, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.update(fileFileRepositoryHref, fileFileRepository, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoriesFileApi - object-oriented interface
 * @export
 * @class RepositoriesFileApi
 * @extends {BaseAPI}
 */
export class RepositoriesFileApi extends BaseAPI {
    /**
     * Trigger an asynchronous delete task
     * @summary Delete a file repository
     * @param {string} fileFileRepositoryHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesFileApi
     */
    public _delete(fileFileRepositoryHref: string, options?: any) {
        return RepositoriesFileApiFp(this.configuration)._delete(fileFileRepositoryHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  FileRepository represents a single file repository, to which content can be synced, added, or removed.
     * @summary Create a file repository
     * @param {FileFileRepository} fileFileRepository 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesFileApi
     */
    public create(fileFileRepository: FileFileRepository, options?: any) {
        return RepositoriesFileApiFp(this.configuration).create(fileFileRepository, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  FileRepository represents a single file repository, to which content can be synced, added, or removed.
     * @summary List file repositorys
     * @param {number} [limit] Number of results to return per page.
     * @param {string} [name] 
     * @param {string} [nameContains] Filter results where name contains value
     * @param {string} [nameIcontains] Filter results where name contains value
     * @param {Array<string>} [nameIn] Filter results where name is in a comma-separated list of values
     * @param {string} [nameStartswith] Filter results where name starts with value
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [pulpLabelSelect] Filter labels by search string
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesFileApi
     */
    public list(limit?: number, name?: string, nameContains?: string, nameIcontains?: string, nameIn?: Array<string>, nameStartswith?: string, offset?: number, ordering?: string, pulpLabelSelect?: string, fields?: string, excludeFields?: string, options?: any) {
        return RepositoriesFileApiFp(this.configuration).list(limit, name, nameContains, nameIcontains, nameIn, nameStartswith, offset, ordering, pulpLabelSelect, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous task to create a new repository version.
     * @summary Modify Repository Content
     * @param {string} fileFileRepositoryHref 
     * @param {RepositoryAddRemoveContent} repositoryAddRemoveContent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesFileApi
     */
    public modify(fileFileRepositoryHref: string, repositoryAddRemoveContent: RepositoryAddRemoveContent, options?: any) {
        return RepositoriesFileApiFp(this.configuration).modify(fileFileRepositoryHref, repositoryAddRemoveContent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous partial update task
     * @summary Update a file repository
     * @param {string} fileFileRepositoryHref 
     * @param {PatchedfileFileRepository} patchedfileFileRepository 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesFileApi
     */
    public partialUpdate(fileFileRepositoryHref: string, patchedfileFileRepository: PatchedfileFileRepository, options?: any) {
        return RepositoriesFileApiFp(this.configuration).partialUpdate(fileFileRepositoryHref, patchedfileFileRepository, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  FileRepository represents a single file repository, to which content can be synced, added, or removed.
     * @summary Inspect a file repository
     * @param {string} fileFileRepositoryHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesFileApi
     */
    public read(fileFileRepositoryHref: string, fields?: string, excludeFields?: string, options?: any) {
        return RepositoriesFileApiFp(this.configuration).read(fileFileRepositoryHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous task to sync file content.
     * @param {string} fileFileRepositoryHref 
     * @param {RepositorySyncURL} repositorySyncURL 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesFileApi
     */
    public sync(fileFileRepositoryHref: string, repositorySyncURL: RepositorySyncURL, options?: any) {
        return RepositoriesFileApiFp(this.configuration).sync(fileFileRepositoryHref, repositorySyncURL, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous update task
     * @summary Update a file repository
     * @param {string} fileFileRepositoryHref 
     * @param {FileFileRepository} fileFileRepository 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesFileApi
     */
    public update(fileFileRepositoryHref: string, fileFileRepository: FileFileRepository, options?: any) {
        return RepositoriesFileApiFp(this.configuration).update(fileFileRepositoryHref, fileFileRepository, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RepositoriesFileVersionsApi - axios parameter creator
 * @export
 */
export const RepositoriesFileVersionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger an asynchronous task to delete a repository version.
         * @summary Delete a repository version
         * @param {string} fileFileRepositoryVersionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (fileFileRepositoryVersionHref: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRepositoryVersionHref' is not null or undefined
            assertParamExists('_delete', 'fileFileRepositoryVersionHref', fileFileRepositoryVersionHref)
            const localVarPath = `{file_file_repository_version_href}`
                .replace(`{${"file_file_repository_version_href"}}`, String(fileFileRepositoryVersionHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  FileRepositoryVersion represents a single file repository version.
         * @summary List repository versions
         * @param {string} fileFileRepositoryHref 
         * @param {string} [content] Content Unit referenced by HREF
         * @param {string} [contentIn] Content Unit referenced by HREF
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [number] 
         * @param {number} [numberGt] Filter results where number is greater than value
         * @param {number} [numberGte] Filter results where number is greater than or equal to value
         * @param {number} [numberLt] Filter results where number is less than value
         * @param {number} [numberLte] Filter results where number is less than or equal to value
         * @param {Array<number>} [numberRange] Filter results where number is between two comma separated values
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpCreated] ISO 8601 formatted dates are supported
         * @param {string} [pulpCreatedGt] Filter results where pulp_created is greater than value
         * @param {string} [pulpCreatedGte] Filter results where pulp_created is greater than or equal to value
         * @param {string} [pulpCreatedLt] Filter results where pulp_created is less than value
         * @param {string} [pulpCreatedLte] Filter results where pulp_created is less than or equal to value
         * @param {Array<string>} [pulpCreatedRange] Filter results where pulp_created is between two comma separated values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (fileFileRepositoryHref: string, content?: string, contentIn?: string, limit?: number, number?: number, numberGt?: number, numberGte?: number, numberLt?: number, numberLte?: number, numberRange?: Array<number>, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: Array<string>, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRepositoryHref' is not null or undefined
            assertParamExists('list', 'fileFileRepositoryHref', fileFileRepositoryHref)
            const localVarPath = `{file_file_repository_href}versions/`
                .replace(`{${"file_file_repository_href"}}`, String(fileFileRepositoryHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (content !== undefined) {
                localVarQueryParameter['content'] = content;
            }

            if (contentIn !== undefined) {
                localVarQueryParameter['content__in'] = contentIn;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }

            if (numberGt !== undefined) {
                localVarQueryParameter['number__gt'] = numberGt;
            }

            if (numberGte !== undefined) {
                localVarQueryParameter['number__gte'] = numberGte;
            }

            if (numberLt !== undefined) {
                localVarQueryParameter['number__lt'] = numberLt;
            }

            if (numberLte !== undefined) {
                localVarQueryParameter['number__lte'] = numberLte;
            }

            if (numberRange) {
                localVarQueryParameter['number__range'] = numberRange.join(COLLECTION_FORMATS.csv);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (pulpCreated !== undefined) {
                localVarQueryParameter['pulp_created'] = (pulpCreated as any instanceof Date) ?
                    (pulpCreated as any).toISOString() :
                    pulpCreated;
            }

            if (pulpCreatedGt !== undefined) {
                localVarQueryParameter['pulp_created__gt'] = (pulpCreatedGt as any instanceof Date) ?
                    (pulpCreatedGt as any).toISOString() :
                    pulpCreatedGt;
            }

            if (pulpCreatedGte !== undefined) {
                localVarQueryParameter['pulp_created__gte'] = (pulpCreatedGte as any instanceof Date) ?
                    (pulpCreatedGte as any).toISOString() :
                    pulpCreatedGte;
            }

            if (pulpCreatedLt !== undefined) {
                localVarQueryParameter['pulp_created__lt'] = (pulpCreatedLt as any instanceof Date) ?
                    (pulpCreatedLt as any).toISOString() :
                    pulpCreatedLt;
            }

            if (pulpCreatedLte !== undefined) {
                localVarQueryParameter['pulp_created__lte'] = (pulpCreatedLte as any instanceof Date) ?
                    (pulpCreatedLte as any).toISOString() :
                    pulpCreatedLte;
            }

            if (pulpCreatedRange) {
                localVarQueryParameter['pulp_created__range'] = pulpCreatedRange.join(COLLECTION_FORMATS.csv);
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  FileRepositoryVersion represents a single file repository version.
         * @summary Inspect a repository version
         * @param {string} fileFileRepositoryVersionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (fileFileRepositoryVersionHref: string, fields?: string, excludeFields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRepositoryVersionHref' is not null or undefined
            assertParamExists('read', 'fileFileRepositoryVersionHref', fileFileRepositoryVersionHref)
            const localVarPath = `{file_file_repository_version_href}`
                .replace(`{${"file_file_repository_version_href"}}`, String(fileFileRepositoryVersionHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeFields !== undefined) {
                localVarQueryParameter['exclude_fields'] = excludeFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger an asynchronous task to repair a repository version.
         * @param {string} fileFileRepositoryVersionHref 
         * @param {RepositoryVersion} repositoryVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repair: async (fileFileRepositoryVersionHref: string, repositoryVersion: RepositoryVersion, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileFileRepositoryVersionHref' is not null or undefined
            assertParamExists('repair', 'fileFileRepositoryVersionHref', fileFileRepositoryVersionHref)
            // verify required parameter 'repositoryVersion' is not null or undefined
            assertParamExists('repair', 'repositoryVersion', repositoryVersion)
            const localVarPath = `{file_file_repository_version_href}repair/`
                .replace(`{${"file_file_repository_version_href"}}`, String(fileFileRepositoryVersionHref));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repositoryVersion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoriesFileVersionsApi - functional programming interface
 * @export
 */
export const RepositoriesFileVersionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepositoriesFileVersionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Trigger an asynchronous task to delete a repository version.
         * @summary Delete a repository version
         * @param {string} fileFileRepositoryVersionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(fileFileRepositoryVersionHref: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(fileFileRepositoryVersionHref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  FileRepositoryVersion represents a single file repository version.
         * @summary List repository versions
         * @param {string} fileFileRepositoryHref 
         * @param {string} [content] Content Unit referenced by HREF
         * @param {string} [contentIn] Content Unit referenced by HREF
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [number] 
         * @param {number} [numberGt] Filter results where number is greater than value
         * @param {number} [numberGte] Filter results where number is greater than or equal to value
         * @param {number} [numberLt] Filter results where number is less than value
         * @param {number} [numberLte] Filter results where number is less than or equal to value
         * @param {Array<number>} [numberRange] Filter results where number is between two comma separated values
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpCreated] ISO 8601 formatted dates are supported
         * @param {string} [pulpCreatedGt] Filter results where pulp_created is greater than value
         * @param {string} [pulpCreatedGte] Filter results where pulp_created is greater than or equal to value
         * @param {string} [pulpCreatedLt] Filter results where pulp_created is less than value
         * @param {string} [pulpCreatedLte] Filter results where pulp_created is less than or equal to value
         * @param {Array<string>} [pulpCreatedRange] Filter results where pulp_created is between two comma separated values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(fileFileRepositoryHref: string, content?: string, contentIn?: string, limit?: number, number?: number, numberGt?: number, numberGte?: number, numberLt?: number, numberLte?: number, numberRange?: Array<number>, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: Array<string>, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRepositoryVersionResponseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(fileFileRepositoryHref, content, contentIn, limit, number, numberGt, numberGte, numberLt, numberLte, numberRange, offset, ordering, pulpCreated, pulpCreatedGt, pulpCreatedGte, pulpCreatedLt, pulpCreatedLte, pulpCreatedRange, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  FileRepositoryVersion represents a single file repository version.
         * @summary Inspect a repository version
         * @param {string} fileFileRepositoryVersionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(fileFileRepositoryVersionHref: string, fields?: string, excludeFields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(fileFileRepositoryVersionHref, fields, excludeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger an asynchronous task to repair a repository version.
         * @param {string} fileFileRepositoryVersionHref 
         * @param {RepositoryVersion} repositoryVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repair(fileFileRepositoryVersionHref: string, repositoryVersion: RepositoryVersion, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repair(fileFileRepositoryVersionHref, repositoryVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RepositoriesFileVersionsApi - factory interface
 * @export
 */
export const RepositoriesFileVersionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepositoriesFileVersionsApiFp(configuration)
    return {
        /**
         * Trigger an asynchronous task to delete a repository version.
         * @summary Delete a repository version
         * @param {string} fileFileRepositoryVersionHref 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(fileFileRepositoryVersionHref: string, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp._delete(fileFileRepositoryVersionHref, options).then((request) => request(axios, basePath));
        },
        /**
         *  FileRepositoryVersion represents a single file repository version.
         * @summary List repository versions
         * @param {string} fileFileRepositoryHref 
         * @param {string} [content] Content Unit referenced by HREF
         * @param {string} [contentIn] Content Unit referenced by HREF
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [number] 
         * @param {number} [numberGt] Filter results where number is greater than value
         * @param {number} [numberGte] Filter results where number is greater than or equal to value
         * @param {number} [numberLt] Filter results where number is less than value
         * @param {number} [numberLte] Filter results where number is less than or equal to value
         * @param {Array<number>} [numberRange] Filter results where number is between two comma separated values
         * @param {number} [offset] The initial index from which to return the results.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {string} [pulpCreated] ISO 8601 formatted dates are supported
         * @param {string} [pulpCreatedGt] Filter results where pulp_created is greater than value
         * @param {string} [pulpCreatedGte] Filter results where pulp_created is greater than or equal to value
         * @param {string} [pulpCreatedLt] Filter results where pulp_created is less than value
         * @param {string} [pulpCreatedLte] Filter results where pulp_created is less than or equal to value
         * @param {Array<string>} [pulpCreatedRange] Filter results where pulp_created is between two comma separated values
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(fileFileRepositoryHref: string, content?: string, contentIn?: string, limit?: number, number?: number, numberGt?: number, numberGte?: number, numberLt?: number, numberLte?: number, numberRange?: Array<number>, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: Array<string>, fields?: string, excludeFields?: string, options?: any): AxiosPromise<PaginatedRepositoryVersionResponseList> {
            return localVarFp.list(fileFileRepositoryHref, content, contentIn, limit, number, numberGt, numberGte, numberLt, numberLte, numberRange, offset, ordering, pulpCreated, pulpCreatedGt, pulpCreatedGte, pulpCreatedLt, pulpCreatedLte, pulpCreatedRange, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         *  FileRepositoryVersion represents a single file repository version.
         * @summary Inspect a repository version
         * @param {string} fileFileRepositoryVersionHref 
         * @param {string} [fields] A list of fields to include in the response.
         * @param {string} [excludeFields] A list of fields to exclude from the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(fileFileRepositoryVersionHref: string, fields?: string, excludeFields?: string, options?: any): AxiosPromise<RepositoryVersionResponse> {
            return localVarFp.read(fileFileRepositoryVersionHref, fields, excludeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger an asynchronous task to repair a repository version.
         * @param {string} fileFileRepositoryVersionHref 
         * @param {RepositoryVersion} repositoryVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repair(fileFileRepositoryVersionHref: string, repositoryVersion: RepositoryVersion, options?: any): AxiosPromise<AsyncOperationResponse> {
            return localVarFp.repair(fileFileRepositoryVersionHref, repositoryVersion, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoriesFileVersionsApi - object-oriented interface
 * @export
 * @class RepositoriesFileVersionsApi
 * @extends {BaseAPI}
 */
export class RepositoriesFileVersionsApi extends BaseAPI {
    /**
     * Trigger an asynchronous task to delete a repository version.
     * @summary Delete a repository version
     * @param {string} fileFileRepositoryVersionHref 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesFileVersionsApi
     */
    public _delete(fileFileRepositoryVersionHref: string, options?: any) {
        return RepositoriesFileVersionsApiFp(this.configuration)._delete(fileFileRepositoryVersionHref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  FileRepositoryVersion represents a single file repository version.
     * @summary List repository versions
     * @param {string} fileFileRepositoryHref 
     * @param {string} [content] Content Unit referenced by HREF
     * @param {string} [contentIn] Content Unit referenced by HREF
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [number] 
     * @param {number} [numberGt] Filter results where number is greater than value
     * @param {number} [numberGte] Filter results where number is greater than or equal to value
     * @param {number} [numberLt] Filter results where number is less than value
     * @param {number} [numberLte] Filter results where number is less than or equal to value
     * @param {Array<number>} [numberRange] Filter results where number is between two comma separated values
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {string} [pulpCreated] ISO 8601 formatted dates are supported
     * @param {string} [pulpCreatedGt] Filter results where pulp_created is greater than value
     * @param {string} [pulpCreatedGte] Filter results where pulp_created is greater than or equal to value
     * @param {string} [pulpCreatedLt] Filter results where pulp_created is less than value
     * @param {string} [pulpCreatedLte] Filter results where pulp_created is less than or equal to value
     * @param {Array<string>} [pulpCreatedRange] Filter results where pulp_created is between two comma separated values
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesFileVersionsApi
     */
    public list(fileFileRepositoryHref: string, content?: string, contentIn?: string, limit?: number, number?: number, numberGt?: number, numberGte?: number, numberLt?: number, numberLte?: number, numberRange?: Array<number>, offset?: number, ordering?: string, pulpCreated?: string, pulpCreatedGt?: string, pulpCreatedGte?: string, pulpCreatedLt?: string, pulpCreatedLte?: string, pulpCreatedRange?: Array<string>, fields?: string, excludeFields?: string, options?: any) {
        return RepositoriesFileVersionsApiFp(this.configuration).list(fileFileRepositoryHref, content, contentIn, limit, number, numberGt, numberGte, numberLt, numberLte, numberRange, offset, ordering, pulpCreated, pulpCreatedGt, pulpCreatedGte, pulpCreatedLt, pulpCreatedLte, pulpCreatedRange, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  FileRepositoryVersion represents a single file repository version.
     * @summary Inspect a repository version
     * @param {string} fileFileRepositoryVersionHref 
     * @param {string} [fields] A list of fields to include in the response.
     * @param {string} [excludeFields] A list of fields to exclude from the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesFileVersionsApi
     */
    public read(fileFileRepositoryVersionHref: string, fields?: string, excludeFields?: string, options?: any) {
        return RepositoriesFileVersionsApiFp(this.configuration).read(fileFileRepositoryVersionHref, fields, excludeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger an asynchronous task to repair a repository version.
     * @param {string} fileFileRepositoryVersionHref 
     * @param {RepositoryVersion} repositoryVersion 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoriesFileVersionsApi
     */
    public repair(fileFileRepositoryVersionHref: string, repositoryVersion: RepositoryVersion, options?: any) {
        return RepositoriesFileVersionsApiFp(this.configuration).repair(fileFileRepositoryVersionHref, repositoryVersion, options).then((request) => request(this.axios, this.basePath));
    }
}



